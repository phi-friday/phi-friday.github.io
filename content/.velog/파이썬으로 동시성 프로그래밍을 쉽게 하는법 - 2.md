---
title: 파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2
date: '2021-11-29T18:42:54.419+09:00'
tags:
  - anyio
  - async
  - python
  - '@all'
page: 파이썬 동시성 프로그래밍
summary: anyio로 작업 생성 + 작업간 정보 주고받기
---

비동기 프로그래밍의 핵심은 무엇일까? 저는 **작업을 생성**하고, 각 작업의 **전환점을 명시**하고, 각 작업간 **정보를 주고받는 것**이라고 생각합니다.

**전환점을 명시**하는 것은 `python`에 특별한 키워드로 추가됐기에, 명확합니다. 각 작업간 전환이 가능하다(`awaitable`이라고 하는 것 같습니다)는 것을 알리는 `async`와, 전환점을 명확하게 알리는 `await`입니다.

그렇다면 **작업을 생성**하고, **정보를 주고받는 것**은 어떻게 해야할까요?

## `anyio`의 작업 생성

`anyio`는 `trio`의 작업 생성 방식을 따라합니다. 그리고 `trio`는 **암시적 동시성**이 없습니다. 따라서 모든 기능은 위에서 아래로 실행합니다.

`trio`는 사용자가 작업을 생성할 때, 그 작업에 대한 책임을 지도록 설계되었습니다. 이 설계는 `async with` 블록으로 나타내며, 이 블록에서 `start_soon`메소드로 호출된 모든 `awaitable` 함수는 동시에 실행되는 하나의 작업으로 생성됩니다. `trio`는 이것을 `nursery`라고 명명했습니다.

`anyio`에서는 이러한 과정을 `task_group`이라 명명해서 보다 직관적으로 알 수 있게 했습니다. 실제 코드로 확인해보겠습니다.

```python
from datetime import datetime

import anyio


async def just_sleep(num: int, second: float):
    print(f"{datetime.today()}:: {num=}, {second=} sleep start")
    await anyio.sleep(second)
    print(f"{datetime.today()}:: {num=}, {second=} sleep end")


async def main():
    async with anyio.create_task_group() as task_group:
        for num in range(5):
            task_group.start_soon(just_sleep, num, 5)
        return


if __name__ == "__main__":
    print(f"{datetime.today()}:: main start")
    result = anyio.run(main)
    print(f"{datetime.today()}:: main end??? {result=}")
```

이 코드에서 실제로 실행되는 함수는 `main` 함수입니다. 이 함수의 코드를 확인해보면, 우선 `async with anyio.create_task_group`으로 `task_group`을 생성합니다. 그리고 이 `task_group` 블록 안에서 `task_group.start_soon`메소드를 이용하여 5개의 `just_sleep`을 호출했습니다.

따라서 이 `task_group` 블록에는, 총 5개의 `just_sleep` 작업이 예정되어있습니다. 하지만 `task_group` 블록을 나가기 전에, `return` 키워드를 작성해서, `task_group` 블록에 5개의 작업을 호출한 직후 해당 함수를 종료하도록 했습니다.

만약 의도한대로 실행된다면, 5개의 `just_sleep` 작업이 생성되지만, 그 직후 main 함수는 `None`을 반환하고, main end??? 는 main start 출력 이후 1초 내에 출력될 것입니다.

```log
2021-11-29 17:56:17.798277:: main start
2021-11-29 17:56:17.800793:: num=0, second=5 sleep start
2021-11-29 17:56:17.800829:: num=1, second=5 sleep start
2021-11-29 17:56:17.800853:: num=2, second=5 sleep start
2021-11-29 17:56:17.800869:: num=3, second=5 sleep start
2021-11-29 17:56:17.800884:: num=4, second=5 sleep start
2021-11-29 17:56:22.806281:: num=0, second=5 sleep end
2021-11-29 17:56:22.806401:: num=1, second=5 sleep end
2021-11-29 17:56:22.806443:: num=2, second=5 sleep end
2021-11-29 17:56:22.806479:: num=3, second=5 sleep end
2021-11-29 17:56:22.806513:: num=4, second=5 sleep end
2021-11-29 17:56:22.807098:: main end??? result=None
```

하지만 실제 결과는, `return`과 무관하게 생성한 작업이 모두 끝난 이후 `return`이 실행됩니다. 즉, 사용자는 작업을 생성할 때, 각 작업을 어떤식으로든 완료되는 것을 확인 할 의무가 있습니다. 만약 작업 도중 `return`을 실행할 일이 있다면, 그에 맞는 조건을 설정하여 해당 `task_group`을 종료시킨 다음 `return`하는 것이 맞습니다.

말이 길어졌기에, 요약하자면

> 1. `awaitable` 함수는 `async with anyio.create_task_group` 블록 내부에서 `task_group.start_soon` 메소드로 호출한다.
> 2. 생성된 작업은, 어떤식으로든 완료시켜야 한다.

이 2가지만 기억해도 큰 문제가 없습니다.

## `anyio`의 정보 주고받기

anyio에서 정보를 주고받을때 사용하는 것을 `stream`이라고 합니다. 이 `stream`은 크게 두가지로 분류되는데, 바이트 스트림과 객체 스트림입니다.

객체 스트림은 기존에 사용하던 큐와 거의 같은 형태로 사용이 가능합니다. `stream`의 버퍼 사이즈를 지정하고, 버퍼 사이즈 만큼 객체를 입력하고, 버퍼에 객체가 있으면 그 객체를 가져오는 간단한 방식입니다. `trio`에서는 `channel`이라고 명명합니다.

바이트 스트림은 약간 다릅니다. 만약 사용자가 `b'qwe'`, `b'rty'`라는 두개의 바이트 객체를 입력했다면, 이 스트림에서 객체를 받을 때, `b'qwe'`, `b'rty'`라고 받을 수도 있지만, `b'q'`, `b'wer'`, `b'ty'`라고 받을 수도 있고, `b'qwert'`, `b'y'`라고 받을 수도 있습니다. `trio`에서는 `stream`이라고 명명합니다.

실제로 `stream`을 사용하는 코드로 확인하겠습니다.

```python
from datetime import datetime
from random import uniform

import anyio
from anyio.abc import ObjectReceiveStream, ObjectSendStream


async def ping(num: int, send: ObjectSendStream):
    print(f"{datetime.today()}:: {num=}, ping start")
    async with send:
        sleep_time = uniform(0, 3)
        await anyio.sleep(sleep_time)
        await send.send((f"ping from {num=}, {sleep_time=}", sleep_time))
    print(f"{datetime.today()}:: {num=}, ping end")


async def pong(receive: ObjectReceiveStream):
    sleep_time_sum = 0
    print(f"{datetime.today()}:: pong start")
    async for text, sleep_time in receive:
        print(f"{datetime.today()}:: pong:: {text}")
        sleep_time_sum += sleep_time
    print(f"{datetime.today()}:: pong end:: {sleep_time_sum=}")


async def main():
    async with anyio.create_task_group() as task_group:
        send, receive = anyio.create_memory_object_stream(0)
        async with send:
            for num in range(5):
                task_group.start_soon(ping, num, send.clone())
        async with receive:
            task_group.start_soon(pong, receive.clone())


if __name__ == "__main__":
    result = anyio.run(main)
```

우선 `main`함수부터 확인하겠습니다.

`create_task_group`으로 `task_group` 블록을 생성합니다. 그리고 `create_memory_object_stream`으로 각 작업간 정보를 주고받기 위한 `stream`을 생성합니다.

> 이때 생성된 `stream`은 send와 receive 두개로 나뉘어 반환됩니다.

이어서 5개의 `ping`과 1개의 `pong` 작업을 호출해서, 실제로 `main`을 실행할 때 실행될 작업을 지정합니다.

여기서 사용되는 `async with send`와 `async with receive`는 안전한 프로그래밍을 위해 필요한 문법으로, 해당 블록이 끝나면 따로 `close` 메소드를 호출 할 필요 없이, 자동으로 해당 객체를 닫습니다.

그리고 `start_soon`으로 호출되는 각 작업에 send와 receive를 보낼 때 사용되는 `clone`메소드는, 해당 `stream`의 새로운 send와 receive를 생성해서 보내기 위해서 사용됩니다. 만약 send나 receive를 사용하는 작업이 하나가 아닐 때 `clone` 메소드를 사용하지 않는다면, 의도치 않은 `ClosedResourceError`를 만나게 될 수 있습니다.

`main`에서 호출된 작업은 간단합니다.
`ping`은 0~3초 사이의 랜덤한 시간동안 대기한 다음, 해당 시간에 대한 정보를 send를 이용해서 보냅니다.
`pong`은 receive를 통해 받은 정보를 출력하고, 합산합니다.
또한, 각 `ping` 작업은 `main`에서 사용된 방식과 같은 방식으로 `async with` 블록으로 구성되어 있으므로, 따로 `close` 메소드를 호출 할 필요가 없습니다.

이 방식은 상당히 유용한데, 모든 send가 닫히고, 더이상 버퍼에 정보가 없다면 `async for` 블록 또한 자동으로 닫히게 됩니다.

위 코드를 실행해보면 다음과 같은 출력을 확인할 수 있습니다.

```log
2021-11-29 18:34:55.095995:: num=0, ping start
2021-11-29 18:34:55.096041:: num=1, ping start
2021-11-29 18:34:55.096056:: num=2, ping start
2021-11-29 18:34:55.096068:: num=3, ping start
2021-11-29 18:34:55.096080:: num=4, ping start
2021-11-29 18:34:55.096091:: pong start
2021-11-29 18:34:55.348744:: num=4, ping end
2021-11-29 18:34:55.348931:: pong:: ping from num=4, sleep_time=0.25142686937439906
2021-11-29 18:34:56.042114:: num=3, ping end
2021-11-29 18:34:56.042310:: pong:: ping from num=3, sleep_time=0.9448073290170278
2021-11-29 18:34:56.779485:: num=1, ping end
2021-11-29 18:34:56.779686:: pong:: ping from num=1, sleep_time=1.6822150526554853
2021-11-29 18:34:56.925375:: num=2, ping end
2021-11-29 18:34:56.925595:: pong:: ping from num=2, sleep_time=1.8275787340996095
2021-11-29 18:34:57.535689:: num=0, ping end
2021-11-29 18:34:57.535911:: pong:: ping from num=0, sleep_time=2.4386441219878816
2021-11-29 18:34:57.536030:: pong end:: sleep_time_sum=7.144672107134403
```

바이트 스트림 또한 대동소이합니다.

요약하자면

> 1. 바이트 스트림과 객체 스트림으로 정보를 주고받을 수 있다.
> 2. send와 receive 두개로 나누어 사용한다.
> 3. send 또는 receive를 사용하는 작업이 여러개라면 `clone` 메소드를 사용한다.
> 4. `async with`, `async for`를 사용하면 좀 더 깔끔하고 명확하게 작성할 수 있다.
