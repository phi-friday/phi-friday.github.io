{"pageProps":{"tag":"fastapi","page":1,"max_page":3,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["í•¨ìˆ˜í˜• í”„ë¡œê·¸ëž˜ë°",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìžˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `Breaking` `changes`\n\nì´í‹€ì „ **`fastapi-users`** ì— í° ë³€í™”ê°€ ìƒê²¼ë‹¤. `v10` ë¦´ë¦¬ì¦ˆê°€ ê³µê°œëëŠ”ë°, `db` ëª¨ë¸ê³¼ ì—¬ëŸ¬ ì œë„¤ë¦­ íƒ€ìž…ì— ëŒ€í•œ ë³€í™”ê°€ ìƒê²¨ì„œ, `v10`ì„ ì´ìš©í•˜ë ¤ë©´ ëŒ€ì‘ íŒ¨ì¹˜ê°€ í•„ìˆ˜ì ì¸ ìƒí™©..\n\nì•„ëž˜ëŠ” í•´ë‹¹ ë¦´ë¦¬ì¦ˆì— ëŒ€í•œ ì „ë¬¸ì´ë‹¤.\n\n> ### [Breaking changes](https://github.com/fastapi-users/fastapi-users/releases/tag/v10.0.0)\n>\n> Version 10 marks important changes in how we manage User models and their ID.\n>\n> Before, we were relying only on Pydantic models to work with users. In particular the current_user dependency would return you an instance of UserDB, a Pydantic model. This proved to be quite problematic with some ORM if you ever needed to retrieve relationship data or make specific requests.\n>\n> Now, FastAPI Users is designed to always return you a native object for your ORM model, whether it's an SQLAlchemy model or a Beanie document. Pydantic models are now only used for validation and serialization inside the API.\n>\n> Before, we were forcing the use of UUID as primary key ID; a consequence of the design above. This proved to be quite problematic on some databases, like MongoDB which uses a special ObjectID format by default. Some SQL folks also prefer to use traditional auto-increment integers.\n>\n> Now, FastAPI Users is designed to use generic ID type. It means that you can use any type you want for your user's ID. By default, SQLAlchemy adapter still use UUID; but you can quite easily switch to another thing, like an integer. Beanie adapter for MongoDB will use native ObjectID by default, but it also can be overriden.\n\n### ìœ ì € ëª¨ë¸ ìƒì„± ë° ìˆ˜ì •\n\nê¸°ì¡´ `fastapi_users.models` ì—ì„œ `fastapi_users.schemas`ë¡œ ë°”ë€ ê²ƒ ì™¸ì— í¬ê²Œ ë‹¬ë¼ì§„ ê²ƒì€ ì—†ë‹¤. ì‚¬ì‹¤ ì´ì „ì— ì–˜ê¸°í–ˆë˜ `user` ì™€ `user_model`ì„ í†µí•©í•˜ëŠ” ìž‘ì—…ì„ ì´ë¯¸ í•œ ë‹¤ìŒ `v10` ë¦´ë¦¬ì¦ˆë¥¼ í™•ì¸í–ˆê¸°ì— ë”ìš± ê·¸ë ‡ê²Œ ëŠê»´ì¡Œë‹¤...\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar\n\nfrom fastapi_users import schemas\nfrom pydantic import EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field, select\n\nfrom ..db.session import async_session\nfrom .core import base_model, datetime_model, uuid_id_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\n_T = TypeVar(\"_T\", bound=\"user\")\nid_model = uuid_id_model\nuser_id_type = id_model.id_type\n\n\nclass user(id_model, datetime_model, base_model, table=True):\n    __tablename__: str = \"users\"\n\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: async_session, email: str\n    ) -> _T | None:\n        is_user_cur = await session.exec(select(cls).where(cls.email == email))\n        return is_user_cur.first()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.validate(self)\n\n\nclass user_read(schemas.BaseUser[user_id_type], datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(schemas.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(schemas.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n```\n\n### ì¸ì¦ ëª¨ë“ˆ ì œë„¤ë¦­ íƒ€ìž… ë®ì–´ì”Œìš°ê¸°\n\n**`fastapi-users`** ì—ì„œ ì›í•˜ëŠ” í˜•íƒœëŠ” `SQLAlchemyBaseUserTable`ë¥¼ ìƒì†í•œ í´ëž˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ì§€ë§Œ, **`sqlmodel`** ë„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³  **`fastapi-users`** ì˜ íƒ€ìž… ížŒíŠ¸ë„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³  ì‹¶ê¸°ì—, ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì—®ì–´ì¤„ ìƒˆë¡œìš´ ì œë„¤ë¦­ í´ëž˜ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.\n`# type: ignore`ë¥¼ ë‚¨ë°œí•˜ê¸°ì— ê·¸ë‹¤ì§€ ì¢‹ì€ ëª¨ìŠµì´ë¼ê³  ìƒê°ë˜ì§€ ì•Šì§€ë§Œ, ì´ê±° ì™¸ì— ë‹¹ìž¥ ìƒê°ë‚˜ëŠ” ë°©ë²•ì´ ì—†ê¸°ì— ì¼ë‹¨ ë„˜ì–´ê°€ìž.\n\n```bash\nâ¯ mkdir backend/app/services/authentication\nâ¯ mv backend/app/services/authentication.py backend/app/services/authentication/authentication.py\nâ¯ touch backend/app/services/authentication/__init__.py backend/app/services/authentication/convert.py\n```\n\n```python\n# backend/app/services/authentication/__init__.py\nfrom .authentication import *\n```\n\n```python\n# backend/app/services/authentication/convert.py\nfrom typing import Generic, TypeVar\n\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import AuthenticationBackend, JWTStrategy, Strategy\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n\nfrom ...models.core import base_model\nfrom ...models.user import user\n\nuser_id_type = user.id_type\n_T = TypeVar(\"_T\", bound=base_model)\n_D = TypeVar(\"_D\")\n\n# fmt: off\nclass user_db_class(SQLAlchemyUserDatabase[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass strategy_class(Strategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass jwt_strategy_class(JWTStrategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass auth_backend_class(AuthenticationBackend[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass user_manager_class(BaseUserManager[_T, _D], Generic[_T, _D]): ...  # type: ignore\nclass fastapi_users_class(FastAPIUsers[_T, _D], Generic[_T, _D]): ...  # type: ignore\n# fmt: on\n\n\nuser_manager_type = user_manager_class[user, user_id_type]\nstrategy_type = strategy_class[user, user_id_type]\n```\n\n### ë³€ê²½ì  ì¸ì¦ ëª¨ë“ˆì— ì ìš©\n\n```python\n# backend/app/services/authentication/authentication.py\nimport re\nfrom dataclasses import dataclass\nfrom re import Pattern\nfrom typing import AsyncGenerator, Sequence\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import IntegerIDMixin, InvalidPasswordException\nfrom fastapi_users.authentication import BearerTransport, Transport\n\nfrom ...core import config\nfrom ...db.session import async_session, get_session\nfrom ...models import user\nfrom .convert import (\n    auth_backend_class,\n    fastapi_users_class,\n    jwt_strategy_class,\n    strategy_class,\n    strategy_type,\n    user_db_class,\n    user_id_type,\n    user_manager_class,\n    user_manager_type,\n)\n\n\nasync def get_user_db(\n    session: async_session = Depends(get_session),\n) -> AsyncGenerator[user_db_class[user.user, user_id_type], None]:\n    yield user_db_class(session, user.user)\n\n\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\n\ndef create_strategy() -> strategy_class[user.user, user_id_type]:\n    return jwt_strategy_class(  # type: ignore\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n\ndef create_backend() -> list[auth_backend_class[user.user, user_id_type]]:\n    transport = create_transport()\n    return [\n        auth_backend_class(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n\n\nclass UserManager(IntegerIDMixin, user_manager_class[user.user, user_id_type]):\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+<>@\\#$%&\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -> None:\n        if len(password) < self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) > self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\n        for pattern in self.re_password_deny_list:\n            if pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\n        for pattern in self.re_password_need_list:\n            if not pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -> AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(\n    *backends: auth_backend_class[user.user, user_id_type],\n) -> fastapi_users_class[user.user, user_id_type]:\n    return fastapi_users_class(\n        get_user_manager=get_user_manager, auth_backends=backends\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -> Sequence[auth_backend_class[user.user, user_id_type]]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\nê½¤ ë§Žì´ ë°”ë€Œê¸´ í–ˆì§€ë§Œ, ì‹¤ì œë¡œ ì‚¬ìš©í• ë•ŒëŠ” ì´ë¦„ì •ë„ë§Œ ë°”ë€Œì§€ ì‚¬ìš©ë²• ìžì²´ëŠ” ë³€í•œê²Œ ì—†ë‹¤. ë°”ë€ ì´ë¦„ì— ë§žì¶°ì„œ ë¼ìš°í„°ì™€ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìˆ˜ì •í•´ì£¼ë©´, ì •ìƒì ìœ¼ë¡œ ìž‘ë™í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìžˆë‹¤.\n\nì´ë²ˆ ê¸°íšŒì— í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì–¼ë§ˆë‚˜ ì¢‹ì€ê±´ì§€ ì•Œê²Œëë‹¤.. ê¸´ê°€ë¯¼ê°€í• ë•Œ `pytest --tb=short` í•œë°©ì´ë©´ ì˜ë¬¸ì´ í•´ê²°ëœë‹¤.\n\nì‚¬ì‹¤ ë³€ê²½í• ê²Œ í•˜ë‚˜ ë” ë‚¨ê¸´ í–ˆì§€ë§Œ, ì´ê±° ì•„ì§ ì‹œë„í•´ë³´ì§€ ì•Šì•˜ë‹¤.\ní˜„ìž¬ í—¤ë”ë¥¼ ì‚¬ìš©í•œ ì¸ì¦ ë°©ì‹ì¸ë°, ì¿ í‚¤ë¥¼ ì‚¬ìš©í•˜ê³ , `access-token`ê³¼ `refresh-token`ì„ ì‚¬ìš©í•œ ë°©ì‹ìœ¼ë¡œ ë³€ê²½í•´ë³´ë ¤ í•œë‹¤. ë‹¤ë§Œ **`fastapi-users`** ìžì²´ì ìœ¼ë¡œëŠ” ì§€ì›í•˜ì§€ ì•Šê¸°ì—, ì§ì ‘ ìž‘ì„±í•  í•„ìš”ê°€ ìžˆì–´ì„œ ì•½ê°„ ê³ ë¯¼ì´ í•„ìš”í• ë“¯.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","date":"2022-05-07T23:00:58.369+09:00","tags":["fastapi","fastapi-users","python","sqlmodel","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ìž… ë¬¸ì œ ìž„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìžˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `Session`ì˜ ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ë³µë¶™\n\nì´ì „ê¹Œì§€ ê¸€ì—ì„œ ê³„ì†í•´ì„œ `AsyncSession`ì˜ íƒ€ìž… ê´€ë ¨ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ”ê²Œ ë„ˆë¬´ ì§œì¦ë‚˜ì„œ, ìž„ì‹œë¡œ ë•œë¹µìš© í´ëž˜ìŠ¤ë¥¼ ìƒì„±í•´ì„œ ì‚¬ìš©í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n````python\n# backend/app/db/session.py\n(...)\n\n_TSelectParam = TypeVar(\"_TSelectParam\")\n\nclass async_session(AsyncSession):\n    # sqlmodel.orm.session.Session\n    @overload\n    async def exec(\n        self,\n        statement: Select[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Result[_TSelectParam]:\n        ...\n\n    @overload\n    async def exec(\n        self,\n        statement: SelectOfScalar[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> ScalarResult[_TSelectParam]:\n        ...\n\n    async def exec(\n        self,\n        statement: Union[\n            Select[_TSelectParam],\n            SelectOfScalar[_TSelectParam],\n            Executable[_TSelectParam],\n        ],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Union[Result[_TSelectParam], ScalarResult[_TSelectParam]]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().exec(\n            statement,  # type: ignore\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def execute(\n        self,\n        statement: _Executable,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Optional[Mapping[str, Any]] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Result[Any]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        ***\n\n        ðŸš¨ You probably want to use `session.exec()` instead of `session.execute()`.\n\n        This is the original SQLAlchemy `session.execute()` method that returns objects\n        of type `Row`, and that you have to call `scalars()` to get the model objects.\n\n        For example:\n\n        ```Python\n        heroes = session.execute(select(Hero)).scalars().all()\n        ```\n\n        instead you could use `exec()`:\n\n        ```Python\n        heroes = session.exec(select(Hero)).all()\n        ```\n        \"\"\"\n        return await super().execute(  # type: ignore\n            statement,\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def get(\n        self,\n        entity: Type[_TSelectParam],\n        ident: Any,\n        options: Optional[Sequence[Any]] = None,\n        populate_existing: bool = False,\n        with_for_update: Optional[Union[Literal[True], Mapping[str, Any]]] = None,\n        identity_token: Optional[Any] = None,\n    ) -> Optional[_TSelectParam]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().get(\n            entity,\n            ident,\n            options=options,\n            populate_existing=populate_existing,\n            with_for_update=with_for_update,\n            identity_token=identity_token,\n        )\n````\n\nì£¼ì„ì„ ë³´ë©´ ì•Œê² ì§€ë§Œ, ê·¸ëƒ¥ `sqlmodel.orm.session.Session` ê°ì²´ì˜ ê° ë©”ì†Œë“œì˜ íƒ€ìž… ížŒíŠ¸ë¥¼ ê·¸ëŒ€ë¡œ ê°€ì ¸ì™”ë‹¤. ì´ì— ë§žì¶°ì„œ ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸ì˜ `AsyncSession`ë„ ëª¨ë‘ `async_session`ì— ëŒ€í•œ ìŠ¤í¬ë¦½íŠ¸ë¡œ ë³€í™˜í•´ì¤€ë‹¤. ê·¸ë¦¬ê³  í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë©´ ë¬¸ì œì—†ì´ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìžˆë‹¤.\n\n---\n\n## `datetime_model` ê´€ë ¨ ë¬¸ì œ í•´ê²°\n\n`datetime_model`ì˜ `datetime_attrs` ì†ì„±ì´ ì˜ë„í•œëŒ€ë¡œ ì¶œë ¤ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ìžˆì–´ì„œ ì¶”ê°€ë¡œ ìˆ˜ì •í–ˆë‹¤. `cls.__fields__.keys()` ë¥¼ `datetime_model.__fields__.keys()`ë¡œ ìˆ˜ì •í•œ ê²ƒì™¸ì— ëª¨ë‘ ë™ì¼í•˜ë‹¤.\n\n```python\n# backend/app/models/core.py\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -> _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def datetime_attrs(cls) -> set[str]:\n        return set(datetime_model.__fields__.keys())\n```\n\n## `id_model` ì„¸ë¶„í™”\n\nê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ `id_model`ì„ `int_id_model`ê³¼ `uuid_id_model`ë¡œ ì„¸ë¶„í™”í•´ì„œ ì‚¬ìš©í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n```python\n# backend/app/models/core.py\nfrom uuid import uuid4\nfrom pydantic import UUID4\n\n(...)\n\nclass id_model(fix_return_type_model):\n    @classmethod\n    @property\n    def id_type(cls) -> Any:\n        return cls.__fields__[\"id\"].type_\n\n\nclass int_id_model(id_model):\n    id: int | None = Field(None, primary_key=True)\n\n\nclass uuid_id_model(id_model):\n    id: UUID4 | None = Field(default_factory=uuid4, primary_key=True)\n```\n\n## `dependencies` ëª¨ë“ˆ ìƒì„±\n\nê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ `get_session`ì´ë‚˜ `get_current_user`ê°™ì€ `Depends`ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë˜ í•¨ìˆ˜ë¥¼ ë”°ë¡œ ê´€ë¦¬í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n```python\n# backend/app/dependencies/database.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\nfrom ..db.session import async_session\n\n\nasync def get_database(request: Request) -> AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -> AsyncIterator[async_session]:\n    async with async_session(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n```python\n# backend/app/dependencies/auth.py\nfrom ..services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\nget_user_manager = fastapi_user.get_user_manager\nget_backend = fastapi_user.get_backend\nget_transport = fastapi_user.get_transport\nget_strategy = fastapi_user.get_strategy\n```\n\n```python\n# backend/app/services/authentication/authentication.py\n(...)\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n    named_backends: dict[str, auth_backend_type] = field(default_factory=dict)\n\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -> Sequence[auth_backend_type]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def get_user_manager(self):\n        return self.users.get_user_manager\n\n    def find_backend(self, _val: str, /) -> auth_backend_type:\n        for backend in self.backends:\n            if backend.name == _val:\n                return backend\n        raise IndexError(f\"there is not auth_backend name: {_val}\")\n\n    def get_backend(self, _val: int | str = 0, /) -> auth_backend_type:\n        if isinstance(_val, int):\n            return self.backends[_val]\n\n        if (backend := self.named_backends.get(_val)) is None:\n            backend = self.named_backends[_val] = self.find_backend(_val)\n        return backend\n\n    def get_transport(self, _val: int | str = 0, /) -> Transport:\n        backend = self.get_backend(_val)\n        return backend.transport\n\n    def get_strategy(self, _val: int | str = 0, /):\n        backend = self.get_backend(_val)\n        return backend.get_strategy\n```\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ìž… ë¬¸ì œ ìž„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ìž… ë¬¸ì œ ìž„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","date":"2022-05-07T22:08:12.781+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìžˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## í† í° ë°œí–‰ ë°©ì‹ ìˆ˜ì •\n\n### ê¸°ì¡´ ì½”ë“œ ìˆ˜ì •\n\nì´ì „ì— í† í° ë°œí–‰ apië¥¼ ì§ì ‘ ìž‘ì„±í–ˆëŠ”ë°, ì¢€ ë” ì•Œì•„ë³´ë‹ˆ, **`fastapi-users`** ì—ì„œ ì œê³µí•˜ëŠ” `login` apiì™€ ë™ì¼í•˜ë‹¤. ë”°ë¼ì„œ í† í° ë°œí–‰ê³¼ ê´€ë ¨í•´ì„œ ì•½ê°„ì˜ ìˆ˜ì •ì„ ì§„í–‰í•œë‹¤.\n\n> #### backend/app/core/config.py\n>\n> í† í° ê²½ë¡œ ìˆ˜ì •\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token/login\"\n```\n\n---\n\n`AUTH_BACKEND_NAME` ì¶”ê°€\n\n```python\nAUTH_BACKEND_NAME = config(\n    \"AUTH_BACKEND_NAME\", cast=str, default=f\"{JWT_TOKEN_PREFIX}-jwt\"\n)\n```\n\n> #### backend/app/services/authentication.py\n>\n> í† í° ëª¨ë¸ ì œê±°\n\n```python\n# class token_model(BaseModel):\n#     access_token: str\n#     token_type: str = config.JWT_TOKEN_PREFIX\n>\n#     @classmethod\n#     def from_token(cls, token: str) -> \"token_model\":\n#         return cls(access_token=toke\n```\n\n---\n\n`AUTH_BACKEND_NAME` ì°¸ì¡° ì¶”ê°€\n\n```python\ndef create_backend() -> list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n```\n\n> #### backend/app/api/routes/token.py\n>\n> **`fastapi-users`** ë¼ìš°í„° ì¶”ê°€\n> íŽ¸ì˜ìƒ ë‹¹ë¶„ê°„ `requires_verification=False`ë¡œ í•œë‹¤.\n\n```python\n# name: auth:{backend.name}.login\nrouter.include_router(\n    fastapi_user.users.get_auth_router(\n        fastapi_user.backends[0], requires_verification=False\n    )\n)\n```\n\n---\n\nê¸°ì¡´ api ì œê±°\n\n```python\n# @router.post(\"\", name=\"users:create-token\")\n# async def create_token(\n#     credentials: OAuth2PasswordRequestForm = Depends(),\n#     user_manager: user_manager_type = fastapi_user.user_manager_depends,\n#     strategy: strategy_type = fastapi_user.strategy_depends(),\n# ) -> token_model:\n#     get_user = await user_manager.authenticate(credentials)\n#     if get_user is None or not get_user.is_active:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n#         )\n#     if not get_user.is_verified:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n#         )\n>\n#     token = await strategy.write_token(get_user)\n#     return token_model.from_token(token)\n```\n\n> #### backend/tests/test_users.py\n>\n> `api_name` ìˆ˜ì •\n\n```python\nclass TestAuthTokens:\n    api_name = f\"auth:{config.AUTH_BACKEND_NAME}.login\"\n```\n\n### **`fastapi-users`** ê°€ ì œê³µí•˜ëŠ” `api`ì˜ ê²€ì¦ ë°©ì‹\n\n> í˜„ìž¬ ì‚¬ìš©ì¤‘ì¸ **`fastapi-users`** ì˜ ë²„ì „ì€ `9.3.1`ì´ë¼ëŠ” ê²ƒì— ìœ ì˜í•œë‹¤.\n\nìš°ì„  ì´ë©”ì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ìœ ì €ë¥¼ ì¡°íšŒ í•œ ë‹¤ìŒ, ë¹„ë°€ë²ˆí˜¸ë¥¼ ê²€ì¦í•œë‹¤.\nê·¸ë¦¬ê³  í•´ë‹¹ ìœ ì € ë ˆì½”ë“œì˜ `is_active`ê°€ `True`ì¸ì§€ í™•ì¸í•˜ê³ , `requires_verification` ê°’ì— ë”°ë¼ `is_verified`ê°€ `True`ì¸ì§€ í™•ì¸í•œë‹¤.\n\nìœ ì €ê°€ ì¡´ìž¬í•˜ì§€ ì•Šê±°ë‚˜, `is_active=False`ì´ê±°ë‚˜, `requires_verification=True`ì´ë©´ì„œ `is_verified=False`ì¸ ê²½ìš° ì—ëŸ¬(400)ì„ ë°˜í™˜í•œë‹¤.\n\n## `TDD` ë°©ë²•ë¡ ì— ë”°ë¥¸ ë¡œê·¸ì¸ `api`\n\n### ì¼ë°˜ì ì¸ ë¡œê·¸ì¸ ë°©ì‹\n\n| ì‚¬ìš©ìž                             | í”„ë¡ íŠ¸ì—”ë“œ                                    | ë°±ì—”ë“œ                         |\n| ---------------------------------- | --------------------------------------------- | ------------------------------ |\n| `name`, `password` ìž…ë ¥            |                                               |                                |\n|                                    | `name`, `password` ë°±ì—”ë“œë¡œ ì „ì†¡              |                                |\n|                                    |                                               | `name`, `password` ìœ íš¨ì„± ê²€ì‚¬ |\n|                                    |                                               | í† í° ìƒì„±                      |\n|                                    |                                               | í† í° í”„ë¡ íŠ¸ì—”ë“œë¡œ ì „ì†¡         |\n|                                    | í† í° ìž„ì‹œ ì €ìž¥                                |\n| ë¡œê·¸ì¸ì´ í•„ìš”í•œ íŠ¹ì • íŽ˜ì´ì§€ë¡œ ì´ë™ |                                               |                                |\n|                                    | ì €ìž¥ëœ í† í°(Authorization í—¤ë”) ë°±ì—”ë“œë¡œ ì „ì†¡ |                                |\n|                                    |                                               | í† í° ìœ íš¨ì„± ê²€ì‚¬               |\n|                                    |                                               | ì»¨í…ì¸  ì „ì†¡                    |\n| ...                                | ...                                           | ...                            |\n\n### ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸ ì½”ë“œ ìž‘ì„±\n\n```python\n# backend/tests/test_users.py\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n(...)\n\nclass TestUserLogin:\n    api_name = \"users:login-email-and-password\"\n\n    async def test_user_can_login_successfully_and_receives_valid_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        login_data = {\"email\": test_user.email, \"password\": \"heatcavslakers@1\"}\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status.HTTP_200_OK\n        # check that token exists in response and has user encoded within it\n        token = res.json().get(\"access_token\")\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n            manager = UserManager(db)\n\n            read_user: user.user_model | None = await strategy.read_token(\n                token, manager\n            )\n        assert read_user is not None\n        assert read_user.name == test_user.name\n        assert read_user.email == test_user.email\n        # check that token is proper type\n        assert \"token_type\" in res.json()\n        assert res.json().get(\"token_type\") == \"bearer\"\n\n    @pytest.mark.parametrize(\n        \"credential, wrong_value, status_code\",\n        (\n            (\"email\", \"wrong@email.com\", 401),\n            (\"email\", None, 401),\n            (\"email\", \"notemail\", 401),\n            (\"password\", \"wrongpassword@1\", 401),\n            (\"password\", None, 401),\n        ),\n    )\n    async def test_user_with_wrong_creds_doesnt_receive_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        credential: str,\n        wrong_value: str,\n        status_code: int,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        user_data = test_user.dict()\n        user_data[\"password\"] = \"heatcavslakers@1\"\n        user_data[credential] = wrong_value\n        login_data = {\n            \"username\": user_data[\"email\"],\n            \"password\": user_data[\"password\"],  # insert password from parameters\n        }\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status_code\n        assert \"access_token\" not in res.json()\n```\n\nì‚¬ìš©ìžê°€ `email`ê³¼ `password`ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë³´ëƒˆì„ ë•Œ ì–»ê²Œ ë˜ëŠ” í† í°ìœ¼ë¡œ ë¶€í„°, **`fastapi_users`** ë¥¼ ì´ìš©í•´ì„œ ë¶ˆëŸ¬ì˜¨ ìœ ì € ë ˆì½”ë“œê°€ `test_user`ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.\n\nì—¬ê¸°ì„œ ë¡œê·¸ì¸ì˜ ê²½ìš° `json` íŒŒë¼ë¯¸í„°ê°€ ì•„ë‹Œ `data` íŒŒë¼ë¯¸í„°ë¡œ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ê³ , `content-type` í—¤ë”ë¡œ `application/x-www-form-urlencoded`ë¥¼ ê°€ì§€ê³  ìžˆì–´ì•¼ í•œë‹¤ëŠ” ì ì— ìœ ì˜í•œë‹¤.\n\n### ë¡œê·¸ì¸ `api` ìž‘ì„±\n\ní† í° ë°œí–‰ apiê°€ ë¡œê·¸ì¸ apiì´ë¯€ë¡œ, ë”°ë¡œ ìž‘ì„±í•  í•„ìš”ê°€ ì—†ë‹¤.\në§Œì•½ 400ì—ëŸ¬ê°€ ì•„ë‹Œ 401ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ê³  ì‹¶ë‹¤ë©´, ì´ì „ ì±•í„°ì²˜ëŸ¼ ì§ì ‘ ìž‘ì„±í•˜ë©´ ëœë‹¤.\n\n### ì¸ì¦ `Depends` ìƒì„±\n\nì´ì œ í† í°ì„ ë°œê¸‰ë°›ì€ ê²½ìš°ì—ë§Œ ì‚¬ìš©ì´ ê°€ëŠ¥í•œ apiì— ëŒ€í•œ ì¸ì¦ ì ˆì°¨ë¥¼ ì •ì˜í•´ì•¼í•œë‹¤. **`fastapi`** ì—ì„œëŠ” ì´ëŸ¬í•œ ê¸°ëŠ¥ì€ `Depends`ë¥¼ ì‚¬ìš©í•´ì„œ ìƒì„±í•  ìˆ˜ ìžˆë‹¤. ë˜í•œ, **`fastapi-users`** ì—ì„œ ê´€ë ¨ëœ í•¨ìˆ˜ë¥¼ ì´ë¯¸ ë§Œë“¤ì–´ì„œ ì œê³µí•˜ê³  ìžˆë‹¤. ìš°ì„  í…ŒìŠ¤íŠ¸ ì½”ë“œë¶€í„° ìž‘ì„±í•œë‹¤.\n\n```python\n# backend/tests/conftest.py\nfrom app.services.authentication import create_strategy\nfrom sqlmodel import select\n\n(...)\n\n@pytest.fixture\nasync def authorized_client(\n    client: AsyncClient, test_user: user.user_model\n) -> AsyncClient:\n    from app.core import config\n\n    strategy = create_strategy()\n    access_token = await strategy.write_token(user=test_user)  # type: ignore\n\n    client.headers[\"Authorization\"] = f\"{config.JWT_TOKEN_PREFIX} {access_token}\"\n    return client\n```\n\në°©ê¸ˆ ìž‘ì„±í•œ `authorized_client`ë¥¼ ì´ìš©í•´ì„œ ì¸ì¦ì´ í•„ìš”í•œ ë¼ìš°í„°ì— ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.\n\n> ì“°ë‹¤ë³´ë‹ˆ `user.user`ì™€ `user.user_model`ì´ ë”°ë¡œ ìžˆëŠ”ê²Œ ë„ˆë¬´ ë¶ˆíŽ¸í•œë°, ì–¸ì œ í•œë²ˆ í•©ì¹˜ëŠ” ì‹œë„ë¥¼ í•´ë´ì•¼ í• ë“¯. `AsyncSession` ê´€ë ¨í•´ì„œë„ ì–¸ì œí•œë²ˆ í•´ê²°ì„ í•´ì•¼í•  ê²ƒ ê°™ê³ ..\n\n```python\n# backend/tests/test_users.py\n(...)\n\nclass TestUserMe:\n    api_name = \"users:get-current-user\"\n\n    async def test_authenticated_user_can_retrieve_own_data(\n        self,\n        app: FastAPI,\n        authorized_client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await authorized_client.get(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_200_OK\n        res_dict: dict = res.json()\n        res_dict[\"hashed_password\"] = \"testpassword@1\"\n        read_user = user.user_model.validate(res_dict)\n        assert read_user.email == test_user.email\n        assert read_user.name == test_user.name\n        assert read_user.id == test_user.id\n\n    async def test_user_cannot_access_own_data_if_not_authenticated(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await client.get(app.url_path_for(\"users:get-current-user\"))\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n\n    @pytest.mark.parametrize(\n        \"jwt_prefix\",\n        (\n            (\"\",),\n            (\"value\",),\n            (\"Token\",),\n            (\"JWT\",),\n            (\"Swearer\",),\n        ),\n    )\n    async def test_user_cannot_access_own_data_with_incorrect_jwt_prefix(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        jwt_prefix: str,\n    ) -> None:\n        token = await strategy.write_token(test_user)\n        res = await client.get(\n            app.url_path_for(\"users:get-current-user\"),\n            headers={\"Authorization\": f\"{jwt_prefix} {token}\"},\n        )\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n```\n\nìœ„ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•  ìˆ˜ ìžˆëŠ” apië¥¼ ìž‘ì„±í•œë‹¤.\n\n```python\nfrom fastapi import Depends\n\n(...)\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\n\n(...)\n\n@router.get(\"/me\", response_model=user.user_read, name=\"users:get-current-user\")\nasync def get_currently_authenticated_user(\n    current_user: user.user = Depends(get_current_user),\n) -> user.user_model:\n    return current_user.to_model()\n```\n\n`optional=False, active=True, verified=False, superuser=False`ìœ¼ë¡œ ê°’ì„ ì§€ì •í–ˆê¸°ì—, í•´ë‹¹ í•¨ìˆ˜ëŠ” ì¼ì¹˜í•˜ëŠ” ìœ ì €ê°€ ì—†ê±°ë‚˜ `is_active` ê°’ì´ `False`ì´ë©´ ì—ëŸ¬(401)ì„ ë°˜í™˜í•œë‹¤.\n\ní…ŒìŠ¤íŠ¸ í†µê³¼ë„ ìž˜ë˜ê³ , **`swagger`** ì—ì„œë„ í™•ì¸ì´ ê°„ë‹¨í•œ apiê°€ ìƒì„±ëë‹¤. ìœ ì € ì¸ì¦ ê´€ë ¨í•´ì„œëŠ” ì‚¬ì‹¤ìƒ ì´ê²Œ ëì´ë‹¤. ì½”ë“œë¥¼ ì¡°ê¸ˆ ë” ì •ë¦¬í•  ìˆ˜ëŠ” ìžˆì§€ë§Œ í•µì‹¬ì€ ë¹„ìŠ·í•  ê²ƒì´ë‹¤.\n\në‹¤ìŒ ì±•í„°ì—ì„œëŠ” ìœ ì € í”„ë¡œí•„ì„ ì„¤ì •í•œë‹¤.\nê·¸ ì „ì— ì•žì—ì„œ ì–¸ê¸‰í•œ ìœ ì € ëª¨ë¸ê³¼ ê´€ë ¨ëœ ìˆ˜ì •ì„ ì§„í–‰í•  ìˆ˜ë„ ìžˆë‹¤.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","date":"2022-05-06T06:26:51.932+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -7- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 2","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìžˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## ì‹œìž‘í•˜ê¸° ì „ ë³€ê²½ì‚¬í•­\n\nì´ì „ ì±•í„°ì—ì„œ ë°ížŒ ê²ƒ ì²˜ëŸ¼, ë‹¤ì†Œ ë‚œìž¡í•˜ë‹¤ê³  ìƒê°ë˜ëŠ” ë¶€ë¶„ ëª‡ê°€ì§€ë¥¼ ìˆ˜ì •í•˜ìž. ì§€ê¸ˆ ìˆ˜ì •í•œ ë¶€ë¶„ì´ ë‚˜ì¤‘ì— ì› ì˜ˆì œì—ì„œ ë‹¤ë¥¸ ë°©í–¥ìœ¼ë¡œ ìˆ˜ì •ë  ìˆ˜ë„ ìžˆì§€ë§Œ, ê·¸ë•Œ ê°€ì„œ ìƒê°í•˜ìž.\n\n> ### backend/app/core/config.py\n>\n> $\\rightarrow$ 1ê°œ ì„¤ì • ë³€ìˆ˜ ìƒì„±\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token\"\n```\n\n> ### backend/app/db/engine.py\n\n```python\nfrom ..core.config import DATABASE_URL\n```\n\n$\\rightarrow$ `core.config` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ..core import config\n```\n\n> ### backend/app/models/user.py\n\n```python\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n>\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n$\\rightarrow$ `unique=True`ëŒ€ì‹  `index=True`ë¡œ ë³€ê²½\n\n```pythonê²½\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n>\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n> ### backend/app/services/authentication.py\n\n```python\nfrom ..core.config import SECRET_KEY\n```\n\n$\\rightarrow$ `core.config` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ..core import config\n```\n\n---\n\n```python\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n```\n\n$\\rightarrow$ `models.user` ì—ì„œ ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ..models import user\n```\n\n---\n\n```python\nfrom pydantic import BaseModel\n>\n(...)\n>\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n>\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n>\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n```\n\n$\\rightarrow$ ìƒˆë¡œ ì •ì˜\n\n---\n\n```python\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n```\n\n$\\rightarrow$ `config.TOKEN_PREFIX` ì„¤ì • ë³€ìˆ˜ ì°¸ì¡°\n\n```python\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n```\n\n---\n\n```python\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n>\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+<>@\\#$%&\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n>\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -> None:\n        if len(password) < self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) > self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n>\n        for pattern in self.re_password_deny_list:\n            if pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n>\n        for pattern in self.re_password_need_list:\n            if not pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n```\n\n$\\rightarrow$ ë¹„ë°€ë²ˆí˜¸ ìœ íš¨ì„± ê²€ì‚¬ ë¡œì§ ì¶”ê°€\n\n---\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n```\n\n$\\rightarrow$ ì›ëž˜ëŠ” ì‚­ì œí•˜ë ¤ í–ˆìœ¼ë‚˜, íŠ¹ì • ê¸°ëŠ¥ ì¶”ê°€ í›„ ì‚¬ìš©. ì˜ì¡´ì„±ì´ ë§ˆìŒì— ë“¤ì§€ ì•Šì§€ë§Œ, ì‚¬ì‹¤ìƒ ì„¤ì •ìš© ê°ì²´ë¼ ì¼ë‹¨ ë¬´ì‹œ.\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n>\n    @property\n    def backends(self) -> Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n>\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n>\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n---\n\nëìœ¼ë¡œ, **`fastapi-users`** ì˜ ê° í´ëž˜ìŠ¤ê°€ ì œë„¤ë¦­ì¸ ê²ƒì„ í™•ì¸í•´ì„œ, ì´ì „ì— ì •ì˜í•œ ìœ ì € ëª¨ë¸ì„ ì´ìš©í•´ì„œ íƒ€ìž… ížŒíŠ¸ë¥¼ ì¶”ê°€í–ˆë‹¤. ì´í•˜ ìŠ¤í¬ë¦½íŠ¸ ì „ë¬¸\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\nfrom typing import AsyncGenerator, Sequence\n>\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom pydantic import BaseModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n>\nfrom ..core import config\nfrom ..db.session import get_session\nfrom ..models import user\n>\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n>\n>\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n>\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n>\n>\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n>\n>\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n>\n>\ndef create_strategy() -> Strategy[user.user_create, user.user]:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n>\n>\ndef create_backend() -> list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n>\n>\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n>\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n>\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n>\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n>\n>\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -> AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n>\n>\ndef create_fastapi_users(\n    *backends: AuthenticationBackend[user.user_create, user.user],\n) -> FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user.user_base,\n        user_create_model=user.user_create,\n        user_update_model=user.user_update,\n        user_db_model=user.user,\n    )\n>\n>\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n>\n    @property\n    def backends(self) -> Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n>\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n>\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n> ### backend/app/services/token.py\n\n#### ìœ„ì¹˜ ë³€ê²½\n\n`backend/app/services/token.py`\n$\\rightarrow$ `backend/app/api/routes/token.py`\n\n---\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ í´ëž˜ìŠ¤ ì´ë¦„ ë³€ê²½ì— ë”°ë¥¸ ìˆ˜ì •\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import HTTP_400_BAD_REQUEST\n```\n\n$\\rightarrow$ `fastapi.status` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```pyhon\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom fastapi_users import models\n>\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -> dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n>\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n$\\rightarrow$ ìµœìƒìœ„ ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš© + `user_manager_type`, `strategy_type`, `token_model` ì‚¬ìš©\n\n```python\nfrom ...services.authentication import strategy_type, token_model, user_manager_type\n>\n(...)\n>\n@router.post(\"\", name=\"users:create-token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n    strategy: strategy_type = fastapi_user.strategy_depends(),\n) -> token_model:\n    get_user = await user_manager.authenticate(credentials)\n    if get_user is None or not get_user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not get_user.is_verified:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n>\n    token = await strategy.write_token(get_user)\n    return token_model.from_token(token)\n```\n\n> ### backend/app/api/routes/cleanings.py\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ í´ëž˜ìŠ¤ ì´ë¦„ ë³€ê²½ì— ë”°ë¥¸ ìˆ˜ì •\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom ...models.cleaning import (\n    cleaning_create,\n    cleaning_public,\n    cleaning_update,\n    cleanings,\n)\n```\n\n$\\rightarrow$ `models.cleaning` ì—ì„œ ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ...models import cleaning\n```\n\n> ### backend/app/api/routes/\\_\\_init\\_\\_.py\n\n```python\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n$\\rightarrow$ `auth` ëŒ€ì‹  `token`ìœ¼ë¡œ ë‹¨ì¼í™”\n\n```python\nrouter.include_router(token_router, prefix=\"/token\", tags=[\"token\"])\n```\n\n> ### backend/tests/conftest.py\n\n```python\n@pytest.fixture(\n    params=[pytest.param((\"asyncio\", {\"use_uvloop\": True}), id=\"asyncio+uvloop\")]\n)\ndef anyio_backend(request):\n    return request.param\n```\n\n$\\rightarrow$ **`pytest`** ë°±ì—”ë“œë¡œ **`anyio+uvloop`** ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì„¤ì • ì¶”ê°€\n\n> ### backend/tests/test_cleanings.py\n\n```python\npytestmark = pytest.mark.asyncio\n```\n\n$\\rightarrow$ **`pytest`** ë°±ì—”ë“œë¡œ **`anyio+uvloop`** ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì„¤ì • ì¶”ê°€\n\n```python\npytestmark = pytest.mark.anyio\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom fastapi import status\n```\n\n> ### ì‹ ê·œ ìƒì„±) backend/pytest.ini\n\n```bash\nâ¯ touch backend/pytest.ini\n```\n\n```yaml\n[pytest]\nfilterwarnings =\n    ignore::sqlalchemy.exc.SAWarning\n```\n\n$\\rightarrow$ **`sqlalchemy`** ì—ì„œ ë³´ë‚´ëŠ” ê²½ê³ ë¥¼ **`pytest`** ì—ì„œ ì¶œë ¥í•˜ì§€ ì•Šë„ë¡ ì„¤ì •\n\nìœ„ ìˆ˜ì •ì—ì„œ í™•ì¸í•  ìˆ˜ ìžˆë“¯ì´, **`pytest`** ë°±ì—”ë“œë¡œ **`anyio`** ë¥¼ ì“°ê¸° ë•Œë¬¸ì—, **`pytest-asyncio`** ëŠ” ì´ì œ í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ ì œê±°í•œë‹¤.\n\n```bash\nâ¯ poetry remove --dev pytest-asyncio\nâ¯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\nâ¯ docker-compose build\n```\n\nê¹œë°•í•˜ê³  ë„˜ì–´ê°„ ê²½ìš°ê°€ ìžˆì„í…ë°, í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë©´ ê¸ˆë°© ìˆ˜ì •í•  ìˆ˜ ìžˆë‹¤.\n\n## `TDD` ë°©ë²•ë¡ ì— ë”°ë¥¸ ìœ ì € ìƒì„± `api` ë§Œë“¤ê¸°\n\n### ë¼ìš°í„° ì¡´ìž¬ í™•ì¸\n\nì› ì˜ˆì œì˜ **jeffastor**ëŠ” íšŒì›ê°€ìž… apiì— ìš”ì²­ì„ ë³´ë‚´ê³  ì—ëŸ¬ ì½”ë“œë¥¼ í™•ì¸í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë§Œë“¤ì—ˆì§€ë§Œ, ìµœê·¼ì— **RESTful** api ìƒì„±ê³¼ ê´€ë ¨í•´ì„œ [ì¢‹ì€ ê¸€](https://sanghaklee.tistory.com/57)ì„ í™•ì¸í–ˆê¸°ì—, **OPTIONS** apië¡œ ëŒ€ì‹ í•˜ê³ ìž í•œë‹¤.\n\n```bash\nâ¯ touch backend/tests/test_users.py\n```\n\n```python\n# backend/tests/test_users.py\nimport pytest\nfrom fastapi import FastAPI, status\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.anyio\n\n\nclass TestUserRoutes:\n    api_name = \"users:get-allowed-methods\"\n\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.options(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_204_NO_CONTENT\n        assert not res.content\n        headers = res.headers\n        assert \"Allow\" in headers\n        allowed_methods_str = headers[\"Allow\"]\n        allowed_methods = {\n            method_str.strip().lower() for method_str in allowed_methods_str.split(\",\")\n        }\n        assert len(allowed_methods) > 0\n        for method_str in (\"post\",):\n            assert method_str in allowed_methods\n```\n\ní…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ë³´ë©´ ë‹¹ì—°ížˆ ì—ëŸ¬ê°€ ë‚˜ì˜¨ë‹¤.\n\n```bash\nroot@90b2a10bcb6d:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py F                                                                                 [100%]\n\n================================================= FAILURES ==================================================\n_____________________________ TestUserRoutes.test_routes_exist[asyncio+uvloop] ______________________________\ntests/test_users.py:10: in test_routes_exist\n    res = await client.options(app.url_path_for(\"users:get-allowed-methods\"))\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: in url_path_for\n    raise NoMatchFound()\nE   starlette.routing.NoMatchFound\n----------------------------------------- Captured stderr teardown ------------------------------------------\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\n========================================== short test summary info ==========================================\nFAILED tests/test_users.py::TestUserRoutes::test_routes_exist[asyncio+uvloop] - starlette.routing.NoMatchF...\n======================================= 1 failed, 39 passed in 4.52s ========================================\n```\n\nì´ì œ ì—ëŸ¬ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë¼ìš°í„°ë¥¼ ìƒì„±í•œë‹¤.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter, Response, status\n\nfrom ...services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.options(\"\", name=\"users:get-allowed-methods\")\nasync def get_allowed_user_methods() -> Response:\n    from functools import reduce\n\n    method_sets = [getattr(route, \"methods\") for route in router.routes]\n    all_methods = reduce(lambda left, right: left | right, method_sets, set())\n    all_methods_str = \", \".join(all_methods)\n\n    return Response(\n        status_code=status.HTTP_204_NO_CONTENT, headers={\"Allow\": all_methods_str}\n    )\n\n\n@router.post(\"\")\nasync def post_temp():\n    ...\n```\n\nìž„ì‹œë¡œ ê°€ì§œ **POST** apië¥¼ ì •ì˜í–ˆê¸°ì—, í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ë„ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.\n\n```bash\nroot@96deef95611e:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py .                                                                                 [100%]\n\n============================================ 40 passed in 4.03s =============================================\n```\n\n### íšŒì›ê°€ìž…\n\nìš°ì„ , ê¸°ì¡´ì— ìž‘ì„±í–ˆë˜ ìœ ì € ëª¨ë¸ì— ëŒ€í•´ ì´ë©”ì¼ë¡œ ê²€ìƒ‰í•  ìˆ˜ ìžˆëŠ” ë©”ì†Œë“œë¥¼ í•˜ë‚˜ ìƒì„±í•œë‹¤. ê´€ë ¨í•´ì„œ ì¢…ì¢… ì“°ì´ê¸° ë•Œë¬¸.\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar, cast\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlmodel.sql.expression import Select\n\n(...)\n\n_T = TypeVar(\"_T\", bound=\"user_model\")\n\n(...)\n\nclass user(user_base, models.BaseUserDB):\n    def to_model(self) -> \"user_model\":\n        return user_model.validate(self)\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: AsyncSession, email: str\n    ) -> _T | None:\n        is_user_cur = await session.exec(\n            cast(Select[_T], select(cls).where(cls.email == email))\n        )\n        return is_user_cur.first()\n```\n\n> ì•„ì§ **`sqlmodel`** ì˜ `async` ì§€ì›ì´ ë¶€ì¡±í•´ì„œ, `typing.cast`ë¥¼ ì´ìš©í•´ì„œ `Select` íƒ€ìž…ìœ¼ë¡œ ê°•ì œí•´ì„œ ì‚¬ìš©í–ˆë‹¤.\n\n> `user`ì™€ `user_model`ì„ í•˜ë‚˜ë¡œ í•©ì¹  ìˆ˜ ìžˆì„ ê²ƒ ê°™ì€ë°, ì´ê±´ ë‚˜ì¤‘ì— ì‹œê°„ë‚´ì„œ í™•ì¸í•´ë³¼ ìƒê°.\n\nì´ì œ **`fastapi-users`** ë¥¼ ì‚¬ìš©í•  ë•Œê°€ ì™”ë‹¤. ìš°ì„  í…ŒìŠ¤íŠ¸ ì½”ë“œë¶€í„° ìž‘ì„±í•œë‹¤.\n\n```python\n# backend/tests/test_users.py\nfrom app.models import user\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\nclass TestUserRegistration:\n    api_name = \"users:register-new-user\"\n\n    async def test_users_can_register_successfully(\n        self, app: FastAPI, client: AsyncClient, engine: AsyncEngine\n    ) -> None:\n        new_user = {\n            \"email\": \"shakira@shakira.io\",\n            \"name\": \"shakirashakira\",\n            \"password\": \"chantaje@1\",\n        }\n        # make sure user doesn't exist yet\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is None\n        # send post request to create user and ensure it is successful\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status.HTTP_201_CREATED\n        # ensure that the user now exists in the db\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is not None\n        assert is_user.email == new_user[\"email\"]\n        assert is_user.name == new_user[\"name\"]\n        # check that the user returned in the response is equal to the user in the database\n        created_user = user.user_model.validate(\n            res.json() | {\"hashed_password\": \"whatever\"}\n        )\n        exclude_attr_set = user.user_model.datetime_attrs | {\"id\", \"hashed_password\"}\n        assert created_user.dict(exclude=exclude_attr_set) == is_user.dict(\n            exclude=exclude_attr_set\n        )\n\n    @pytest.mark.parametrize(\n        \"attr, value, status_code\",\n        (\n            (\"email\", \"shakira@shakira.io\", 400),\n            (\"name\", \"sha\", 422),\n            (\"name\", \"shafasdfsdwerewfsdfxcvxcvxcv\", 422),\n            (\"email\", \"invalid_email@one@two.io\", 422),\n            (\"password\", \"short\", 422),\n            (\n                \"password\",\n                (\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                ),\n                422,\n            ),\n            (\"password\", \"pattern@\", 422),\n            (\"name\", \"shakira@#$%^<>\", 422),\n            (\"name\", \"ab\", 422),\n        ),\n    )\n    async def test_user_registration_fails_when_credentials_are_taken(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        attr: str,\n        value: str,\n        status_code: int,\n    ) -> None:\n        new_user = {\n            \"email\": \"nottaken@email.io\",\n            \"name\": \"not_taken_username\",\n            \"password\": \"freepassword@1\",\n        }\n        new_user[attr] = value\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status_code\n```\n\nì´ì œ ìœ„ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í†µê³¼í•  ìˆ˜ ìžˆì„ ê²ƒ ê°™ì€ apië¥¼ ìƒì„±í•œë‹¤.\n\n```python\nimport re\n\nimport orjson\nfrom fastapi import Body, HTTPException, Request\nfrom fastapi_users.manager import InvalidPasswordException, UserAlreadyExists\nfrom pydantic import ValidationError\n\nfrom ...models import user\nfrom ...services.authentication import user_manager_type\n\n(...)\n\nre_deny_name = re.compile(r\"[^a-zA-Z0-9_-]\")\n\n(...)\n\n@router.post(\n    \"\",\n    name=\"users:register-new-user\",\n    response_model=user.user_read,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def register_new_user(\n    request: Request,\n    new_user: user.user_create = Body(..., embed=True),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n):\n    if re_deny_name.search(new_user.name):\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=(\n                \"The name can only contain the following characters: \"\n                f\"{re_deny_name.pattern.replace('^','')}\"\n            ),\n        )\n\n    try:\n        return await user_manager.create(new_user, safe=True, request=request)\n    except UserAlreadyExists as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=(\n                \"That email is already taken. \"\n                \"Login with that email or register with another one.\"\n            ),\n        )\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=orjson.loads(exc.json()),\n        )\n    except InvalidPasswordException as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=exc.reason,\n        )\n\n```\n\n> ë”°ë¡œ ì ì§€ëŠ” ì•Šì•˜ì§€ë§Œ, **TDD** ë°©ë²•ë¡ ì„ ì¶©ì‹¤ížˆ ì´í–‰í•˜ë©´ì„œ ë§Œë“¤ì–´ì§„ í…ŒìŠ¤íŠ¸ ì½”ë“œì™€ apië‹¤.\n\nìœ„ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ë³´ë©´, ëª¨ë‘ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìžˆë‹¤.\n\n### í† í°\n\n**`fastapi-users`** ë•ë¶„ì— í† í° ë“±ì— ëŒ€í•œ ë³„ë‹¤ë¥¸ ìž‘ì—… ì—†ì´ ê¹”ë”í•˜ê²Œ ëë‚¬ì§€ë§Œ, ì› ì˜ˆì œì—ì„œëŠ” í† í°ê³¼ ê´€ë ¨ëœ ëª‡ê°€ì§€ ìž‘ì—…ì´ ì§„í–‰ëœë‹¤. í•´ë‹¹ ê³¼ì • ì¤‘ í•´ë³´ë©´ ì¢‹ì„ ê²ƒ ê°™ì€ ë¶€ë¶„ë§Œ ë”°ë¼ì„œ ì§„í–‰í•œë‹¤.\n\n#### í† í° ê´€ë ¨ ì„¤ì • ìˆ˜ì • ë° ì¶”ê°€\n\nì´ˆê¸°ì— ëŒ€ì¶© ìž‘ì„±í•´ë†¨ë˜ `SECRET_KEY` ë“±ì˜ ê°’ì„ ì§€ì •í•´ì¤€ë‹¤. ì´ ê°’ì„ ì§ì ‘ ìž‘ì„±í•˜ê¸° ë³´ë‹¤ëŠ” ê·¸ëƒ¥ í„°ë¯¸ë„ ëª…ë ¹ì–´ë¡œ ìƒì„±ëœ ìž„ì˜ì˜ ê°’ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.\n\n```bash\nâ¯ openssl rand -hex 32\n```\n\nì´ì œ ì´ ê°’ì„ `.env` íŒŒì¼ì— ì¶”ê°€í•˜ë©´ ëœë‹¤. ì´ ì™¸ì—ë„ ëª‡ëª‡ ê°’ì„ ì¶”ê°€ë¡œ ë” ì„¤ì •í•˜ëŠ”ë° ê° ê°’ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\n\n> `ACCESS_TOKEN_EXPIRE_SECONDS`: í† í°ì˜ ë§Œë£Œì‹œê°„(ì´ˆ)\n> `JWT_ALGORITHM`: í† í° ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜\n> `JWT_AUDIENCE`: í† í° ë°œê¸‰/ìˆ˜ì‹  ëŒ€ìƒ\n> `JWT_TOKEN_PREFIX`: í† í° íƒ€ìž…?(ì–˜ëŠ” í™•ì‹¤í•˜ì§€ ì•ŠìŒ)\n\nì´ì œ `config.py`ê°€ ìœ„ ê°’ì„ ìž˜ ì½ì„ ìˆ˜ ìžˆê²Œ ìˆ˜ì •í•œë‹¤.\n\n```python\n# backend/app/core/config.py\n(...)\n\nACCESS_TOKEN_EXPIRE_MINUTES = config(\n    \"ACCESS_TOKEN_EXPIRE_MINUTES\", cast=int, default=60 * 60\n)\nJWT_ALGORITHM = config(\"JWT_ALGORITHM\", cast=str, default=\"HS256\")\nJWT_AUDIENCE = config(\"JWT_AUDIENCE\", cast=str, default=\"phresh:auth\")\nJWT_TOKEN_PREFIX = config(\"JWT_TOKEN_PREFIX\", cast=str, default=\"Bearer\")\n\n(...)\n```\n\nê·¸ë¦¬ê³  ì´ ê°’ì„ ìž˜ ì°¸ì¡°í•  ìˆ˜ ìžˆë„ë¡ ìˆ˜ì •í•œë‹¤.\n\n```python\n# backend/app/services/authentication.py\n(...)\n\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = config.JWT_TOKEN_PREFIX\n\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n\n(...)\n\ndef create_strategy() -> Strategy[user.user_create, user.user]:\n    return JWTStrategy(\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n(...)\n```\n\ní…ŒìŠ¤íŠ¸ ì½”ë“œì—ì„œ ì‚¬ìš©í•  `fixture`ë¥¼ ì •ì˜í•œë‹¤. ì¤‘ë³µ ì´ë©”ì¼ì„ í—ˆìš©í•˜ì§€ ì•Šê¸°ì— ì£¼ì˜í•´ì„œ ìž‘ì„±í•œë‹¤.\n\n```python\n# backend/tests/conftest.py\nfrom app.models import user\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_user(engine: AsyncEngine) -> user.user_model:\n    new_user = user.user_create.parse_obj(\n        dict(\n            email=\"lebron@james.io\",\n            name=\"lebronjames\",\n            password=\"heatcavslakers@1\",\n        )\n    )\n\n    async with AsyncSession(engine, autocommit=False) as session:\n        db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n        manager = UserManager(db)\n\n        try:\n            new_user_db = await manager.get_by_email(new_user.email)\n        except UserNotExists:\n            new_user_db = await manager.create(new_user, safe=True)\n\n    return new_user_db.to_model()\n```\n\nì´ì œ ì´ `fixture`ë¥¼ ì´ìš©í•´ì„œ í† í°ì„ ë°œê¸‰ë°›ê³ , ê²€ì¦í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìž‘ì„±í•œë‹¤.\n\n> 2022.05.06. ì•„ëž˜ í…ŒìŠ¤íŠ¸ ì½”ë“œëŠ” ì‚¬ì‹¤ìƒ ë¬´ì˜ë¯¸í•˜ê¸°ì—, ì—†ì–´ë„ ì¢‹ë‹¤. **TDD**ì— ìµìˆ™í•˜ì§€ ì•Šì€ ê²ƒë„ ìžˆê³ , ì› ì˜ˆì œì˜ ë‚´ìš©ê³¼ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ apië¥¼ ìƒì„±í•˜ë‹¤ë³´ë‹ˆ í—·ê°ˆë ¤ì„œ ìž˜ëª» ìž‘ì„±í•œ ê²ƒ ê°™ë‹¤. ë‹¤ìŒ ì±•í„°ì˜ ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í™•ì¸í•˜ìž.\n\n```python\nclass TestAuthTokens:\n    api_name = \"users:create-token\"\n\n    async def test_can_create_access_token_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -> None:\n        access_token = await strategy.write_token(user=test_user)\n        creds = decode_jwt(\n            access_token,\n            str(config.SECRET_KEY),\n            [config.JWT_AUDIENCE],\n            [config.JWT_ALGORITHM],\n        )\n\n        assert creds.get(\"user_id\") is not None\n        user_id = creds[\"user_id\"]\n        assert config.JWT_AUDIENCE in creds[\"aud\"]\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            user_model = await session.get(user.user_model, user_id)\n        assert user_model is not None\n\n        assert user_model.name == test_user.name\n\n    async def test_token_missing_user_is_invalid(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(\n            url=app.url_path_for(self.api_name),\n            data={\"username\": \"unknown\", \"password\": \"testpassword@1\"},\n        )\n        assert res.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n```\n\nì› ì˜ˆì œëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì¡°ê¸ˆ ë” í’ë¶€í•˜ì§€ë§Œ, **`fastapi-users`** ë¥¼ ì‚¬ìš©ì¤‘ì´ê¸°ì—, ë¶ˆí•„ìš”í•œ ê³¼ì •ì´ë¼ ìƒê°ëë‹¤. ìœ„ í…ŒìŠ¤íŠ¸ ì½”ë“œì—ì„œ `strategy`ë¥¼ ì´ìš©í•˜ì—¬ ì§ì ‘ `access_token`ì„ ìƒì„±í•´ë³´ê¸°ë„ í•˜ê³  ë³µí˜¸í™”í•´ë³´ê¸°ë„ í•˜ë©°, `access_token`ë¡œ ë¶€í„° ìœ ì €ë¥¼ ë¶ˆëŸ¬ì˜¤ê¸°ë„ í•œë‹¤. ëìœ¼ë¡œ ì´ëŸ¬í•œ ê³¼ì •ì´ ì§„í–‰ë˜ëŠ” apië¥¼ í˜¸ì¶œí•´ë³´ê¸°ë„ í•œë‹¤.\n\ní…ŒìŠ¤íŠ¸ëŠ” ë¬¸ì œì—†ì´ ìž˜ ì§„í–‰ëë‹¤.\n\në‹¤ìŒ ì±•í„°ì—ì„œëŠ” ì§€ê¸ˆê¹Œì§€ ë§Œë“  ìœ ì € apië¡œ ë¡œê·¸ì¸ ë“±ì„ ì‹œë„í•œë‹¤. ì°¸ê³ ë¡œ, í˜„ìž¬ ì„ íƒí•œ ì „ëžµìœ¼ë¡œëŠ”, ì„œë²„ê°€ ì´ë¯¸ ë°œê¸‰í•œ í† í°ì— ëŒ€í•´ ì²˜ë¦¬ê°€ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ, ë¡œê·¸ì•„ì›ƒ ê¸°ëŠ¥ì„ ìƒì„±í•  ìˆ˜ ì—†ë‹¤.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -7- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 2","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -7- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 2","date":"2022-05-05T06:13:07.421+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -6- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„±","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìžˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `cleanings`, `users` ëª¨ë¸ ìƒì„± ë° ìˆ˜ì •\n\nì‹œìž‘ë¶€í„° ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì§„í–‰í•˜ê¸¸ëž˜ ì–´ë–¤ê±´ê°€ í–ˆë”ë‹ˆ, ì´ì „ì— ìž‘ì„±í–ˆë˜ `cleanings` í…Œì´ë¸”ì— ì‹œê°„ ì†ì„±(ìƒì„±, ìˆ˜ì •)ì„ sql ì„œë²„ì—ì„œ ìžë™ìœ¼ë¡œ ì²˜ë¦¬í•˜ë„ë¡ í•˜ëŠ” íŠ¸ë¦¬ê±°ë¥¼ ìƒì„±í•˜ëŠ” ê³¼ì •ì´ ìžˆì—ˆë‹¤. sql ì„œë²„ì—ì„œ ì§ì ‘ ì²˜ë¦¬í•˜ëŠ”ê²Œ ê°€ìž¥ ê°„ë‹¨í•œ ë°©ë²•ì´ë¼ê³  í•œë‹¤. ì¼ë‹¨ ë¬´ì‹œ.\n\nì´ê²ƒê³¼ëŠ” ë³„ê°œë¡œ, ì´ì „ì— ë§ˆì´ê·¸ë ˆì´ì…˜ ê´€ë ¨ ì½”ë“œ ìž‘ì„±ì‹œ ë¬¸ì œê°€ ìžˆëŠ” í˜•íƒœë¡œ ìž‘ì„±í•œ ê²ƒ ê°™ì•„ì„œ, ê´€ë ¨í•´ì„œ ì¡°ê¸ˆ ìˆ˜ì •í•œë‹¤.\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -> None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\nì´ì œ ì› ì˜ˆì œì™€ ê°™ì´, ë‹¤ìš´ê·¸ë ˆì´ë“œ í›„, ì‹œê°„ ì†ì„±ë¶€í„° ì¶”ê°€í•œ ë‹¤ìŒ, ìœ ì € ê´€ë ¨ í…Œì´ë¸”ì„ ì„¤ì •í•˜ê³  ì—…ê·¸ë ˆì´ë“œë¥¼ ì‹¤ì‹œí•œë‹¤. ì› ì˜ˆì œì™€ ìˆœì„œë¥¼ ë§žì¶°ê°€ê¸° ìœ„í•´ ì•½ê°„ ê¼¬ì¸ ëŠë‚Œì´ ìžˆëŠ”ë°, ì§€ê¸ˆ ìž‘ì„±í•˜ëŠ” ìœ ì € í…Œì´ë¸”ì€ **`fastapi-users`** ì—ì„œ ìž‘ì„±í•˜ëŠ” ëª¨ë¸ í˜•íƒœë¥¼ ë”°ë¼ê°„ë‹¤.\n\n```bash\nroot@c62cf3d05043:/backend# alembic downgrade base\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running downgrade f721febf752b -> , create account table\n```\n\n### ì‹œê°„ ì†ì„± ê´€ë ¨ ì½”ì–´ ëª¨ë¸ ì¶”ê°€\n\n```python\n# backend/app/models/core.py\nfrom datetime import datetime\n\n(...)\n\n_D = TypeVar(\"_D\", bound=\"datetime_model\")\n\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -> _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def attrs(cls) -> set[str]:\n        return set(cls.__fields__.keys())\n```\n\n### ì‹œê°„ ì†ì„± ì¶”ê°€ë¡œ ì¸í•œ ê¸°ì¡´ ëª¨ë¸ ë³€ê²½ì  ëŒ€ì‘ ìˆ˜ì •\n\n> ì•„ëž˜ ë‚´ìš©ì€ ë‹¨ìˆœížˆ ì‹œê°„ ì†ì„± ì¶”ê°€ë¡œ ì¸í•´ ì½”ë“œê°€ ë„ˆë¬´ ë‚˜ì—´ë¼ìžˆì–´ì„œ ì ‘ì–´ë†“ê³  ì‹¶ì§€ë§Œ velogê°€ í•´ë‹¹ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.. velogì—ì„œ ìžë™ ìƒì„±ëœ ëª©ì°¨ë¥¼ ì„ íƒí•´ì„œ ë‹¤ìŒ í•­ëª©ìœ¼ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìžˆë‹¤.\n\n```python\n# backend/app/models/cleaning.py\n(...)\n\nfrom .core import base_model, datetime_model, id_model\n\n(...)\n\nclass cleanings(id_model, datetime_model, cleaning_base, table=True):\n    name: str = Field(index=True)\n    cleaning_type: cleaning_type_enum = Field(\n        cleaning_type_enum.spot_clean,\n        sa_column_kwargs={\"server_default\": cleaning_type_enum.spot_clean},\n    )\n    price: price_decimal_type\n\n(...)\n```\n\n```python\n# backend/tests/test_cleaning.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\nimport orjson\nimport pytest\nfrom app.models.cleaning import cleaning_create, cleanings\nfrom app.models.core import datetime_model\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n# decorate all tests with @pytest.mark.asyncio\npytestmark = pytest.mark.asyncio\n\n\n@pytest.fixture\ndef new_cleaning():\n    return cleaning_create.parse_obj(\n        dict(\n            name=\"test cleaning\",\n            description=\"test description\",\n            price=0.00,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n\n\nclass TestCleaningsRoutes:\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCreateCleaning:\n    async def test_valid_input_creates_cleaning(\n        self, app: FastAPI, client: AsyncClient, new_cleaning: cleaning_create\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": orjson.loads(new_cleaning.json())},\n        )\n        assert res.status_code == HTTP_201_CREATED\n\n        created_cleaning = cleaning_create(**res.json())\n        assert created_cleaning == new_cleaning\n\n    @pytest.mark.parametrize(\n        \"invalid_payload, status_code\",\n        (\n            (None, 422),\n            ({}, 422),\n            ({\"name\": \"test_name\"}, 422),\n            ({\"price\": 10.00}, 422),\n            ({\"name\": \"test_name\", \"description\": \"test\"}, 422),\n        ),\n    )\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient, invalid_payload: dict, status_code: int\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": invalid_payload},\n        )\n        assert res.status_code == status_code\n\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning.dict(exclude=datetime_model.attrs) == test_cleaning.dict(\n            exclude=datetime_model.attrs\n        )\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [\n            cleanings.validate(l).dict(exclude=datetime_model.attrs) for l in json\n        ]\n        assert test_cleaning.dict(exclude=datetime_model.attrs) in all_cleanings\n\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(test_cleaning.id),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -> None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -> None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate ê´€ë ¨ ë¬¸ì œ í•´ê²° ì „ê¹Œì§€ëŠ” ì´ë ‡ê²Œ..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -> None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n    from app.models.core import datetime_model\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\nì´ë ‡ê²Œ ìˆ˜ì •í•˜ë©´ ì¶”ê°€, ìˆ˜ì • ì‹œê°„ ì†ì„±ì„ ë¬¸ì œì—†ì´ ì‚¬ìš©í•  ìˆ˜ ìžˆë‹¤..\ní° ë¬¸ì œê°€ ì—†ë‹¤ë©´ ê·¸ëƒ¥ íŠ¸ë¦¬ê±°ë¥¼ ì´ìš©í•˜ìž.\n\n### `users` ëª¨ë¸ ìƒì„±\n\n```bash\nâ¯ poetry add 'fastapi-users[sqlalchemy2]'\nâ¯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\nâ¯ touch backend/app/models/user.py\nâ¯ docker-compose up --build\n```\n\nì› ì˜ˆì œì—ì„œ **`JWT`** ë¥¼ ì‚¬ìš©í•˜ê¸°ì— ë”°ë¼ê°„ë‹¤.\n\n```python\n# backend/app/models/user.py\nfrom uuid import uuid4\n\nfrom fastapi_users import models\nfrom pydantic import UUID4, EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field\n\nfrom .core import base_model, datetime_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\nclass user_base(models.BaseUser, datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(models.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(models.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_read(user_base):\n    ...\n\n\nclass user(user_base, models.BaseUserDB):\n    ...\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\nìœ„ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì •ì˜í•œ ëª¨ë¸ì€, **`pydantic`** ì˜ `BaseModel`ì„ ìƒì†ë°›ëŠ”, **`fastapi-users`** ì—ì„œ ì •ì˜ëœ ëª¨ë¸ì„ ìƒì†ë°›ì•„ì„œ ì •ì˜í•œë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ê°€ì§€ê³  ìžˆëŠ” ì†ì„±ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\n\n> `id` : `UUID`ë¡œ ìž„ì˜ ìƒì„±\n> `email`: `xxx@yyy.zz`ì˜ í˜•íƒœë¡œ êµ¬ì„±ëœ ë¬¸ìžì—´\n> `is_active`: í•´ë‹¹ ìœ ì € ë ˆì½”ë“œê°€ í™œì„±í™”ëœ ìƒíƒœì¸ì§€ í™•ì¸\n> `is_superuser`: í•´ë‹¹ ìœ ì €ê°€ ê´€ë¦¬ìžì¸ì§€ í™•ì¸\n> `is_verified`: ì„ íƒì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ, í•´ë‹¹ ìœ ì €ì— ëŒ€í•œ ì¶”ê°€ì ì¸ ê²€ì¦ í†µê³¼ ì—¬ë¶€ë¥¼ í™•ì¸. í”ížˆ ì´ë©”ì¼ë¡œ ê²€ì¦ì„ ì§„í–‰í•¨.\n> `password`: í•´ë‹¹ ìœ ì €ê°€ ë¡œê·¸ì¸ì‹œ ì‚¬ìš©í•˜ëŠ” ë¹„ë°€ë²ˆí˜¸ë¡œ, ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ì—ëŠ” `hashed_password` ì†ì„±ìœ¼ë¡œ ì•”í˜¸í™” í›„ ì €ìž¥ëœë‹¤.\n\nì¶”ê°€ì ìœ¼ë¡œ í•„ìš”í•œ ì†ì„±ì´ ìžˆë‹¤ë˜ê°€, ì œì•½ì‚¬í•­ì´ ìžˆë‹¤ë©´ ìœ„ ìŠ¤í¬ë¦½íŠ¸ì™€ ê°™ì´ ëª¨ë¸ì— ìƒˆë¡œ ì •ì˜ë¥¼ í•´ë„ ì¢‹ê³ , ì´í›„ ì •ì˜í•  `UserManager` í´ëž˜ìŠ¤ì˜ `on_after_register` ë“±ì˜ ë©”ì†Œë“œì— ì œì•½ì‚¬í•­ì„ ì ìš©í•´ë„ ëœë‹¤.\n\nê·¸ë¦¬ê³  ì¶”ê°€ëœ ëª¨ë¸ì„ ë§ˆì´ê·¸ë ˆì´ì…˜ ì„¤ì •ì— ì¶”ê°€í•œë‹¤.\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n\"\"\"create account table\n\nRevision ID: f721febf752b\nRevises:\nCreate Date: 2022-04-27 17:21:25.945460\n\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nimport sqlalchemy as sa\nfrom alembic import op\n\nsys.path.append(Path(__file__).resolve().parents[4].as_posix())\nfrom app.models.cleaning import cleanings\nfrom app.models.core import datetime_model\nfrom app.models.user import user_model\n\n# revision identifiers, used by Alembic.\nrevision = \"f721febf752b\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ncleanings_table = cleanings.get_table()\nusers_table = user_model.get_table()\n\n\ndef create_cleanings_table() -> None:\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        cleanings_table.name,\n        *[col for col in cleanings_table.columns if col.name in col_names]\n    )\n\n\ndef create_user_table() -> None:\n    col_names = {\n        \"id\",\n        \"name\",\n        \"hashed_password\",\n        \"email\",\n        \"is_active\",\n        \"is_superuser\",\n        \"is_verified\",\n    }.union(datetime_model.attrs)\n\n    op.create_table(\n        users_table.name, *[col for col in users_table.columns if col.name in col_names]\n    )\n\n\ndef upgrade():\n    create_cleanings_table()\n    create_user_table()\n\n\ndef downgrade():\n    op.drop_table(cleanings_table.name)\n    op.drop_table(users_table.name)\n```\n\nì´ì œ ë“œë””ì–´ ë§ˆì´ê·¸ë ˆì´ì…˜ì„ í•  ì¤€ë¹„ê°€ ëë‚¬ë‹¤.\n\n```bash\nroot@77f86a971288:/backend# alembic upgrade head\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -> f721febf752b, create account table\n```\n\n## `FastAPI-Users`\n\nì› ì˜ˆì œì—ì„œëŠ” ì´ì œ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìž‘ì„±í•œë‹¤. í•˜ì§€ë§Œ `fastapi-users`ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ, ì‚¬ì „ ìž‘ì—…ì´ ëª‡ê°€ì§€ í•„ìš”í•œë°, ì§€ê¸ˆ ì§„í–‰í•˜ëŠ” ìž‘ì—…ì´ ë‹¤ìŒ ì±•í„°ë‚˜ ê·¸ ë‹¤ìŒ ì±•í„°ì— ë‚˜ì˜¤ëŠ” ë‚´ìš©ê³¼ ë¹„ìŠ·í•  ìˆ˜ ìžˆë‹¤..\n\n### ê°„ë‹¨í•œ ì„¤ëª…\n\n**`fastapi-users`** ì˜ ì„¤ëª…ì— ë”°ë¥´ë©´, **`fastapi-users`** ëŠ” `Transport`ì™€ `Strategy` ì´ ë‘ê°€ì§€ë¥¼ ì¡°í•©í•´ì„œ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì´ë‹¤. ì§€ê¸ˆ ì´ ì˜ˆì œëŠ” **`Bearer`** ì™€ **`JWT`** ë¥¼ ì¡°í•©í•´ì„œ ì“°ëŠ” ë°©ì‹ì´ë¼ê³  ìƒê°í•  ìˆ˜ ìžˆë‹¤.\n\n> - **`Bearer`** : `header`ì— í† í°ì„ ì €ìž¥\n> - **`JWT`** : `JSON`í˜•íƒœì˜ í† í°ì„ ì•”í˜¸í™” í•˜ì—¬ ì €ìž¥(í† í° ë°œí–‰ ì´í›„ ì„œë²„ì—ì„œ ë¬´íš¨í™” ë¶ˆê°€ëŠ¥). ìžì„¸í•œ ì„¤ëª…ì€ [ì—¬ê¸°](https://jwt.io/introduction)ì—ì„œ í™•ì¸í•  ìˆ˜ ìžˆë‹¤.\n\n### ì¸ì¦ ë°±ì—”ë“œ ì„¤ì •\n\nì¸ì¦ê³¼ ê´€ë ¨í•œ ëª¨ë“ˆì„ ì €ìž¥í•  ê²½ë¡œë¥¼ ìƒì„±í•˜ê³  ë°±ì—”ë“œë¶€í„° ì•žì—ì„œ ê°„ëžµí•˜ê²Œ ì„¤ëª…í•œ ì¸ì¦ ë°±ì—”ë“œë¶€í„° ìƒì„±í•œë‹¤.\n\n```bash\nâ¯ mkdir backend/app/services\nâ¯ touch backend/app/services/__init__.py backend/app/services/authentication.py\n```\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ..core.config import SECRET_KEY\nfrom ..db.session import get_session\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n\n\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user, session, user_model)  # type: ignore\n\n\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n\n\ndef create_strategy() -> Strategy:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n\n\ndef create_backend() -> list[AuthenticationBackend]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n\n\nclass UserManager(BaseUserManager[user_create, user]):\n    user_db_model = user\n    reset_password_token_secret = str(SECRET_KEY)\n    verification_token_secret = str(SECRET_KEY)\n\n    async def on_after_register(self, user: user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(user_db=Depends(get_user_db)):\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(*backends: AuthenticationBackend) -> FastAPIUsers:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user_base,\n        user_create_model=user_create,\n        user_update_model=user_update,\n        user_db_model=user,\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n\n    @classmethod\n    def init(cls) -> \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n\n```\n\në­”ê°€ ë§Žì´ ì ì—ˆì§€ë§Œ ì‹¤ì œë¡œ ì§ì ‘ ìž‘ì„±í–ˆë‹¤ê³  í• ë§Œí•œê±´ ë°ì´í„°í´ëž˜ìŠ¤ **`fastapi_user`** ì •ë„ ë°–ì— ì—†ë‹¤. ì „ë¶€ **`fastapi-users`** ë ˆí¼ëŸ°ìŠ¤ì— ìžˆëŠ” ë‚´ìš©ì´ë‹¤.\n\n`UserManager` ì™€ `AuthenticationBackend` ì¸ìŠ¤í„´ìŠ¤ëŠ” ì´í›„ ê³„ì •ê³¼ ê´€ë ¨ëœ ìž‘ì—…ì„ í• ë•Œ ìžì£¼ ì‚¬ìš©ëœë‹¤.\n\n### í† í° `api` ìƒì„±\n\nì´ì œ í† í°ì„ ìƒì„±í•˜ëŠ” apië¥¼ ìƒì„±í•œë‹¤. ì´ apiì˜ ì—”ë“œí¬ì¸íŠ¸ëŠ” `Transport`ë¥¼ ìƒì„±í•  ë•Œ ì‚¬ìš©í•œ `tokenUrl`ì˜ ê°’ê³¼ ì¼ì¹˜í•´ì•¼í•œë‹¤.\n\n```python\n# backend/app/api/routes/token.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi_users import models\nfrom fastapi_users.authentication import Strategy\nfrom fastapi_users.manager import BaseUserManager\nfrom fastapi_users.router import ErrorCode\nfrom starlette.status import HTTP_400_BAD_REQUEST\n\nfrom .authentication import fastapi_user as fastapi_user_class\nfrom .authentication import get_user_manager\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -> dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n### ì¸ì¦ ë°±ì—”ë“œ í™•ì¸ìš© ìž„ì‹œ `api` ìƒì„±\n\nì´ì–´ì„œ ì¸ì¦ ë°±ì—”ë“œ ì„¤ì •ì´ ìž˜ ëëŠ”ì§€ í™•ì¸í•´ë³¼ ìž„ì‹œ ë¼ìš°í„°ë¥¼ ìƒì„±í•œë‹¤. ì‹¤ì œë¡œ ì‚¬ìš©í•  ìƒê°ì€ ì•„ë‹ˆê³ , ë§ ê·¸ëŒ€ë¡œ ìž„ì‹œ í™•ì¸ìš©ì´ë‹¤.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter\n\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\nrouter.include_router(\n    fastapi_user.users.get_auth_router(fastapi_user.backends[0]), prefix=\"/auth\"\n)\nrouter.include_router(fastapi_user.users.get_register_router(), prefix=\"/auth\")\nrouter.include_router(fastapi_user.users.get_verify_router(), prefix=\"/auth\")\n```\n\n```python\n# backend/api/routes/__init__.py\nfrom fastapi import APIRouter\n\nfrom .cleanings import router as cleanings_router\nfrom .token import router as token_router\nfrom .users import router as users_router\n\nrouter = APIRouter()\n\nrouter.include_router(cleanings_router, prefix=\"/cleanings\", tags=[\"cleanings\"])\nrouter.include_router(users_router, prefix=\"/users\", tags=[\"users\"])\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\nì´ì œ [http://localhost:8000/docs](http://localhost:8000/docs)ì—ì„œ í™•ì¸í•´ë³´ë©´ **`fastapi-users`** ì—ì„œ ì„¤ì •í•œ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ìƒì„±í•´ë†“ì€ ìœ ì € ê´€ë ¨ apië¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆë‹¤. ë˜í•œ, ë¡œê·¸ì¸ì‹œ ìƒì„±ë˜ëŠ” í† í°ì„ í—¤ë”ì— ì¶”ê°€í•˜ë©´ **`swagger`** ì—ì„œ ë¡œê·¸ì¸ì„ ì‹œë„í•´ë³¼ ìˆ˜ ìžˆë‹¤.\n\në‹¤ìŒì€ ì´ë²ˆì— ìž‘ì„±í•œ ë‚´ìš©ì„ ì¢€ ë” ë‹¤ë“¬ê³ , ì´ì „ê¹Œì§€ í–ˆë˜ ë°©ì‹ìœ¼ë¡œ **TDD** ë°©ë²•ë¡ ì— ë”°ë¼ apië¥¼ ìƒì„±í•  ìƒê°ì´ë‹¤.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -6- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„±","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -6- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„±","date":"2022-05-03T01:35:06.494+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìžˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}}]},"__N_SSG":true}