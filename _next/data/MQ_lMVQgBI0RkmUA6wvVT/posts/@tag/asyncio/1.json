{"pageProps":{"tag":"asyncio","page":1,"max_page":1,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"파이썬으로 동시성 프로그래밍을 쉽게 하는법","content":"\n## 동시성 프로그래밍이란\n\n동시성 프로그래밍은, **한 사람이 두가지 이상의 일을 같이 작업하는 것**을 말합니다.\n\n예를 들자면, 한 사람이 세탁기를 돌리고, 세탁기가 돌아가던 중 설거지를 하고, 설거지를 하던 중 전화를 받고, 세탁기가 끝나서 빨래를 널고, 설거지를 마저 끝내는 것입니다.\n\n이것을 만약 순차적으로 한다면, 세탁기를 돌리고 끝날 때 까지 기다린 다음 빨래를 널고, 이후 설거지를 합니다. 설거지가 끝나지 않았으니 전화는 받을 수 없고, 설거지가 끝난 다음 전화를 받습니다.\n\n어떤 방식이 더 효율적인지는 따로 설명하지 않아도 알 수 있습니다.\n\n### `asyncio`, 동시성 프로그래밍의 아주 간단한 예\n\n```python\nimport asyncio\nfrom datetime import datetime\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await asyncio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    tasks = [just_sleep(num, 1) for num in range(5)]\n    await asyncio.gather(*tasks)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n`asyncio`는 파이썬의 동시성 프로그래밍을 위한 기본 라이브러리입니다. 동시성 프로그래밍을 위해서는 `async`와 `await` 키워드를 알아야 합니다.\n\n> `async`는 이 함수가 다른 작업을 위해 기다릴 수 있다는 것을 의미합니다.\n> `await`은 `async`로 정의된 함수가 기다리는 지점을 특정합니다.\n\n따라서 위 코드는 1초간 기다리는 5개의 작업을 실시하는 간단한 코드입니다.\n\n> 1초간 기다리 행위는, 데이터를 쓰거나 읽는 등의 작업이 걸리는 시간을 흉내내는 것입니다.\n\n실제로 실행해보면, 다음과 같은 출력을 얻습니다.\n\n```log\n2021-11-27 16:17:25.901585:: num=0, second=1 sleep start\n2021-11-27 16:17:25.901626:: num=1, second=1 sleep start\n2021-11-27 16:17:25.901642:: num=2, second=1 sleep start\n2021-11-27 16:17:25.901653:: num=3, second=1 sleep start\n2021-11-27 16:17:25.901662:: num=4, second=1 sleep start\n2021-11-27 16:17:26.902915:: num=0, second=1 sleep end\n2021-11-27 16:17:26.902996:: num=1, second=1 sleep end\n2021-11-27 16:17:26.903025:: num=2, second=1 sleep end\n2021-11-27 16:17:26.903053:: num=3, second=1 sleep end\n2021-11-27 16:17:26.903080:: num=4, second=1 sleep end\n```\n\n`num=0`인 작업이 `await asyncio.sleep(sencond=1)`에서 1초간 대기하기 때문에, 그동안 `num=1`작업을 실행할 수 있습니다.\n\n> #### 왜 `time.sleep`이 아닌 `asyncio.sleep`인가?\n>\n> `time.sleep`은 블로킹 함수입니다. 블로킹 함수는 `async`로 정의되지 않아 기다릴 수 없는 함수입니다. 만약 `asyncio.sleep`대신 `time.sleep`을 사용한다면, io작업을 흉내낸다기 보다, cpu작업을 흉내내게 됩니다.\n\n### 하지만 뭔가 어색하다\n\n구글에서 검색해서 얻을 수 있는 자료나, 시중에서 판매하는 책을 보면 `yield` 키워드를 쓴다던가, `ensure_future`를 쓴다던가, `get_running_loop`를 쓴다던가.. 최신의 `asyncio`의 사용법에 맞지 않은 방법을 소개하는 글이 많습니다.\n\n> 물론 `ensure_future`나 `get_running_loop`와 같은 함수를 쓸 수도 있습니다. 하지만 **저수준 api를 다뤄야 할 때 필요하지, 대부분의 경우 그렇지 않습니다.**\n\n아직 파이썬에서 동시성 프로그래밍을 제대로 지원한지 얼마 되지 않아, 버전이 올라갈수록 변경사항이 많아서 이런 일이 생긴겁니다.\n\n## `trio`, 조금 더 현대적인 방식으로\n\n그렇다면 차라리 더 최근에 만들어진 라이브러리를 사용하는게 어떨까요? 적어도 검색했을때 헷갈리는 일은 없을테니까요.\n\n기본 라이브러리인 `asyncio` 대신 `trio`라는 라이브러리가 있습니다. 개인적으로 좋아하는 `open_nursery`라는 함수가 있습니다. ~~끔찍한 gather는 이제 그만두고~~ 앞에서 `asyncio`로 작성한 코드를 `trio`로는 어떻게 작성할 수 있을까요.\n\n```python\nfrom datetime import datetime\n\nimport trio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await trio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with trio.open_nursery() as nursery:\n        for num in range(5):\n            nursery.start_soon(just_sleep, num, 1)\n\n\nif __name__ == \"__main__\":\n    trio.run(main)\n```\n\n사실 여기서 달라진건 많이 없습니다. 특징적인 부분은 `gather`로 작업을 모으는 대신, `nursery` 블록에서 `nursery.start_soon` 메소드로 `just_sleep` 작업 5개를 지시한 것입니다.\n\n출력 결과를 보면 이전과 대동소이합니다.\n\n```log\n2021-11-27 16:38:19.661314:: num=4, second=1 sleep start\n2021-11-27 16:38:19.661370:: num=3, second=1 sleep start\n2021-11-27 16:38:19.661393:: num=2, second=1 sleep start\n2021-11-27 16:38:19.661415:: num=1, second=1 sleep start\n2021-11-27 16:38:19.661434:: num=0, second=1 sleep start\n2021-11-27 16:38:20.662955:: num=4, second=1 sleep end\n2021-11-27 16:38:20.663113:: num=3, second=1 sleep end\n2021-11-27 16:38:20.663196:: num=2, second=1 sleep end\n2021-11-27 16:38:20.663272:: num=1, second=1 sleep end\n2021-11-27 16:38:20.663347:: num=0, second=1 sleep end\n```\n\n### 다른게 별로 없는데 왜 `trio`를 써야하지\n\n위 코드만 봤을때, `trio`를 써서 얻는 이득은 그다지 없어 보입니다. 하지만 그건 지금 코드가 아주 간단한 형태로 작성되어 있기 때문에 그렇습니다. 이후 사용하게 될 `channel` (`anyio`에서는 `stream`) 과 `CancelScope`, `Semaphore` 에서 그 이점이 드러나게 됩니다.\n\n### 잘 작성된 document\n\n`trio`의 [document](https://trio.readthedocs.io/en/stable/index.html)는 꽤 잘만들었다 생각합니다. 사용하다 막히는 부분이 있을때 따로 검색하기 보다는 공식 문서를 다시 한번 읽어보는게 도움이 되는 경우가 더 많았습니다.\n\n### 아쉽게도 기존 asyncio와 호환 안됨\n\n`trio`는 다 좋은데 기존 `asyncio`와 호환이 되지 않습니다. 즉, 이미 `asyncio`로 작성된 코드가 있다면 `trio`를 사용하기 위해서는 전부 수정을 해야합니다.\n\n무엇보다도 `uvloop`를 지원하지 않습니다. `uvloop`는 간단한 사용법으로 파이썬 동시성 프로그래밍의 성능을 끌어올릴 수 있는데, `trio`에서는 사용할 수가 없습니다.\n\n그렇다면 `trio`의 기능적 특징을 가지고, `asyncio`와 호환되고, `uvloop`도 지원하는 그런 라이브러리는 없을까요? **있습니다.** `anyio`라는 라이브러리를 사용하면 됩니다.\n\n## `anyio`, 현대적 방식과 호환성을 한번에\n\n`anyio`는 `asyncio`와 `trio`를 둘 다 사용할 수 있습니다. `asyncio`를 사용하고 싶다면 백엔드로 `asyncio`를 지정하고, `trio`를 사용하고 싶다면 `trio`를 지정하기만 하면 됩니다. `uvloop`를 사용하고 싶다면? `use_uvloop=True` 파라미터를 입력하기만 하면 됩니다.\n\n> 그렇다면 `trio`의 기능을 사용하기 위해 무조건 백엔드를 `trio`로 지정해야 할까요? **아닙니다.** `anyio`는 `trio`의 기능을 `asyncio`로 구현한 라이브러리이기 때문에, `asyncio`를 백엔드로 사용해도 아무 문제가 없습니다.\n\n앞에서 `asyncio`와 `trio`로 작성했던 코드를 `anyio`로 다시 작성하겠습니다.\n\n```python\nfrom datetime import datetime\n\nimport anyio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await anyio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with anyio.create_task_group() as task_group:\n        for num in range(5):\n            task_group.start_soon(just_sleep, num, 1)\n\n\nif __name__ == \"__main__\":\n    anyio.run(main, backend_options=dict(use_uvloop=True))\n```\n\n> `uvloop` 사용이 가능하다는 것을 보이기 위해 `backend_options=dict(use_uvloop=True)` 파라미터를 추가했습니다. 추가하지 않아도 문제 없습니다.\n\n`trio`로 작성된 코드와 차이점이 있다면 `trio.open_nursery`가 `anyio.create_task_group`로 바뀐 것 정도입니다. 실제로 대부분 용어의 문제지, `trio`에서 작성된 [document](https://trio.readthedocs.io/en/stable/index.html)는 `anyio`에 대부분 적용이 가능합니다.\n\n### 상대적으로 빈약한 document\n\n`anyio`의 [document](https://anyio.readthedocs.io/en/stable/index.html)는 상대적으로 좀 부족하다는 느낌을 받았습니다. 그래서 쓰다가 부족한 부분이 있으면 `trio`의 [document](https://trio.readthedocs.io/en/stable/index.html)를 읽어보고, `trio`와 대응하는 `anyio`의 모듈을 찾아서 해결하곤 했습니다.\n\n## 내 선택은 `anyio`\n\n저는 동시성 프로그래밍을 해야 할 일이 있으면 우선 `anyio`를 사용하는 편입니다. 특히 제가 좋아하는 프레임워크인 `fastapi`에서 `anyio`를 사용하기 때문에 거리낌 없이 사용할 수 있습니다. (`fastapi`에서 사용하는 `starlette`의 특정 버전부터 `anyio`를 지원하기 때문에 가능한 것으로, `anyio`를 사용하려면 버전 확인이 필요합니다.)\n\n이후 글에서는 `anyio`의 메소드와 클래스를 활용하는 것에 대해 작성할 예정입니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/파이썬으로 동시성 프로그래밍을 쉽게 하는법","data":{"title":"파이썬으로 동시성 프로그래밍을 쉽게 하는법","date":"2021-11-27T17:20:16.241+09:00","tags":["anyio","async","asyncio","python","trio","@all"],"page":"파이썬 동시성 프로그래밍","summary":"asyncio? trio? anyio!"}}]},"__N_SSG":true}