{"pageProps":{"tag":"@all","page":2,"max_page":6,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"vim ì˜ë¬¸ í‚¤ë³´ë“œ ìë™ ì „í™˜","content":"\n# ì•„ë˜ ê¸€ì€ í¼ì˜¨ ê¸€ì…ë‹ˆë‹¤.\nì¶œì²˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.\n\n[[Vim] Normalëª¨ë“œì—ì„œ ì˜ë¬¸ í‚¤ë³´ë“œë¡œ ìë™ ì „í™˜í•˜ê¸° (Windows)](https://rottk.tistory.com/entry/Vim-Normal%EB%AA%A8%EB%93%9C%EC%97%90%EC%84%9C-%EC%98%81%EB%AC%B8-%ED%82%A4%EB%B3%B4%EB%93%9C%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-Windows)\n\n---\n\n# Windowsì—ì„œ `Vim`ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° (`VSCode`ì˜ `Vim Extension`, `WSL`ì—ì„œì˜ `Vim`)\n`Vim` ì‚¬ìš© ì‹œ í”íˆ ê²ªëŠ” ë¬¸ì œê°€ í•œê¸€ë¡œ ì£¼ì„ ì‘ì„± í›„, Normal ëª¨ë“œë¡œ ì „í™˜í•˜ì—¬ ëª…ë ¹ì–´ë¥¼ ì…ë ¥í•˜ë©´ ëª…ë ¹ì–´ê°€ ì ìš©ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.\n\nì˜ˆë¥¼ ë“¤ì–´, íŒŒì¼ ì €ì¥ì„ ìœ„í•´ `ESC` + `:w` ë¥¼ ì…ë ¥í•˜ì˜€ìœ¼ë‚˜, ì‹¤ì œë¡œëŠ” `ESC`, `:ã…ˆ`ê°€ ì…ë ¥ë˜ì–´ ì €ì¥ì´ ë˜ì§€ ì•ŠëŠ” ê²½ìš°ì…ë‹ˆë‹¤.\n\n`Vim`ì—ì„œ í•œê¸€ì„ ì…ë ¥í•˜ëŠ” ê²½ìš°ëŠ” ì½”ë“œì— ì£¼ì„ì„ ë„£ëŠ” ê²½ìš° ì´ì™¸ì—ëŠ” ì—†ìœ¼ë¯€ë¡œ, Normal ëª¨ë“œë¡œ ì „í™˜ ì‹œ(ì¦‰, `ESC`ë¥¼ ëˆ„ë¥´ë©´) ì˜ë¬¸ìœ¼ë¡œ ìë™ì „í™˜ì´ ë˜ë„ë¡ ì„¤ì •í•˜ë©´ ì´ëŸ¬í•œ ë¬¸ì œê°€ í•´ê²°ë  ê²ƒì…ë‹ˆë‹¤.\n\nâ€» ê°„ë‹¨íˆ IMEì—ì„œ í•´ë‹¹ ê¸°ëŠ¥ì„ ì œê³µí•´ì¤€ë‹¤ë©´ ë³„ë„ì˜ í”„ë¡œê·¸ë¨ì„ ì„¤ì¹˜í•˜ì§€ ì•Šì•„ë„ ë˜ê² ì§€ë§Œ ì•„ì‰½ê²Œë„ `Microsoft IME`ëŠ” ì„¤ì • ê¸°ëŠ¥ì´ ì¡´ì¬í•˜ì§€ ì•Šì•„ ì™¸ë¶€ í”„ë¡œê·¸ë¨(í‚¤ ë§¤í¬ë¡œ)ì„ ì„¤ì¹˜í•˜ì—¬ ë„ì›€ì„ ë°›ì•„ì•¼ í•©ë‹ˆë‹¤.\n* ìœˆë„ì— [Auto HotKey](https://www.autohotkey.com/)ë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤.\n* ë©”ëª¨ì¥ì— `Script.ahk`ë¥¼ ë§Œë“¤ì–´ ì•„ë˜ì˜ Scriptë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.\n* ì‘ì„±í•œ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë”ë¸” í´ë¦­í•˜ì—¬ ì‹¤í–‰í•©ë‹ˆë‹¤. ì´í›„, `ESC`ë¥¼ ëˆ„ë¥´ë©´ ìë™ìœ¼ë¡œ ì˜ë¬¸ í‚¤ë³´ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤.\n\n```auto hotkey\n$Esc::\n    if(IME_CHECK(\"A\"))\n        Send, {VK15}    ;ì˜ë¬¸ì´ë¼ë©´ í•œì˜ì „í™˜ í‚¤ë¥¼ ì…ë ¥í•´ì¤€ë‹¤.\n    Send, {Escape}\n    return\n\n/*\n  IME check \n*/\nIME_CHECK(WinTitle) {\n  WinGet,hWnd,ID,%WinTitle%\n  Return Send_ImeControl(ImmGetDefaultIMEWnd(hWnd),0x005,\"\")\n}\nSend_ImeControl(DefaultIMEWnd, wParam, lParam) {\n  DetectSave := A_DetectHiddenWindows\n  DetectHiddenWindows,ON\n   SendMessage 0x283, wParam,lParam,,ahk_id %DefaultIMEWnd%\n  if (DetectSave <> A_DetectHiddenWindows)\n      DetectHiddenWindows,%DetectSave%\n  return ErrorLevel\n}\nImmGetDefaultIMEWnd(hWnd) {\n  return DllCall(\"imm32\\ImmGetDefaultIMEWnd\", Uint,hWnd, Uint)\n}\n```\n\n## Windows ì‹¤í–‰ì‹œ ìë™ìœ¼ë¡œ Script ì‹œì‘í•˜ê¸°\nScriptë¥¼ ì‹¤í–‰íŒŒì¼(.exe)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.\n\n1. `C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\AutoHotkey` í´ë”ë¡œ ì´ë™í•©ë‹ˆë‹¤.\n2. `Convert .ahk to .exe`ë¥¼ ë”ë¸”í´ë¦­í•˜ì—¬ ì‹¤í–‰í•©ë‹ˆë‹¤.\n3. `Source`í•­ëª©ì—ì„œ ì•ì„œ ì‘ì„±í•œ `script.ahk`ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.\n4. `Convert` ë¥¼ í´ë¦­í•©ë‹ˆë‹¤.\n5. 'Conversion complete' íŒì—…ì´ í‘œì‹œë˜ë©´, .exe íŒŒì¼ì´ ìŠ¤í¬ë¦½íŠ¸ì™€ ê°™ì€ í´ë”ì— ìƒì„±ë©ë‹ˆë‹¤.\n\nì‹¤í–‰íŒŒì¼ì„ ìœˆë„ìš°ì¦ˆ ì‹œì‘í”„ë¡œê·¸ë¨ìœ¼ë¡œ ì¶”ê°€í•©ë‹ˆë‹¤.\n\n1. Windows ë¡œê³  í‚¤ + Rì„ ëˆ„ë¥´ê³  `shell:startup`ì„ ì…ë ¥í•œ ë‹¤ìŒ í™•ì¸ì„ ì„ íƒí•©ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ì‹œì‘ í´ë”ê°€ ì—´ë¦½ë‹ˆë‹¤.\n2. ì•ì„œ ë³€í™˜í•œ ì‹¤í–‰íŒŒì¼(.exe)ì„ ë³µì‚¬í•˜ì—¬ ì‹œì‘ í´ë”ì— ë¶™ì—¬ë„£ìŠµë‹ˆë‹¤.\n\n# ì¶œì²˜\n* [https://github.com/johngrib/simple_vim_guide/blob/master/md/with_korean.md](https://github.com/johngrib/simple_vim_guide/blob/master/md/with_korean.md)\n* [https://www.autohotkey.com/](https://www.autohotkey.com/)\n* [Windows 10ì—ì„œ ì‹œì‘í•  ë•Œ ìë™ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ì•± ì¶”ê°€](https://support.microsoft.com/ko-kr/windows/windows-10%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%ED%95%A0-%EB%95%8C-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94-%EC%95%B1-%EC%B6%94%EA%B0%80-150da165-dcd9-7230-517b-cf3c295d89dd)\n* [AHK Startup Under Windows 10](https://www.autohotkey.com/boards/viewtopic.php?t=15820)\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"other/vim ì˜ë¬¸ í‚¤ë³´ë“œ ìë™ ì „í™˜","data":{"title":"[Vim] Normalëª¨ë“œì—ì„œ ì˜ë¬¸ í‚¤ë³´ë“œë¡œ ìë™ ì „í™˜í•˜ê¸° (Windows)","tags":["windows","wsl","vim","@all"],"page":null,"summary":"escë¥¼ ëˆ„ë¥´ë©´ ìë™ìœ¼ë¡œ ì˜ë¬¸ í‚¤ë³´ë“œê°€ ëœë‹¤.","date":"2022-08-06T20:00:32.948+09:00"}},{"name":"velogì—ì„œ git pageë¡œ ë¸”ë¡œê·¸ ì´ì „","content":"\n# ì™œ ì˜®ê²¼ë‚˜?\n\nì§€ë‚œ ëª‡ë‹¬ê°„ `velog`ì—ì„œ ëª‡ëª‡ í¬ìŠ¤íŠ¸ë¥¼ ì‘ì„±í–ˆë‹¤.\nì˜ ë§Œë“¤ì–´ì§„ êµ¬ì„±ì´ë‹¤ ë³´ë‹ˆ ë³„ë‹¤ë¥¸ ë¶ˆë§Œ ì—†ì´ ì˜ ì‚¬ìš©í–ˆë‹¤.\ní•˜ì§€ë§Œ ì§€ë‚œ ë©°ì¹ ê°„ì˜ ì—°ìŠµ ëì— `git page`ë¡œ ë¸”ë¡œê·¸ë¥¼ ì´ì „í–ˆë‹¤.\n\n## ì²˜ìŒë¶€í„° `git page`ë¥¼ ì“°ê³  ì‹¶ì—ˆë‹¤.\n\nì‚¬ì‹¤ ì´ì „ë¶€í„° `git page`ë¡œ ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ê³  ì‹¶ì—ˆë‹¤.\nê°€ì¥ ë§ì´ ì•Œë ¤ì§„ ê°„ë‹¨í•œ ë°©ë²•ì€ `jekyll`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.\ní•˜ì§€ë§Œ `ruby`ë¡œ ì‘ì„±ëœ ì—”ì§„ì´ë‹¤ ë³´ë‹ˆ ì œëŒ€ë¡œ ì•Œì•„ë³´ëŠ”ë° í˜ì´ ë“¤ì—ˆë‹¤.\nê·¸ë ‡ë‹¤ê³  `ruby`ë¥¼ ë”°ë¡œ ë°°ì›Œë³´ìë‹ˆ, ì‚´ë©´ì„œ `ruby`ë¥¼ ì‚¬ìš©í•  ì¼ì´ ì–¼ë§ˆë‚˜ ìˆì„ê¹Œ í•˜ëŠ” ìƒê°ì´ ë¬¸ë“ ë“¤ì—ˆë‹¤.\nì°¨ë¼ë¦¬ `go`ë‚˜ `rust`ë¼ë©´ ë…¸ë ¥í•´ë³´ê² ì§€ë§Œ, `ruby`ë¼ë‹ˆ..\n\nê·¸ë ‡ê²Œ ê·¸ëƒ¥ í•˜ì§€ ë§ê¹Œ? í•˜ë‹¤ê°€ ì•Œê²Œëœê²Œ `velog`ì˜€ë‹¤.\n`velog`ëŠ” ë‚´ê°€ ì²˜ìŒì— ê¸°ëŒ€í•œ ê±°ì˜ ëª¨ë“  ê²ƒì„ ë§Œì¡±í–ˆë‹¤.\n\n- ë§ˆí¬ë‹¤ìš´ì„ ì´ìš©í•œ í¬ìŠ¤íŒ…\n- ì½”ë“œ ë¸”ë¡ í•˜ì´ë¼ì´íŒ…\n- ì‹¤ì‹œê°„ í¬ìŠ¤íŒ… í”„ë¦¬ë·°\n\nê²¨ìš° ì„¸ê°€ì§€ì§€ë§Œ ì´ ì„¸ê°€ì§€ë¥¼ ë§Œì¡±í•˜ëŠ” ê³³ì´ ì‚¬ì‹¤ìƒ ì—†ë‹¤.\nê·¸ë¦¬ê³  ë”°ë¡œ ë‚´ê°€ ë ˆì´ì•„ì›ƒì„ ìˆ˜ì •í•  í•„ìš”ê°€ ì—†ë‹¤ë³´ë‹ˆ(ì‚¬ì‹¤ ë°©ë²•ë„ ì—†ë‹¤), ê·¸ëƒ¥ ì˜ ë§Œë“¤ì–´ì§„ í”Œë«í¼ì— ê¸€ë§Œ ì“°ë©´ ë‚´ê°€ ì›í•˜ëŠ”ê²Œ ë‹¤ ëë‹¤.\n\n## `velog`ëŠ” ë‹¤ ì¢‹ì€ë° ì´ê²Œ ì—†ë‹¤.\n\ní•˜ì§€ë§Œ ì“°ë‹¤ë³´ë‹ˆ ì—­ì‹œ ì•„ì‰¬ìš´ê²Œ ë³´ì¸ë‹¤.\n\n- ëª…í™•í•œ ê¸°ì¤€ì€ ëª¨ë¥´ê² ì§€ë§Œ, ëª‡ëª‡ ì–‘ì‹ì— ëŒ€í•œ í•˜ì´ë¼ì´íŒ… ë¯¸ì§€ì›(log ë“±)\n- ì‘ì„±ê¸€ ìˆ¨ê¸°ê¸°\n\nê·¸ë¦¬ê³  ë¬´ì—‡ë³´ë‹¤ë„.. ë‚´ê°€ ì§ì ‘ ë§Œë“ ë‹¤ëŠ” ì„±ì·¨ê°ì´ ì—†ì—ˆë‹¤.\nê·¸ë˜ì„œ ê²°êµ­ ì§ì ‘ ë§Œë“¤ê¸°ë¡œ í–ˆë‹¤.\n\në‹¤ë§Œ `velog`ë•ë¶„ì— ì¹´í…Œê³ ë¦¬ê°€ ë¬´ì¡°ê±´ ìˆì–´ì•¼ í•œë‹¤ëŠ” ê³ ì •ê´€ë…ì—ì„œ ë²—ì–´ë‚  ìˆ˜ ìˆì—ˆë‹¤.\níƒœê·¸ë¥¼ ì¶”ê°€í•˜ë©´, íƒœê·¸ê°€ ê¸°ì¡´ì˜ ì¹´í…Œê³ ë¦¬ì²˜ëŸ¼ ì‚¬ìš©ë  ìˆ˜ ìˆê²Œ í•˜ë©´ ëœë‹¤.\në˜í•œ íŠ¹ì • í¬ìŠ¤íŠ¸ê°„ì˜ ì—°ê²°ì´ í•„ìš”í•˜ë‹¤ë©´, ë”°ë¡œ ì§€ì •í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ìˆìœ¼ë©´ ëœë‹¤.\n\n`velog`ì—ì„œ ì–»ì€ ì†Œì¤‘í•œ ê²½í—˜ì„ í† ëŒ€ë¡œ, `git page`ì— ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ì¤€ë¹„ë¥¼ í–ˆë‹¤.\n\n# ì–´ë–»ê²Œ ì˜®ê²¼ë‚˜?\n\nì²˜ìŒì—ëŠ” ê·¸ëƒ¥ ìµìˆ™í•œ `python`ìœ¼ë¡œ ì‘ì„±í•˜ë ¤ í–ˆë‹¤.\n`pelican`ì´ë¼ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ìˆì–´ì„œ, `jekyll`ì²˜ëŸ¼ ê°„ë‹¨í•˜ê²Œ ì •ì  ì‚¬ì´íŠ¸ë¥¼ ë°°í¬í•  ìˆ˜ ìˆê²Œ í•œë‹¤. ì‚¬ìš© ì–¸ì–´ê°€ `python`ì´ë‹¤ ë³´ë‹ˆ ê´€ë ¨ ìŠ¤í¬ë¦½íŠ¸ë¥¼ í™•ì¸í•˜ë©°, ì‘ë™ ë°©ì‹ì„ íŒŒì•…í•˜ëŠ” ê²ƒë„ í• ë§Œí–ˆë‹¤.\n\ní•˜ì§€ë§Œ ë°˜ì‘í˜•ìœ¼ë¡œ ì‘ì„±í•´ë³´ë ¤ í•˜ë‹ˆ, ê²°êµ­ `javascript`ë¥¼ ì“¸ ìˆ˜ ë°–ì— ì—†ì—ˆë‹¤.\nê·¸ë¦¬ê³  ì–´ì°¨í”¼ `javascript`ë¥¼ ì¨ì•¼í•œë‹¤ë©´.. ì´ë²ˆê¸°íšŒì— ê³µë¶€ë„ í•  ê²¸ ì™„ì „íˆ `javascript`ë¡œ ì‘ì„±í•´ë³´ìëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤.\n\nì—¬ê¸°ì„œ `vue`ëƒ, `react`ëƒ ë§ì€ ê³ ë¯¼ì´ ìˆì—ˆê³ , ì—¬ëŸ¬ ì‹œë„ê°€ ìˆì—ˆëŠ”ë°, ê²°êµ­ ì„ íƒí•œê±´ `react`ë‹¤.\nê·¸ë¦¬ê³  `react` ì•±ì„ ê°„ë‹¨í•˜ê²Œ ì‘ì„±í•˜ê³  ë°°í¬í•  ìˆ˜ ìˆëŠ” í”„ë ˆì„ì›Œí¬ë¡œ `nextjs`ë¥¼ ì‚¬ìš©í–ˆë‹¤.\n\nì²˜ìŒ ìƒê°ì€ `javascript`ì˜€ëŠ”ë°, `python`ì˜ íƒ€ì… íŒíŠ¸ë¥¼ ì´ìš©í•œ `vscode`ì˜ ìë™ì™„ì„± ê¸°ëŠ¥ì— ë„ˆë¬´ ìµìˆ™í•´ì ¸ì„œ ê·¸ëŸ°ê°€, ì½”ë“œ ì‘ì„±ì´ ë„ˆë¬´ ë¶ˆí¸í–ˆë‹¤.\në§ˆì¹¨ `nextjs`ê°€ `typescript`ë¥¼ ì§€ì›í•˜ê¸°ë„ í•´ì„œ, ì•½ê°„ì˜ ìˆ˜ê³ ê°€ ìˆì—ˆì§€ë§Œ `typescript`ë¡œ ì•±ì„ ì‘ì„±í–ˆë‹¤.\n\në§ì€ ì‚½ì§ˆëì— ê·¸ë˜ë„ `git page`ì— ë°°í¬í•  ìˆ˜ ìˆëŠ” í˜•íƒœë¡œ ë§Œë“œëŠ”ë° ì„±ê³µí–ˆë‹¤.\nì´ì œ ë¶€ì¡±í•œ ëª‡ëª‡ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê³ , ë””ìì¸ì„ ì†ë³´ê¸°ë§Œ í•˜ë©´ ëœë‹¤.\nê·¸ëŸ¬ê³ ë³´ë‹ˆ... `typescript`ë³´ë‹¤ `css`ê°€ ë” ì–´ë ¤ìš´ ê²ƒ ê°™ë‹¤..\nì•„ë¬´ë¦¬ í•´ë„ ì˜ˆì˜ê²Œ ë³´ì´ì§€ë¥¼ ì•ŠëŠ”ë‹¤..\n\n# ì•ìœ¼ë¡œ ì¶”ê°€í•  ê¸°ëŠ¥\n\n- [ ] ë‹¤í¬ëª¨ë“œ í† ê¸€\n  > ì‚¬ì‹¤ ì´ë¯¸ ê¸°ëŠ¥ ì¶”ê°€ëŠ” í–ˆì§€ë§Œ, css ì‘ì„±í•˜ê¸°ê°€ í˜ë“¤ì–´ì„œ ì£¼ì„ìœ¼ë¡œ ë†”ë‘” ìƒíƒœ\n- [ ] ë¬¸ë‹¨ ì œëª© ì—­ë§í¬\n- [ ] ì½”ë“œ ë¸”ëŸ­ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"js/velogì—ì„œ git pageë¡œ ë¸”ë¡œê·¸ ì´ì „","data":{"title":"velogì—ì„œ git pageë¡œ ë¸”ë¡œê·¸ ì´ì „","tags":["js","ts","nextjs","velog","github","@all"],"page":null,"date":"2022-06-12T04:27:48.097+09:00","summary":"there is no summary"}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `Breaking` `changes`\n\nì´í‹€ì „ **`fastapi-users`** ì— í° ë³€í™”ê°€ ìƒê²¼ë‹¤. `v10` ë¦´ë¦¬ì¦ˆê°€ ê³µê°œëëŠ”ë°, `db` ëª¨ë¸ê³¼ ì—¬ëŸ¬ ì œë„¤ë¦­ íƒ€ì…ì— ëŒ€í•œ ë³€í™”ê°€ ìƒê²¨ì„œ, `v10`ì„ ì´ìš©í•˜ë ¤ë©´ ëŒ€ì‘ íŒ¨ì¹˜ê°€ í•„ìˆ˜ì ì¸ ìƒí™©..\n\nì•„ë˜ëŠ” í•´ë‹¹ ë¦´ë¦¬ì¦ˆì— ëŒ€í•œ ì „ë¬¸ì´ë‹¤.\n\n> ### [Breaking changes](https://github.com/fastapi-users/fastapi-users/releases/tag/v10.0.0)\n>\n> Version 10 marks important changes in how we manage User models and their ID.\n>\n> Before, we were relying only on Pydantic models to work with users. In particular the current_user dependency would return you an instance of UserDB, a Pydantic model. This proved to be quite problematic with some ORM if you ever needed to retrieve relationship data or make specific requests.\n>\n> Now, FastAPI Users is designed to always return you a native object for your ORM model, whether it's an SQLAlchemy model or a Beanie document. Pydantic models are now only used for validation and serialization inside the API.\n>\n> Before, we were forcing the use of UUID as primary key ID; a consequence of the design above. This proved to be quite problematic on some databases, like MongoDB which uses a special ObjectID format by default. Some SQL folks also prefer to use traditional auto-increment integers.\n>\n> Now, FastAPI Users is designed to use generic ID type. It means that you can use any type you want for your user's ID. By default, SQLAlchemy adapter still use UUID; but you can quite easily switch to another thing, like an integer. Beanie adapter for MongoDB will use native ObjectID by default, but it also can be overriden.\n\n### ìœ ì € ëª¨ë¸ ìƒì„± ë° ìˆ˜ì •\n\nê¸°ì¡´ `fastapi_users.models` ì—ì„œ `fastapi_users.schemas`ë¡œ ë°”ë€ ê²ƒ ì™¸ì— í¬ê²Œ ë‹¬ë¼ì§„ ê²ƒì€ ì—†ë‹¤. ì‚¬ì‹¤ ì´ì „ì— ì–˜ê¸°í–ˆë˜ `user` ì™€ `user_model`ì„ í†µí•©í•˜ëŠ” ì‘ì—…ì„ ì´ë¯¸ í•œ ë‹¤ìŒ `v10` ë¦´ë¦¬ì¦ˆë¥¼ í™•ì¸í–ˆê¸°ì— ë”ìš± ê·¸ë ‡ê²Œ ëŠê»´ì¡Œë‹¤...\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar\n\nfrom fastapi_users import schemas\nfrom pydantic import EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field, select\n\nfrom ..db.session import async_session\nfrom .core import base_model, datetime_model, uuid_id_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\n_T = TypeVar(\"_T\", bound=\"user\")\nid_model = uuid_id_model\nuser_id_type = id_model.id_type\n\n\nclass user(id_model, datetime_model, base_model, table=True):\n    __tablename__: str = \"users\"\n\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: async_session, email: str\n    ) -> _T | None:\n        is_user_cur = await session.exec(select(cls).where(cls.email == email))\n        return is_user_cur.first()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.validate(self)\n\n\nclass user_read(schemas.BaseUser[user_id_type], datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(schemas.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(schemas.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n```\n\n### ì¸ì¦ ëª¨ë“ˆ ì œë„¤ë¦­ íƒ€ì… ë®ì–´ì”Œìš°ê¸°\n\n**`fastapi-users`** ì—ì„œ ì›í•˜ëŠ” í˜•íƒœëŠ” `SQLAlchemyBaseUserTable`ë¥¼ ìƒì†í•œ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ì§€ë§Œ, **`sqlmodel`** ë„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³  **`fastapi-users`** ì˜ íƒ€ì… íŒíŠ¸ë„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³  ì‹¶ê¸°ì—, ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì—®ì–´ì¤„ ìƒˆë¡œìš´ ì œë„¤ë¦­ í´ë˜ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.\n`# type: ignore`ë¥¼ ë‚¨ë°œí•˜ê¸°ì— ê·¸ë‹¤ì§€ ì¢‹ì€ ëª¨ìŠµì´ë¼ê³  ìƒê°ë˜ì§€ ì•Šì§€ë§Œ, ì´ê±° ì™¸ì— ë‹¹ì¥ ìƒê°ë‚˜ëŠ” ë°©ë²•ì´ ì—†ê¸°ì— ì¼ë‹¨ ë„˜ì–´ê°€ì.\n\n```bash\nâ¯ mkdir backend/app/services/authentication\nâ¯ mv backend/app/services/authentication.py backend/app/services/authentication/authentication.py\nâ¯ touch backend/app/services/authentication/__init__.py backend/app/services/authentication/convert.py\n```\n\n```python\n# backend/app/services/authentication/__init__.py\nfrom .authentication import *\n```\n\n```python\n# backend/app/services/authentication/convert.py\nfrom typing import Generic, TypeVar\n\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import AuthenticationBackend, JWTStrategy, Strategy\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n\nfrom ...models.core import base_model\nfrom ...models.user import user\n\nuser_id_type = user.id_type\n_T = TypeVar(\"_T\", bound=base_model)\n_D = TypeVar(\"_D\")\n\n# fmt: off\nclass user_db_class(SQLAlchemyUserDatabase[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass strategy_class(Strategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass jwt_strategy_class(JWTStrategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass auth_backend_class(AuthenticationBackend[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass user_manager_class(BaseUserManager[_T, _D], Generic[_T, _D]): ...  # type: ignore\nclass fastapi_users_class(FastAPIUsers[_T, _D], Generic[_T, _D]): ...  # type: ignore\n# fmt: on\n\n\nuser_manager_type = user_manager_class[user, user_id_type]\nstrategy_type = strategy_class[user, user_id_type]\n```\n\n### ë³€ê²½ì  ì¸ì¦ ëª¨ë“ˆì— ì ìš©\n\n```python\n# backend/app/services/authentication/authentication.py\nimport re\nfrom dataclasses import dataclass\nfrom re import Pattern\nfrom typing import AsyncGenerator, Sequence\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import IntegerIDMixin, InvalidPasswordException\nfrom fastapi_users.authentication import BearerTransport, Transport\n\nfrom ...core import config\nfrom ...db.session import async_session, get_session\nfrom ...models import user\nfrom .convert import (\n    auth_backend_class,\n    fastapi_users_class,\n    jwt_strategy_class,\n    strategy_class,\n    strategy_type,\n    user_db_class,\n    user_id_type,\n    user_manager_class,\n    user_manager_type,\n)\n\n\nasync def get_user_db(\n    session: async_session = Depends(get_session),\n) -> AsyncGenerator[user_db_class[user.user, user_id_type], None]:\n    yield user_db_class(session, user.user)\n\n\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\n\ndef create_strategy() -> strategy_class[user.user, user_id_type]:\n    return jwt_strategy_class(  # type: ignore\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n\ndef create_backend() -> list[auth_backend_class[user.user, user_id_type]]:\n    transport = create_transport()\n    return [\n        auth_backend_class(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n\n\nclass UserManager(IntegerIDMixin, user_manager_class[user.user, user_id_type]):\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+<>@\\#$%&\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -> None:\n        if len(password) < self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) > self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\n        for pattern in self.re_password_deny_list:\n            if pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\n        for pattern in self.re_password_need_list:\n            if not pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -> AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(\n    *backends: auth_backend_class[user.user, user_id_type],\n) -> fastapi_users_class[user.user, user_id_type]:\n    return fastapi_users_class(\n        get_user_manager=get_user_manager, auth_backends=backends\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -> Sequence[auth_backend_class[user.user, user_id_type]]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\nê½¤ ë§ì´ ë°”ë€Œê¸´ í–ˆì§€ë§Œ, ì‹¤ì œë¡œ ì‚¬ìš©í• ë•ŒëŠ” ì´ë¦„ì •ë„ë§Œ ë°”ë€Œì§€ ì‚¬ìš©ë²• ìì²´ëŠ” ë³€í•œê²Œ ì—†ë‹¤. ë°”ë€ ì´ë¦„ì— ë§ì¶°ì„œ ë¼ìš°í„°ì™€ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìˆ˜ì •í•´ì£¼ë©´, ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\nì´ë²ˆ ê¸°íšŒì— í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì–¼ë§ˆë‚˜ ì¢‹ì€ê±´ì§€ ì•Œê²Œëë‹¤.. ê¸´ê°€ë¯¼ê°€í• ë•Œ `pytest --tb=short` í•œë°©ì´ë©´ ì˜ë¬¸ì´ í•´ê²°ëœë‹¤.\n\nì‚¬ì‹¤ ë³€ê²½í• ê²Œ í•˜ë‚˜ ë” ë‚¨ê¸´ í–ˆì§€ë§Œ, ì´ê±° ì•„ì§ ì‹œë„í•´ë³´ì§€ ì•Šì•˜ë‹¤.\ní˜„ì¬ í—¤ë”ë¥¼ ì‚¬ìš©í•œ ì¸ì¦ ë°©ì‹ì¸ë°, ì¿ í‚¤ë¥¼ ì‚¬ìš©í•˜ê³ , `access-token`ê³¼ `refresh-token`ì„ ì‚¬ìš©í•œ ë°©ì‹ìœ¼ë¡œ ë³€ê²½í•´ë³´ë ¤ í•œë‹¤. ë‹¤ë§Œ **`fastapi-users`** ìì²´ì ìœ¼ë¡œëŠ” ì§€ì›í•˜ì§€ ì•Šê¸°ì—, ì§ì ‘ ì‘ì„±í•  í•„ìš”ê°€ ìˆì–´ì„œ ì•½ê°„ ê³ ë¯¼ì´ í•„ìš”í• ë“¯.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","date":"2022-05-07T23:00:58.369+09:00","tags":["fastapi","fastapi-users","python","sqlmodel","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ì… ë¬¸ì œ ì„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `Session`ì˜ ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ë³µë¶™\n\nì´ì „ê¹Œì§€ ê¸€ì—ì„œ ê³„ì†í•´ì„œ `AsyncSession`ì˜ íƒ€ì… ê´€ë ¨ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ”ê²Œ ë„ˆë¬´ ì§œì¦ë‚˜ì„œ, ì„ì‹œë¡œ ë•œë¹µìš© í´ë˜ìŠ¤ë¥¼ ìƒì„±í•´ì„œ ì‚¬ìš©í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n````python\n# backend/app/db/session.py\n(...)\n\n_TSelectParam = TypeVar(\"_TSelectParam\")\n\nclass async_session(AsyncSession):\n    # sqlmodel.orm.session.Session\n    @overload\n    async def exec(\n        self,\n        statement: Select[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Result[_TSelectParam]:\n        ...\n\n    @overload\n    async def exec(\n        self,\n        statement: SelectOfScalar[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> ScalarResult[_TSelectParam]:\n        ...\n\n    async def exec(\n        self,\n        statement: Union[\n            Select[_TSelectParam],\n            SelectOfScalar[_TSelectParam],\n            Executable[_TSelectParam],\n        ],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Union[Result[_TSelectParam], ScalarResult[_TSelectParam]]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().exec(\n            statement,  # type: ignore\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def execute(\n        self,\n        statement: _Executable,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Optional[Mapping[str, Any]] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Result[Any]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        ***\n\n        ğŸš¨ You probably want to use `session.exec()` instead of `session.execute()`.\n\n        This is the original SQLAlchemy `session.execute()` method that returns objects\n        of type `Row`, and that you have to call `scalars()` to get the model objects.\n\n        For example:\n\n        ```Python\n        heroes = session.execute(select(Hero)).scalars().all()\n        ```\n\n        instead you could use `exec()`:\n\n        ```Python\n        heroes = session.exec(select(Hero)).all()\n        ```\n        \"\"\"\n        return await super().execute(  # type: ignore\n            statement,\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def get(\n        self,\n        entity: Type[_TSelectParam],\n        ident: Any,\n        options: Optional[Sequence[Any]] = None,\n        populate_existing: bool = False,\n        with_for_update: Optional[Union[Literal[True], Mapping[str, Any]]] = None,\n        identity_token: Optional[Any] = None,\n    ) -> Optional[_TSelectParam]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().get(\n            entity,\n            ident,\n            options=options,\n            populate_existing=populate_existing,\n            with_for_update=with_for_update,\n            identity_token=identity_token,\n        )\n````\n\nì£¼ì„ì„ ë³´ë©´ ì•Œê² ì§€ë§Œ, ê·¸ëƒ¥ `sqlmodel.orm.session.Session` ê°ì²´ì˜ ê° ë©”ì†Œë“œì˜ íƒ€ì… íŒíŠ¸ë¥¼ ê·¸ëŒ€ë¡œ ê°€ì ¸ì™”ë‹¤. ì´ì— ë§ì¶°ì„œ ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸ì˜ `AsyncSession`ë„ ëª¨ë‘ `async_session`ì— ëŒ€í•œ ìŠ¤í¬ë¦½íŠ¸ë¡œ ë³€í™˜í•´ì¤€ë‹¤. ê·¸ë¦¬ê³  í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë©´ ë¬¸ì œì—†ì´ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\n---\n\n## `datetime_model` ê´€ë ¨ ë¬¸ì œ í•´ê²°\n\n`datetime_model`ì˜ `datetime_attrs` ì†ì„±ì´ ì˜ë„í•œëŒ€ë¡œ ì¶œë ¤ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ìˆì–´ì„œ ì¶”ê°€ë¡œ ìˆ˜ì •í–ˆë‹¤. `cls.__fields__.keys()` ë¥¼ `datetime_model.__fields__.keys()`ë¡œ ìˆ˜ì •í•œ ê²ƒì™¸ì— ëª¨ë‘ ë™ì¼í•˜ë‹¤.\n\n```python\n# backend/app/models/core.py\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -> _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def datetime_attrs(cls) -> set[str]:\n        return set(datetime_model.__fields__.keys())\n```\n\n## `id_model` ì„¸ë¶„í™”\n\nê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ `id_model`ì„ `int_id_model`ê³¼ `uuid_id_model`ë¡œ ì„¸ë¶„í™”í•´ì„œ ì‚¬ìš©í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n```python\n# backend/app/models/core.py\nfrom uuid import uuid4\nfrom pydantic import UUID4\n\n(...)\n\nclass id_model(fix_return_type_model):\n    @classmethod\n    @property\n    def id_type(cls) -> Any:\n        return cls.__fields__[\"id\"].type_\n\n\nclass int_id_model(id_model):\n    id: int | None = Field(None, primary_key=True)\n\n\nclass uuid_id_model(id_model):\n    id: UUID4 | None = Field(default_factory=uuid4, primary_key=True)\n```\n\n## `dependencies` ëª¨ë“ˆ ìƒì„±\n\nê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ `get_session`ì´ë‚˜ `get_current_user`ê°™ì€ `Depends`ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë˜ í•¨ìˆ˜ë¥¼ ë”°ë¡œ ê´€ë¦¬í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n```python\n# backend/app/dependencies/database.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\nfrom ..db.session import async_session\n\n\nasync def get_database(request: Request) -> AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -> AsyncIterator[async_session]:\n    async with async_session(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n```python\n# backend/app/dependencies/auth.py\nfrom ..services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\nget_user_manager = fastapi_user.get_user_manager\nget_backend = fastapi_user.get_backend\nget_transport = fastapi_user.get_transport\nget_strategy = fastapi_user.get_strategy\n```\n\n```python\n# backend/app/services/authentication/authentication.py\n(...)\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n    named_backends: dict[str, auth_backend_type] = field(default_factory=dict)\n\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -> Sequence[auth_backend_type]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def get_user_manager(self):\n        return self.users.get_user_manager\n\n    def find_backend(self, _val: str, /) -> auth_backend_type:\n        for backend in self.backends:\n            if backend.name == _val:\n                return backend\n        raise IndexError(f\"there is not auth_backend name: {_val}\")\n\n    def get_backend(self, _val: int | str = 0, /) -> auth_backend_type:\n        if isinstance(_val, int):\n            return self.backends[_val]\n\n        if (backend := self.named_backends.get(_val)) is None:\n            backend = self.named_backends[_val] = self.find_backend(_val)\n        return backend\n\n    def get_transport(self, _val: int | str = 0, /) -> Transport:\n        backend = self.get_backend(_val)\n        return backend.transport\n\n    def get_strategy(self, _val: int | str = 0, /):\n        backend = self.get_backend(_val)\n        return backend.get_strategy\n```\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ì… ë¬¸ì œ ì„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ì… ë¬¸ì œ ì„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","date":"2022-05-07T22:08:12.781+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## í† í° ë°œí–‰ ë°©ì‹ ìˆ˜ì •\n\n### ê¸°ì¡´ ì½”ë“œ ìˆ˜ì •\n\nì´ì „ì— í† í° ë°œí–‰ apië¥¼ ì§ì ‘ ì‘ì„±í–ˆëŠ”ë°, ì¢€ ë” ì•Œì•„ë³´ë‹ˆ, **`fastapi-users`** ì—ì„œ ì œê³µí•˜ëŠ” `login` apiì™€ ë™ì¼í•˜ë‹¤. ë”°ë¼ì„œ í† í° ë°œí–‰ê³¼ ê´€ë ¨í•´ì„œ ì•½ê°„ì˜ ìˆ˜ì •ì„ ì§„í–‰í•œë‹¤.\n\n> #### backend/app/core/config.py\n>\n> í† í° ê²½ë¡œ ìˆ˜ì •\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token/login\"\n```\n\n---\n\n`AUTH_BACKEND_NAME` ì¶”ê°€\n\n```python\nAUTH_BACKEND_NAME = config(\n    \"AUTH_BACKEND_NAME\", cast=str, default=f\"{JWT_TOKEN_PREFIX}-jwt\"\n)\n```\n\n> #### backend/app/services/authentication.py\n>\n> í† í° ëª¨ë¸ ì œê±°\n\n```python\n# class token_model(BaseModel):\n#     access_token: str\n#     token_type: str = config.JWT_TOKEN_PREFIX\n>\n#     @classmethod\n#     def from_token(cls, token: str) -> \"token_model\":\n#         return cls(access_token=toke\n```\n\n---\n\n`AUTH_BACKEND_NAME` ì°¸ì¡° ì¶”ê°€\n\n```python\ndef create_backend() -> list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n```\n\n> #### backend/app/api/routes/token.py\n>\n> **`fastapi-users`** ë¼ìš°í„° ì¶”ê°€\n> í¸ì˜ìƒ ë‹¹ë¶„ê°„ `requires_verification=False`ë¡œ í•œë‹¤.\n\n```python\n# name: auth:{backend.name}.login\nrouter.include_router(\n    fastapi_user.users.get_auth_router(\n        fastapi_user.backends[0], requires_verification=False\n    )\n)\n```\n\n---\n\nê¸°ì¡´ api ì œê±°\n\n```python\n# @router.post(\"\", name=\"users:create-token\")\n# async def create_token(\n#     credentials: OAuth2PasswordRequestForm = Depends(),\n#     user_manager: user_manager_type = fastapi_user.user_manager_depends,\n#     strategy: strategy_type = fastapi_user.strategy_depends(),\n# ) -> token_model:\n#     get_user = await user_manager.authenticate(credentials)\n#     if get_user is None or not get_user.is_active:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n#         )\n#     if not get_user.is_verified:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n#         )\n>\n#     token = await strategy.write_token(get_user)\n#     return token_model.from_token(token)\n```\n\n> #### backend/tests/test_users.py\n>\n> `api_name` ìˆ˜ì •\n\n```python\nclass TestAuthTokens:\n    api_name = f\"auth:{config.AUTH_BACKEND_NAME}.login\"\n```\n\n### **`fastapi-users`** ê°€ ì œê³µí•˜ëŠ” `api`ì˜ ê²€ì¦ ë°©ì‹\n\n> í˜„ì¬ ì‚¬ìš©ì¤‘ì¸ **`fastapi-users`** ì˜ ë²„ì „ì€ `9.3.1`ì´ë¼ëŠ” ê²ƒì— ìœ ì˜í•œë‹¤.\n\nìš°ì„  ì´ë©”ì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ìœ ì €ë¥¼ ì¡°íšŒ í•œ ë‹¤ìŒ, ë¹„ë°€ë²ˆí˜¸ë¥¼ ê²€ì¦í•œë‹¤.\nê·¸ë¦¬ê³  í•´ë‹¹ ìœ ì € ë ˆì½”ë“œì˜ `is_active`ê°€ `True`ì¸ì§€ í™•ì¸í•˜ê³ , `requires_verification` ê°’ì— ë”°ë¼ `is_verified`ê°€ `True`ì¸ì§€ í™•ì¸í•œë‹¤.\n\nìœ ì €ê°€ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜, `is_active=False`ì´ê±°ë‚˜, `requires_verification=True`ì´ë©´ì„œ `is_verified=False`ì¸ ê²½ìš° ì—ëŸ¬(400)ì„ ë°˜í™˜í•œë‹¤.\n\n## `TDD` ë°©ë²•ë¡ ì— ë”°ë¥¸ ë¡œê·¸ì¸ `api`\n\n### ì¼ë°˜ì ì¸ ë¡œê·¸ì¸ ë°©ì‹\n\n| ì‚¬ìš©ì                             | í”„ë¡ íŠ¸ì—”ë“œ                                    | ë°±ì—”ë“œ                         |\n| ---------------------------------- | --------------------------------------------- | ------------------------------ |\n| `name`, `password` ì…ë ¥            |                                               |                                |\n|                                    | `name`, `password` ë°±ì—”ë“œë¡œ ì „ì†¡              |                                |\n|                                    |                                               | `name`, `password` ìœ íš¨ì„± ê²€ì‚¬ |\n|                                    |                                               | í† í° ìƒì„±                      |\n|                                    |                                               | í† í° í”„ë¡ íŠ¸ì—”ë“œë¡œ ì „ì†¡         |\n|                                    | í† í° ì„ì‹œ ì €ì¥                                |\n| ë¡œê·¸ì¸ì´ í•„ìš”í•œ íŠ¹ì • í˜ì´ì§€ë¡œ ì´ë™ |                                               |                                |\n|                                    | ì €ì¥ëœ í† í°(Authorization í—¤ë”) ë°±ì—”ë“œë¡œ ì „ì†¡ |                                |\n|                                    |                                               | í† í° ìœ íš¨ì„± ê²€ì‚¬               |\n|                                    |                                               | ì»¨í…ì¸  ì „ì†¡                    |\n| ...                                | ...                                           | ...                            |\n\n### ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±\n\n```python\n# backend/tests/test_users.py\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n(...)\n\nclass TestUserLogin:\n    api_name = \"users:login-email-and-password\"\n\n    async def test_user_can_login_successfully_and_receives_valid_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        login_data = {\"email\": test_user.email, \"password\": \"heatcavslakers@1\"}\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status.HTTP_200_OK\n        # check that token exists in response and has user encoded within it\n        token = res.json().get(\"access_token\")\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n            manager = UserManager(db)\n\n            read_user: user.user_model | None = await strategy.read_token(\n                token, manager\n            )\n        assert read_user is not None\n        assert read_user.name == test_user.name\n        assert read_user.email == test_user.email\n        # check that token is proper type\n        assert \"token_type\" in res.json()\n        assert res.json().get(\"token_type\") == \"bearer\"\n\n    @pytest.mark.parametrize(\n        \"credential, wrong_value, status_code\",\n        (\n            (\"email\", \"wrong@email.com\", 401),\n            (\"email\", None, 401),\n            (\"email\", \"notemail\", 401),\n            (\"password\", \"wrongpassword@1\", 401),\n            (\"password\", None, 401),\n        ),\n    )\n    async def test_user_with_wrong_creds_doesnt_receive_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        credential: str,\n        wrong_value: str,\n        status_code: int,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        user_data = test_user.dict()\n        user_data[\"password\"] = \"heatcavslakers@1\"\n        user_data[credential] = wrong_value\n        login_data = {\n            \"username\": user_data[\"email\"],\n            \"password\": user_data[\"password\"],  # insert password from parameters\n        }\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status_code\n        assert \"access_token\" not in res.json()\n```\n\nì‚¬ìš©ìê°€ `email`ê³¼ `password`ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë³´ëƒˆì„ ë•Œ ì–»ê²Œ ë˜ëŠ” í† í°ìœ¼ë¡œ ë¶€í„°, **`fastapi_users`** ë¥¼ ì´ìš©í•´ì„œ ë¶ˆëŸ¬ì˜¨ ìœ ì € ë ˆì½”ë“œê°€ `test_user`ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.\n\nì—¬ê¸°ì„œ ë¡œê·¸ì¸ì˜ ê²½ìš° `json` íŒŒë¼ë¯¸í„°ê°€ ì•„ë‹Œ `data` íŒŒë¼ë¯¸í„°ë¡œ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ê³ , `content-type` í—¤ë”ë¡œ `application/x-www-form-urlencoded`ë¥¼ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤ëŠ” ì ì— ìœ ì˜í•œë‹¤.\n\n### ë¡œê·¸ì¸ `api` ì‘ì„±\n\ní† í° ë°œí–‰ apiê°€ ë¡œê·¸ì¸ apiì´ë¯€ë¡œ, ë”°ë¡œ ì‘ì„±í•  í•„ìš”ê°€ ì—†ë‹¤.\në§Œì•½ 400ì—ëŸ¬ê°€ ì•„ë‹Œ 401ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ê³  ì‹¶ë‹¤ë©´, ì´ì „ ì±•í„°ì²˜ëŸ¼ ì§ì ‘ ì‘ì„±í•˜ë©´ ëœë‹¤.\n\n### ì¸ì¦ `Depends` ìƒì„±\n\nì´ì œ í† í°ì„ ë°œê¸‰ë°›ì€ ê²½ìš°ì—ë§Œ ì‚¬ìš©ì´ ê°€ëŠ¥í•œ apiì— ëŒ€í•œ ì¸ì¦ ì ˆì°¨ë¥¼ ì •ì˜í•´ì•¼í•œë‹¤. **`fastapi`** ì—ì„œëŠ” ì´ëŸ¬í•œ ê¸°ëŠ¥ì€ `Depends`ë¥¼ ì‚¬ìš©í•´ì„œ ìƒì„±í•  ìˆ˜ ìˆë‹¤. ë˜í•œ, **`fastapi-users`** ì—ì„œ ê´€ë ¨ëœ í•¨ìˆ˜ë¥¼ ì´ë¯¸ ë§Œë“¤ì–´ì„œ ì œê³µí•˜ê³  ìˆë‹¤. ìš°ì„  í…ŒìŠ¤íŠ¸ ì½”ë“œë¶€í„° ì‘ì„±í•œë‹¤.\n\n```python\n# backend/tests/conftest.py\nfrom app.services.authentication import create_strategy\nfrom sqlmodel import select\n\n(...)\n\n@pytest.fixture\nasync def authorized_client(\n    client: AsyncClient, test_user: user.user_model\n) -> AsyncClient:\n    from app.core import config\n\n    strategy = create_strategy()\n    access_token = await strategy.write_token(user=test_user)  # type: ignore\n\n    client.headers[\"Authorization\"] = f\"{config.JWT_TOKEN_PREFIX} {access_token}\"\n    return client\n```\n\në°©ê¸ˆ ì‘ì„±í•œ `authorized_client`ë¥¼ ì´ìš©í•´ì„œ ì¸ì¦ì´ í•„ìš”í•œ ë¼ìš°í„°ì— ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.\n\n> ì“°ë‹¤ë³´ë‹ˆ `user.user`ì™€ `user.user_model`ì´ ë”°ë¡œ ìˆëŠ”ê²Œ ë„ˆë¬´ ë¶ˆí¸í•œë°, ì–¸ì œ í•œë²ˆ í•©ì¹˜ëŠ” ì‹œë„ë¥¼ í•´ë´ì•¼ í• ë“¯. `AsyncSession` ê´€ë ¨í•´ì„œë„ ì–¸ì œí•œë²ˆ í•´ê²°ì„ í•´ì•¼í•  ê²ƒ ê°™ê³ ..\n\n```python\n# backend/tests/test_users.py\n(...)\n\nclass TestUserMe:\n    api_name = \"users:get-current-user\"\n\n    async def test_authenticated_user_can_retrieve_own_data(\n        self,\n        app: FastAPI,\n        authorized_client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await authorized_client.get(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_200_OK\n        res_dict: dict = res.json()\n        res_dict[\"hashed_password\"] = \"testpassword@1\"\n        read_user = user.user_model.validate(res_dict)\n        assert read_user.email == test_user.email\n        assert read_user.name == test_user.name\n        assert read_user.id == test_user.id\n\n    async def test_user_cannot_access_own_data_if_not_authenticated(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await client.get(app.url_path_for(\"users:get-current-user\"))\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n\n    @pytest.mark.parametrize(\n        \"jwt_prefix\",\n        (\n            (\"\",),\n            (\"value\",),\n            (\"Token\",),\n            (\"JWT\",),\n            (\"Swearer\",),\n        ),\n    )\n    async def test_user_cannot_access_own_data_with_incorrect_jwt_prefix(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        jwt_prefix: str,\n    ) -> None:\n        token = await strategy.write_token(test_user)\n        res = await client.get(\n            app.url_path_for(\"users:get-current-user\"),\n            headers={\"Authorization\": f\"{jwt_prefix} {token}\"},\n        )\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n```\n\nìœ„ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•  ìˆ˜ ìˆëŠ” apië¥¼ ì‘ì„±í•œë‹¤.\n\n```python\nfrom fastapi import Depends\n\n(...)\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\n\n(...)\n\n@router.get(\"/me\", response_model=user.user_read, name=\"users:get-current-user\")\nasync def get_currently_authenticated_user(\n    current_user: user.user = Depends(get_current_user),\n) -> user.user_model:\n    return current_user.to_model()\n```\n\n`optional=False, active=True, verified=False, superuser=False`ìœ¼ë¡œ ê°’ì„ ì§€ì •í–ˆê¸°ì—, í•´ë‹¹ í•¨ìˆ˜ëŠ” ì¼ì¹˜í•˜ëŠ” ìœ ì €ê°€ ì—†ê±°ë‚˜ `is_active` ê°’ì´ `False`ì´ë©´ ì—ëŸ¬(401)ì„ ë°˜í™˜í•œë‹¤.\n\ní…ŒìŠ¤íŠ¸ í†µê³¼ë„ ì˜ë˜ê³ , **`swagger`** ì—ì„œë„ í™•ì¸ì´ ê°„ë‹¨í•œ apiê°€ ìƒì„±ëë‹¤. ìœ ì € ì¸ì¦ ê´€ë ¨í•´ì„œëŠ” ì‚¬ì‹¤ìƒ ì´ê²Œ ëì´ë‹¤. ì½”ë“œë¥¼ ì¡°ê¸ˆ ë” ì •ë¦¬í•  ìˆ˜ëŠ” ìˆì§€ë§Œ í•µì‹¬ì€ ë¹„ìŠ·í•  ê²ƒì´ë‹¤.\n\në‹¤ìŒ ì±•í„°ì—ì„œëŠ” ìœ ì € í”„ë¡œí•„ì„ ì„¤ì •í•œë‹¤.\nê·¸ ì „ì— ì•ì—ì„œ ì–¸ê¸‰í•œ ìœ ì € ëª¨ë¸ê³¼ ê´€ë ¨ëœ ìˆ˜ì •ì„ ì§„í–‰í•  ìˆ˜ë„ ìˆë‹¤.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","date":"2022-05-06T06:26:51.932+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}}]},"__N_SSG":true}