{"pageProps":{"tag":"@all","page":2,"max_page":6,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"vim 영문 키보드 자동 전환","content":"\n# 아래 글은 퍼온 글입니다.\n출처는 다음과 같습니다.\n\n[[Vim] Normal모드에서 영문 키보드로 자동 전환하기 (Windows)](https://rottk.tistory.com/entry/Vim-Normal%EB%AA%A8%EB%93%9C%EC%97%90%EC%84%9C-%EC%98%81%EB%AC%B8-%ED%82%A4%EB%B3%B4%EB%93%9C%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-Windows)\n\n---\n\n# Windows에서 `Vim`을 사용하는 경우 (`VSCode`의 `Vim Extension`, `WSL`에서의 `Vim`)\n`Vim` 사용 시 흔히 겪는 문제가 한글로 주석 작성 후, Normal 모드로 전환하여 명령어를 입력하면 명령어가 적용되지 않는 문제가 있습니다.\n\n예를 들어, 파일 저장을 위해 `ESC` + `:w` 를 입력하였으나, 실제로는 `ESC`, `:ㅈ`가 입력되어 저장이 되지 않는 경우입니다.\n\n`Vim`에서 한글을 입력하는 경우는 코드에 주석을 넣는 경우 이외에는 없으므로, Normal 모드로 전환 시(즉, `ESC`를 누르면) 영문으로 자동전환이 되도록 설정하면 이러한 문제가 해결될 것입니다.\n\n※ 간단히 IME에서 해당 기능을 제공해준다면 별도의 프로그램을 설치하지 않아도 되겠지만 아쉽게도 `Microsoft IME`는 설정 기능이 존재하지 않아 외부 프로그램(키 매크로)을 설치하여 도움을 받아야 합니다.\n* 윈도에 [Auto HotKey](https://www.autohotkey.com/)를 설치합니다.\n* 메모장에 `Script.ahk`를 만들어 아래의 Script를 작성합니다.\n* 작성한 스크립트를 더블 클릭하여 실행합니다. 이후, `ESC`를 누르면 자동으로 영문 키보드로 전환됩니다.\n\n```auto hotkey\n$Esc::\n    if(IME_CHECK(\"A\"))\n        Send, {VK15}    ;영문이라면 한영전환 키를 입력해준다.\n    Send, {Escape}\n    return\n\n/*\n  IME check \n*/\nIME_CHECK(WinTitle) {\n  WinGet,hWnd,ID,%WinTitle%\n  Return Send_ImeControl(ImmGetDefaultIMEWnd(hWnd),0x005,\"\")\n}\nSend_ImeControl(DefaultIMEWnd, wParam, lParam) {\n  DetectSave := A_DetectHiddenWindows\n  DetectHiddenWindows,ON\n   SendMessage 0x283, wParam,lParam,,ahk_id %DefaultIMEWnd%\n  if (DetectSave <> A_DetectHiddenWindows)\n      DetectHiddenWindows,%DetectSave%\n  return ErrorLevel\n}\nImmGetDefaultIMEWnd(hWnd) {\n  return DllCall(\"imm32\\ImmGetDefaultIMEWnd\", Uint,hWnd, Uint)\n}\n```\n\n## Windows 실행시 자동으로 Script 시작하기\nScript를 실행파일(.exe)로 변환합니다.\n\n1. `C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\AutoHotkey` 폴더로 이동합니다.\n2. `Convert .ahk to .exe`를 더블클릭하여 실행합니다.\n3. `Source`항목에서 앞서 작성한 `script.ahk`를 추가합니다.\n4. `Convert` 를 클릭합니다.\n5. 'Conversion complete' 팝업이 표시되면, .exe 파일이 스크립트와 같은 폴더에 생성됩니다.\n\n실행파일을 윈도우즈 시작프로그램으로 추가합니다.\n\n1. Windows 로고 키 + R을 누르고 `shell:startup`을 입력한 다음 확인을 선택합니다. 그러면 시작 폴더가 열립니다.\n2. 앞서 변환한 실행파일(.exe)을 복사하여 시작 폴더에 붙여넣습니다.\n\n# 출처\n* [https://github.com/johngrib/simple_vim_guide/blob/master/md/with_korean.md](https://github.com/johngrib/simple_vim_guide/blob/master/md/with_korean.md)\n* [https://www.autohotkey.com/](https://www.autohotkey.com/)\n* [Windows 10에서 시작할 때 자동으로 실행되는 앱 추가](https://support.microsoft.com/ko-kr/windows/windows-10%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%ED%95%A0-%EB%95%8C-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94-%EC%95%B1-%EC%B6%94%EA%B0%80-150da165-dcd9-7230-517b-cf3c295d89dd)\n* [AHK Startup Under Windows 10](https://www.autohotkey.com/boards/viewtopic.php?t=15820)\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"other/vim 영문 키보드 자동 전환","data":{"title":"[Vim] Normal모드에서 영문 키보드로 자동 전환하기 (Windows)","tags":["windows","wsl","vim","@all"],"page":null,"summary":"esc를 누르면 자동으로 영문 키보드가 된다.","date":"2022-08-06T20:00:32.948+09:00"}},{"name":"velog에서 git page로 블로그 이전","content":"\n# 왜 옮겼나?\n\n지난 몇달간 `velog`에서 몇몇 포스트를 작성했다.\n잘 만들어진 구성이다 보니 별다른 불만 없이 잘 사용했다.\n하지만 지난 며칠간의 연습 끝에 `git page`로 블로그를 이전했다.\n\n## 처음부터 `git page`를 쓰고 싶었다.\n\n사실 이전부터 `git page`로 블로그를 만들고 싶었다.\n가장 많이 알려진 간단한 방법은 `jekyll`를 사용하는 것이다.\n하지만 `ruby`로 작성된 엔진이다 보니 제대로 알아보는데 힘이 들었다.\n그렇다고 `ruby`를 따로 배워보자니, 살면서 `ruby`를 사용할 일이 얼마나 있을까 하는 생각이 문득 들었다.\n차라리 `go`나 `rust`라면 노력해보겠지만, `ruby`라니..\n\n그렇게 그냥 하지 말까? 하다가 알게된게 `velog`였다.\n`velog`는 내가 처음에 기대한 거의 모든 것을 만족했다.\n\n- 마크다운을 이용한 포스팅\n- 코드 블록 하이라이팅\n- 실시간 포스팅 프리뷰\n\n겨우 세가지지만 이 세가지를 만족하는 곳이 사실상 없다.\n그리고 따로 내가 레이아웃을 수정할 필요가 없다보니(사실 방법도 없다), 그냥 잘 만들어진 플랫폼에 글만 쓰면 내가 원하는게 다 됐다.\n\n## `velog`는 다 좋은데 이게 없다.\n\n하지만 쓰다보니 역시 아쉬운게 보인다.\n\n- 명확한 기준은 모르겠지만, 몇몇 양식에 대한 하이라이팅 미지원(log 등)\n- 작성글 숨기기\n\n그리고 무엇보다도.. 내가 직접 만든다는 성취감이 없었다.\n그래서 결국 직접 만들기로 했다.\n\n다만 `velog`덕분에 카테고리가 무조건 있어야 한다는 고정관념에서 벗어날 수 있었다.\n태그를 추가하면, 태그가 기존의 카테고리처럼 사용될 수 있게 하면 된다.\n또한 특정 포스트간의 연결이 필요하다면, 따로 지정할 수 있는 기능이 있으면 된다.\n\n`velog`에서 얻은 소중한 경험을 토대로, `git page`에 블로그를 만들기 위한 준비를 했다.\n\n# 어떻게 옮겼나?\n\n처음에는 그냥 익숙한 `python`으로 작성하려 했다.\n`pelican`이라는 라이브러리가 있어서, `jekyll`처럼 간단하게 정적 사이트를 배포할 수 있게 한다. 사용 언어가 `python`이다 보니 관련 스크립트를 확인하며, 작동 방식을 파악하는 것도 할만했다.\n\n하지만 반응형으로 작성해보려 하니, 결국 `javascript`를 쓸 수 밖에 없었다.\n그리고 어차피 `javascript`를 써야한다면.. 이번기회에 공부도 할 겸 완전히 `javascript`로 작성해보자는 생각이 들었다.\n\n여기서 `vue`냐, `react`냐 많은 고민이 있었고, 여러 시도가 있었는데, 결국 선택한건 `react`다.\n그리고 `react` 앱을 간단하게 작성하고 배포할 수 있는 프레임워크로 `nextjs`를 사용했다.\n\n처음 생각은 `javascript`였는데, `python`의 타입 힌트를 이용한 `vscode`의 자동완성 기능에 너무 익숙해져서 그런가, 코드 작성이 너무 불편했다.\n마침 `nextjs`가 `typescript`를 지원하기도 해서, 약간의 수고가 있었지만 `typescript`로 앱을 작성했다.\n\n많은 삽질끝에 그래도 `git page`에 배포할 수 있는 형태로 만드는데 성공했다.\n이제 부족한 몇몇 기능을 추가하고, 디자인을 손보기만 하면 된다.\n그러고보니... `typescript`보다 `css`가 더 어려운 것 같다..\n아무리 해도 예쁘게 보이지를 않는다..\n\n# 앞으로 추가할 기능\n\n- [ ] 다크모드 토글\n  > 사실 이미 기능 추가는 했지만, css 작성하기가 힘들어서 주석으로 놔둔 상태\n- [ ] 문단 제목 역링크\n- [ ] 코드 블럭 라인 하이라이트\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"js/velog에서 git page로 블로그 이전","data":{"title":"velog에서 git page로 블로그 이전","tags":["js","ts","nextjs","velog","github","@all"],"page":null,"date":"2022-06-12T04:27:48.097+09:00","summary":"there is no summary"}},{"name":"fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `Breaking` `changes`\n\n이틀전 **`fastapi-users`** 에 큰 변화가 생겼다. `v10` 릴리즈가 공개됐는데, `db` 모델과 여러 제네릭 타입에 대한 변화가 생겨서, `v10`을 이용하려면 대응 패치가 필수적인 상황..\n\n아래는 해당 릴리즈에 대한 전문이다.\n\n> ### [Breaking changes](https://github.com/fastapi-users/fastapi-users/releases/tag/v10.0.0)\n>\n> Version 10 marks important changes in how we manage User models and their ID.\n>\n> Before, we were relying only on Pydantic models to work with users. In particular the current_user dependency would return you an instance of UserDB, a Pydantic model. This proved to be quite problematic with some ORM if you ever needed to retrieve relationship data or make specific requests.\n>\n> Now, FastAPI Users is designed to always return you a native object for your ORM model, whether it's an SQLAlchemy model or a Beanie document. Pydantic models are now only used for validation and serialization inside the API.\n>\n> Before, we were forcing the use of UUID as primary key ID; a consequence of the design above. This proved to be quite problematic on some databases, like MongoDB which uses a special ObjectID format by default. Some SQL folks also prefer to use traditional auto-increment integers.\n>\n> Now, FastAPI Users is designed to use generic ID type. It means that you can use any type you want for your user's ID. By default, SQLAlchemy adapter still use UUID; but you can quite easily switch to another thing, like an integer. Beanie adapter for MongoDB will use native ObjectID by default, but it also can be overriden.\n\n### 유저 모델 생성 및 수정\n\n기존 `fastapi_users.models` 에서 `fastapi_users.schemas`로 바뀐 것 외에 크게 달라진 것은 없다. 사실 이전에 얘기했던 `user` 와 `user_model`을 통합하는 작업을 이미 한 다음 `v10` 릴리즈를 확인했기에 더욱 그렇게 느껴졌다...\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar\n\nfrom fastapi_users import schemas\nfrom pydantic import EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field, select\n\nfrom ..db.session import async_session\nfrom .core import base_model, datetime_model, uuid_id_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\n_T = TypeVar(\"_T\", bound=\"user\")\nid_model = uuid_id_model\nuser_id_type = id_model.id_type\n\n\nclass user(id_model, datetime_model, base_model, table=True):\n    __tablename__: str = \"users\"\n\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: async_session, email: str\n    ) -> _T | None:\n        is_user_cur = await session.exec(select(cls).where(cls.email == email))\n        return is_user_cur.first()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.validate(self)\n\n\nclass user_read(schemas.BaseUser[user_id_type], datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(schemas.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(schemas.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n```\n\n### 인증 모듈 제네릭 타입 덮어씌우기\n\n**`fastapi-users`** 에서 원하는 형태는 `SQLAlchemyBaseUserTable`를 상속한 클래스를 사용하는 것이지만, **`sqlmodel`** 도 그대로 사용하고 **`fastapi-users`** 의 타입 힌트도 그대로 사용하고 싶기에, 두 라이브러리를 엮어줄 새로운 제네릭 클래스를 생성한다.\n`# type: ignore`를 남발하기에 그다지 좋은 모습이라고 생각되지 않지만, 이거 외에 당장 생각나는 방법이 없기에 일단 넘어가자.\n\n```bash\n❯ mkdir backend/app/services/authentication\n❯ mv backend/app/services/authentication.py backend/app/services/authentication/authentication.py\n❯ touch backend/app/services/authentication/__init__.py backend/app/services/authentication/convert.py\n```\n\n```python\n# backend/app/services/authentication/__init__.py\nfrom .authentication import *\n```\n\n```python\n# backend/app/services/authentication/convert.py\nfrom typing import Generic, TypeVar\n\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import AuthenticationBackend, JWTStrategy, Strategy\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n\nfrom ...models.core import base_model\nfrom ...models.user import user\n\nuser_id_type = user.id_type\n_T = TypeVar(\"_T\", bound=base_model)\n_D = TypeVar(\"_D\")\n\n# fmt: off\nclass user_db_class(SQLAlchemyUserDatabase[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass strategy_class(Strategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass jwt_strategy_class(JWTStrategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass auth_backend_class(AuthenticationBackend[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass user_manager_class(BaseUserManager[_T, _D], Generic[_T, _D]): ...  # type: ignore\nclass fastapi_users_class(FastAPIUsers[_T, _D], Generic[_T, _D]): ...  # type: ignore\n# fmt: on\n\n\nuser_manager_type = user_manager_class[user, user_id_type]\nstrategy_type = strategy_class[user, user_id_type]\n```\n\n### 변경점 인증 모듈에 적용\n\n```python\n# backend/app/services/authentication/authentication.py\nimport re\nfrom dataclasses import dataclass\nfrom re import Pattern\nfrom typing import AsyncGenerator, Sequence\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import IntegerIDMixin, InvalidPasswordException\nfrom fastapi_users.authentication import BearerTransport, Transport\n\nfrom ...core import config\nfrom ...db.session import async_session, get_session\nfrom ...models import user\nfrom .convert import (\n    auth_backend_class,\n    fastapi_users_class,\n    jwt_strategy_class,\n    strategy_class,\n    strategy_type,\n    user_db_class,\n    user_id_type,\n    user_manager_class,\n    user_manager_type,\n)\n\n\nasync def get_user_db(\n    session: async_session = Depends(get_session),\n) -> AsyncGenerator[user_db_class[user.user, user_id_type], None]:\n    yield user_db_class(session, user.user)\n\n\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\n\ndef create_strategy() -> strategy_class[user.user, user_id_type]:\n    return jwt_strategy_class(  # type: ignore\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n\ndef create_backend() -> list[auth_backend_class[user.user, user_id_type]]:\n    transport = create_transport()\n    return [\n        auth_backend_class(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n\n\nclass UserManager(IntegerIDMixin, user_manager_class[user.user, user_id_type]):\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+<>@\\#$%&\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -> None:\n        if len(password) < self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) > self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\n        for pattern in self.re_password_deny_list:\n            if pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\n        for pattern in self.re_password_need_list:\n            if not pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -> AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(\n    *backends: auth_backend_class[user.user, user_id_type],\n) -> fastapi_users_class[user.user, user_id_type]:\n    return fastapi_users_class(\n        get_user_manager=get_user_manager, auth_backends=backends\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -> Sequence[auth_backend_class[user.user, user_id_type]]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n꽤 많이 바뀌긴 했지만, 실제로 사용할때는 이름정도만 바뀌지 사용법 자체는 변한게 없다. 바뀐 이름에 맞춰서 라우터와 테스트 코드를 수정해주면, 정상적으로 작동하는 것을 확인할 수 있다.\n\n이번 기회에 테스트 코드가 얼마나 좋은건지 알게됐다.. 긴가민가할때 `pytest --tb=short` 한방이면 의문이 해결된다.\n\n사실 변경할게 하나 더 남긴 했지만, 이거 아직 시도해보지 않았다.\n현재 헤더를 사용한 인증 방식인데, 쿠키를 사용하고, `access-token`과 `refresh-token`을 사용한 방식으로 변경해보려 한다. 다만 **`fastapi-users`** 자체적으로는 지원하지 않기에, 직접 작성할 필요가 있어서 약간 고민이 필요할듯.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","data":{"title":"fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","date":"2022-05-07T23:00:58.369+09:00","tags":["fastapi","fastapi-users","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `Session`의 코드를 그대로 복붙\n\n이전까지 글에서 계속해서 `AsyncSession`의 타입 관련 문제가 발생하는게 너무 짜증나서, 임시로 땜빵용 클래스를 생성해서 사용하기로 했다.\n\n````python\n# backend/app/db/session.py\n(...)\n\n_TSelectParam = TypeVar(\"_TSelectParam\")\n\nclass async_session(AsyncSession):\n    # sqlmodel.orm.session.Session\n    @overload\n    async def exec(\n        self,\n        statement: Select[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Result[_TSelectParam]:\n        ...\n\n    @overload\n    async def exec(\n        self,\n        statement: SelectOfScalar[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> ScalarResult[_TSelectParam]:\n        ...\n\n    async def exec(\n        self,\n        statement: Union[\n            Select[_TSelectParam],\n            SelectOfScalar[_TSelectParam],\n            Executable[_TSelectParam],\n        ],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Union[Result[_TSelectParam], ScalarResult[_TSelectParam]]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().exec(\n            statement,  # type: ignore\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def execute(\n        self,\n        statement: _Executable,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Optional[Mapping[str, Any]] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -> Result[Any]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        ***\n\n        🚨 You probably want to use `session.exec()` instead of `session.execute()`.\n\n        This is the original SQLAlchemy `session.execute()` method that returns objects\n        of type `Row`, and that you have to call `scalars()` to get the model objects.\n\n        For example:\n\n        ```Python\n        heroes = session.execute(select(Hero)).scalars().all()\n        ```\n\n        instead you could use `exec()`:\n\n        ```Python\n        heroes = session.exec(select(Hero)).all()\n        ```\n        \"\"\"\n        return await super().execute(  # type: ignore\n            statement,\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def get(\n        self,\n        entity: Type[_TSelectParam],\n        ident: Any,\n        options: Optional[Sequence[Any]] = None,\n        populate_existing: bool = False,\n        with_for_update: Optional[Union[Literal[True], Mapping[str, Any]]] = None,\n        identity_token: Optional[Any] = None,\n    ) -> Optional[_TSelectParam]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().get(\n            entity,\n            ident,\n            options=options,\n            populate_existing=populate_existing,\n            with_for_update=with_for_update,\n            identity_token=identity_token,\n        )\n````\n\n주석을 보면 알겠지만, 그냥 `sqlmodel.orm.session.Session` 객체의 각 메소드의 타입 힌트를 그대로 가져왔다. 이에 맞춰서 다른 스크립트의 `AsyncSession`도 모두 `async_session`에 대한 스크립트로 변환해준다. 그리고 테스트 코드를 실행해보면 문제없이 실행되는 것을 확인할 수 있다.\n\n---\n\n## `datetime_model` 관련 문제 해결\n\n`datetime_model`의 `datetime_attrs` 속성이 의도한대로 출려되지 않는 문제가 있어서 추가로 수정했다. `cls.__fields__.keys()` 를 `datetime_model.__fields__.keys()`로 수정한 것외에 모두 동일하다.\n\n```python\n# backend/app/models/core.py\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -> _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def datetime_attrs(cls) -> set[str]:\n        return set(datetime_model.__fields__.keys())\n```\n\n## `id_model` 세분화\n\n기존에 사용하던 `id_model`을 `int_id_model`과 `uuid_id_model`로 세분화해서 사용하기로 했다.\n\n```python\n# backend/app/models/core.py\nfrom uuid import uuid4\nfrom pydantic import UUID4\n\n(...)\n\nclass id_model(fix_return_type_model):\n    @classmethod\n    @property\n    def id_type(cls) -> Any:\n        return cls.__fields__[\"id\"].type_\n\n\nclass int_id_model(id_model):\n    id: int | None = Field(None, primary_key=True)\n\n\nclass uuid_id_model(id_model):\n    id: UUID4 | None = Field(default_factory=uuid4, primary_key=True)\n```\n\n## `dependencies` 모듈 생성\n\n기존에 사용하던 `get_session`이나 `get_current_user`같은 `Depends`와 함께 사용하던 함수를 따로 관리하기로 했다.\n\n```python\n# backend/app/dependencies/database.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\nfrom ..db.session import async_session\n\n\nasync def get_database(request: Request) -> AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -> AsyncIterator[async_session]:\n    async with async_session(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n```python\n# backend/app/dependencies/auth.py\nfrom ..services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\nget_user_manager = fastapi_user.get_user_manager\nget_backend = fastapi_user.get_backend\nget_transport = fastapi_user.get_transport\nget_strategy = fastapi_user.get_strategy\n```\n\n```python\n# backend/app/services/authentication/authentication.py\n(...)\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n    named_backends: dict[str, auth_backend_type] = field(default_factory=dict)\n\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -> Sequence[auth_backend_type]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def get_user_manager(self):\n        return self.users.get_user_manager\n\n    def find_backend(self, _val: str, /) -> auth_backend_type:\n        for backend in self.backends:\n            if backend.name == _val:\n                return backend\n        raise IndexError(f\"there is not auth_backend name: {_val}\")\n\n    def get_backend(self, _val: int | str = 0, /) -> auth_backend_type:\n        if isinstance(_val, int):\n            return self.backends[_val]\n\n        if (backend := self.named_backends.get(_val)) is None:\n            backend = self.named_backends[_val] = self.find_backend(_val)\n        return backend\n\n    def get_transport(self, _val: int | str = 0, /) -> Transport:\n        backend = self.get_backend(_val)\n        return backend.transport\n\n    def get_strategy(self, _val: int | str = 0, /):\n        backend = self.get_backend(_val)\n        return backend.get_strategy\n```\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","data":{"title":"fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","date":"2022-05-07T22:08:12.781+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## 토큰 발행 방식 수정\n\n### 기존 코드 수정\n\n이전에 토큰 발행 api를 직접 작성했는데, 좀 더 알아보니, **`fastapi-users`** 에서 제공하는 `login` api와 동일하다. 따라서 토큰 발행과 관련해서 약간의 수정을 진행한다.\n\n> #### backend/app/core/config.py\n>\n> 토큰 경로 수정\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token/login\"\n```\n\n---\n\n`AUTH_BACKEND_NAME` 추가\n\n```python\nAUTH_BACKEND_NAME = config(\n    \"AUTH_BACKEND_NAME\", cast=str, default=f\"{JWT_TOKEN_PREFIX}-jwt\"\n)\n```\n\n> #### backend/app/services/authentication.py\n>\n> 토큰 모델 제거\n\n```python\n# class token_model(BaseModel):\n#     access_token: str\n#     token_type: str = config.JWT_TOKEN_PREFIX\n>\n#     @classmethod\n#     def from_token(cls, token: str) -> \"token_model\":\n#         return cls(access_token=toke\n```\n\n---\n\n`AUTH_BACKEND_NAME` 참조 추가\n\n```python\ndef create_backend() -> list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n```\n\n> #### backend/app/api/routes/token.py\n>\n> **`fastapi-users`** 라우터 추가\n> 편의상 당분간 `requires_verification=False`로 한다.\n\n```python\n# name: auth:{backend.name}.login\nrouter.include_router(\n    fastapi_user.users.get_auth_router(\n        fastapi_user.backends[0], requires_verification=False\n    )\n)\n```\n\n---\n\n기존 api 제거\n\n```python\n# @router.post(\"\", name=\"users:create-token\")\n# async def create_token(\n#     credentials: OAuth2PasswordRequestForm = Depends(),\n#     user_manager: user_manager_type = fastapi_user.user_manager_depends,\n#     strategy: strategy_type = fastapi_user.strategy_depends(),\n# ) -> token_model:\n#     get_user = await user_manager.authenticate(credentials)\n#     if get_user is None or not get_user.is_active:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n#         )\n#     if not get_user.is_verified:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n#         )\n>\n#     token = await strategy.write_token(get_user)\n#     return token_model.from_token(token)\n```\n\n> #### backend/tests/test_users.py\n>\n> `api_name` 수정\n\n```python\nclass TestAuthTokens:\n    api_name = f\"auth:{config.AUTH_BACKEND_NAME}.login\"\n```\n\n### **`fastapi-users`** 가 제공하는 `api`의 검증 방식\n\n> 현재 사용중인 **`fastapi-users`** 의 버전은 `9.3.1`이라는 것에 유의한다.\n\n우선 이메일을 기준으로 유저를 조회 한 다음, 비밀번호를 검증한다.\n그리고 해당 유저 레코드의 `is_active`가 `True`인지 확인하고, `requires_verification` 값에 따라 `is_verified`가 `True`인지 확인한다.\n\n유저가 존재하지 않거나, `is_active=False`이거나, `requires_verification=True`이면서 `is_verified=False`인 경우 에러(400)을 반환한다.\n\n## `TDD` 방법론에 따른 로그인 `api`\n\n### 일반적인 로그인 방식\n\n| 사용자                             | 프론트엔드                                    | 백엔드                         |\n| ---------------------------------- | --------------------------------------------- | ------------------------------ |\n| `name`, `password` 입력            |                                               |                                |\n|                                    | `name`, `password` 백엔드로 전송              |                                |\n|                                    |                                               | `name`, `password` 유효성 검사 |\n|                                    |                                               | 토큰 생성                      |\n|                                    |                                               | 토큰 프론트엔드로 전송         |\n|                                    | 토큰 임시 저장                                |\n| 로그인이 필요한 특정 페이지로 이동 |                                               |                                |\n|                                    | 저장된 토큰(Authorization 헤더) 백엔드로 전송 |                                |\n|                                    |                                               | 토큰 유효성 검사               |\n|                                    |                                               | 컨텐츠 전송                    |\n| ...                                | ...                                           | ...                            |\n\n### 로그인 테스트 코드 작성\n\n```python\n# backend/tests/test_users.py\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n(...)\n\nclass TestUserLogin:\n    api_name = \"users:login-email-and-password\"\n\n    async def test_user_can_login_successfully_and_receives_valid_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        login_data = {\"email\": test_user.email, \"password\": \"heatcavslakers@1\"}\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status.HTTP_200_OK\n        # check that token exists in response and has user encoded within it\n        token = res.json().get(\"access_token\")\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n            manager = UserManager(db)\n\n            read_user: user.user_model | None = await strategy.read_token(\n                token, manager\n            )\n        assert read_user is not None\n        assert read_user.name == test_user.name\n        assert read_user.email == test_user.email\n        # check that token is proper type\n        assert \"token_type\" in res.json()\n        assert res.json().get(\"token_type\") == \"bearer\"\n\n    @pytest.mark.parametrize(\n        \"credential, wrong_value, status_code\",\n        (\n            (\"email\", \"wrong@email.com\", 401),\n            (\"email\", None, 401),\n            (\"email\", \"notemail\", 401),\n            (\"password\", \"wrongpassword@1\", 401),\n            (\"password\", None, 401),\n        ),\n    )\n    async def test_user_with_wrong_creds_doesnt_receive_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        credential: str,\n        wrong_value: str,\n        status_code: int,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        user_data = test_user.dict()\n        user_data[\"password\"] = \"heatcavslakers@1\"\n        user_data[credential] = wrong_value\n        login_data = {\n            \"username\": user_data[\"email\"],\n            \"password\": user_data[\"password\"],  # insert password from parameters\n        }\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status_code\n        assert \"access_token\" not in res.json()\n```\n\n사용자가 `email`과 `password`를 올바르게 보냈을 때 얻게 되는 토큰으로 부터, **`fastapi_users`** 를 이용해서 불러온 유저 레코드가 `test_user`와 일치하는지 확인한다.\n\n여기서 로그인의 경우 `json` 파라미터가 아닌 `data` 파라미터로 데이터를 전송하고, `content-type` 헤더로 `application/x-www-form-urlencoded`를 가지고 있어야 한다는 점에 유의한다.\n\n### 로그인 `api` 작성\n\n토큰 발행 api가 로그인 api이므로, 따로 작성할 필요가 없다.\n만약 400에러가 아닌 401에러를 반환하고 싶다면, 이전 챕터처럼 직접 작성하면 된다.\n\n### 인증 `Depends` 생성\n\n이제 토큰을 발급받은 경우에만 사용이 가능한 api에 대한 인증 절차를 정의해야한다. **`fastapi`** 에서는 이러한 기능은 `Depends`를 사용해서 생성할 수 있다. 또한, **`fastapi-users`** 에서 관련된 함수를 이미 만들어서 제공하고 있다. 우선 테스트 코드부터 작성한다.\n\n```python\n# backend/tests/conftest.py\nfrom app.services.authentication import create_strategy\nfrom sqlmodel import select\n\n(...)\n\n@pytest.fixture\nasync def authorized_client(\n    client: AsyncClient, test_user: user.user_model\n) -> AsyncClient:\n    from app.core import config\n\n    strategy = create_strategy()\n    access_token = await strategy.write_token(user=test_user)  # type: ignore\n\n    client.headers[\"Authorization\"] = f\"{config.JWT_TOKEN_PREFIX} {access_token}\"\n    return client\n```\n\n방금 작성한 `authorized_client`를 이용해서 인증이 필요한 라우터에 접근이 가능하다.\n\n> 쓰다보니 `user.user`와 `user.user_model`이 따로 있는게 너무 불편한데, 언제 한번 합치는 시도를 해봐야 할듯. `AsyncSession` 관련해서도 언제한번 해결을 해야할 것 같고..\n\n```python\n# backend/tests/test_users.py\n(...)\n\nclass TestUserMe:\n    api_name = \"users:get-current-user\"\n\n    async def test_authenticated_user_can_retrieve_own_data(\n        self,\n        app: FastAPI,\n        authorized_client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await authorized_client.get(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_200_OK\n        res_dict: dict = res.json()\n        res_dict[\"hashed_password\"] = \"testpassword@1\"\n        read_user = user.user_model.validate(res_dict)\n        assert read_user.email == test_user.email\n        assert read_user.name == test_user.name\n        assert read_user.id == test_user.id\n\n    async def test_user_cannot_access_own_data_if_not_authenticated(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await client.get(app.url_path_for(\"users:get-current-user\"))\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n\n    @pytest.mark.parametrize(\n        \"jwt_prefix\",\n        (\n            (\"\",),\n            (\"value\",),\n            (\"Token\",),\n            (\"JWT\",),\n            (\"Swearer\",),\n        ),\n    )\n    async def test_user_cannot_access_own_data_with_incorrect_jwt_prefix(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        jwt_prefix: str,\n    ) -> None:\n        token = await strategy.write_token(test_user)\n        res = await client.get(\n            app.url_path_for(\"users:get-current-user\"),\n            headers={\"Authorization\": f\"{jwt_prefix} {token}\"},\n        )\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n```\n\n위 테스트를 통과할 수 있는 api를 작성한다.\n\n```python\nfrom fastapi import Depends\n\n(...)\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\n\n(...)\n\n@router.get(\"/me\", response_model=user.user_read, name=\"users:get-current-user\")\nasync def get_currently_authenticated_user(\n    current_user: user.user = Depends(get_current_user),\n) -> user.user_model:\n    return current_user.to_model()\n```\n\n`optional=False, active=True, verified=False, superuser=False`으로 값을 지정했기에, 해당 함수는 일치하는 유저가 없거나 `is_active` 값이 `False`이면 에러(401)을 반환한다.\n\n테스트 통과도 잘되고, **`swagger`** 에서도 확인이 간단한 api가 생성됐다. 유저 인증 관련해서는 사실상 이게 끝이다. 코드를 조금 더 정리할 수는 있지만 핵심은 비슷할 것이다.\n\n다음 챕터에서는 유저 프로필을 설정한다.\n그 전에 앞에서 언급한 유저 모델과 관련된 수정을 진행할 수도 있다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","data":{"title":"fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","date":"2022-05-06T06:26:51.932+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}}]},"__N_SSG":true}