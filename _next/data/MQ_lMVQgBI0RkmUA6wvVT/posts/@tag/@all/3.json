{"pageProps":{"tag":"@all","page":3,"max_page":6,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## 시작하기 전 변경사항\n\n이전 챕터에서 밝힌 것 처럼, 다소 난잡하다고 생각되는 부분 몇가지를 수정하자. 지금 수정한 부분이 나중에 원 예제에서 다른 방향으로 수정될 수도 있지만, 그때 가서 생각하자.\n\n> ### backend/app/core/config.py\n>\n> $\\rightarrow$ 1개 설정 변수 생성\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token\"\n```\n\n> ### backend/app/db/engine.py\n\n```python\nfrom ..core.config import DATABASE_URL\n```\n\n$\\rightarrow$ `core.config` 에서 값을 불러오는 방식으로\n\n```python\nfrom ..core import config\n```\n\n> ### backend/app/models/user.py\n\n```python\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n>\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n$\\rightarrow$ `unique=True`대신 `index=True`로 변경\n\n```python경\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n>\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n> ### backend/app/services/authentication.py\n\n```python\nfrom ..core.config import SECRET_KEY\n```\n\n$\\rightarrow$ `core.config` 에서 값을 불러오는 방식으로\n\n```python\nfrom ..core import config\n```\n\n---\n\n```python\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n```\n\n$\\rightarrow$ `models.user` 에서 모델을 불러오는 방식으로\n\n```python\nfrom ..models import user\n```\n\n---\n\n```python\nfrom pydantic import BaseModel\n>\n(...)\n>\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n>\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n>\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n```\n\n$\\rightarrow$ 새로 정의\n\n---\n\n```python\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n```\n\n$\\rightarrow$ `config.TOKEN_PREFIX` 설정 변수 참조\n\n```python\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n```\n\n---\n\n```python\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n>\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+<>@\\#$%&\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n>\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -> None:\n        if len(password) < self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) > self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n>\n        for pattern in self.re_password_deny_list:\n            if pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n>\n        for pattern in self.re_password_need_list:\n            if not pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n```\n\n$\\rightarrow$ 비밀번호 유효성 검사 로직 추가\n\n---\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n```\n\n$\\rightarrow$ 원래는 삭제하려 했으나, 특정 기능 추가 후 사용. 의존성이 마음에 들지 않지만, 사실상 설정용 객체라 일단 무시.\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n>\n    @property\n    def backends(self) -> Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n>\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n>\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n---\n\n끝으로, **`fastapi-users`** 의 각 클래스가 제네릭인 것을 확인해서, 이전에 정의한 유저 모델을 이용해서 타입 힌트를 추가했다. 이하 스크립트 전문\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\nfrom typing import AsyncGenerator, Sequence\n>\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom pydantic import BaseModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n>\nfrom ..core import config\nfrom ..db.session import get_session\nfrom ..models import user\n>\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n>\n>\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n>\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n>\n>\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n>\n>\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n>\n>\ndef create_strategy() -> Strategy[user.user_create, user.user]:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n>\n>\ndef create_backend() -> list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n>\n>\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n>\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n>\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n>\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n>\n>\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -> AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n>\n>\ndef create_fastapi_users(\n    *backends: AuthenticationBackend[user.user_create, user.user],\n) -> FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user.user_base,\n        user_create_model=user.user_create,\n        user_update_model=user.user_update,\n        user_db_model=user.user,\n    )\n>\n>\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n>\n    @property\n    def backends(self) -> Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n>\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n>\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n> ### backend/app/services/token.py\n\n#### 위치 변경\n\n`backend/app/services/token.py`\n$\\rightarrow$ `backend/app/api/routes/token.py`\n\n---\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ 클래스 이름 변경에 따른 수정\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import HTTP_400_BAD_REQUEST\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```pyhon\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom fastapi_users import models\n>\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -> dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n>\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n$\\rightarrow$ 최상위 엔드포인트 사용 + `user_manager_type`, `strategy_type`, `token_model` 사용\n\n```python\nfrom ...services.authentication import strategy_type, token_model, user_manager_type\n>\n(...)\n>\n@router.post(\"\", name=\"users:create-token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n    strategy: strategy_type = fastapi_user.strategy_depends(),\n) -> token_model:\n    get_user = await user_manager.authenticate(credentials)\n    if get_user is None or not get_user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not get_user.is_verified:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n>\n    token = await strategy.write_token(get_user)\n    return token_model.from_token(token)\n```\n\n> ### backend/app/api/routes/cleanings.py\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ 클래스 이름 변경에 따른 수정\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```python\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom ...models.cleaning import (\n    cleaning_create,\n    cleaning_public,\n    cleaning_update,\n    cleanings,\n)\n```\n\n$\\rightarrow$ `models.cleaning` 에서 모델을 불러오는 방식으로\n\n```python\nfrom ...models import cleaning\n```\n\n> ### backend/app/api/routes/\\_\\_init\\_\\_.py\n\n```python\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n$\\rightarrow$ `auth` 대신 `token`으로 단일화\n\n```python\nrouter.include_router(token_router, prefix=\"/token\", tags=[\"token\"])\n```\n\n> ### backend/tests/conftest.py\n\n```python\n@pytest.fixture(\n    params=[pytest.param((\"asyncio\", {\"use_uvloop\": True}), id=\"asyncio+uvloop\")]\n)\ndef anyio_backend(request):\n    return request.param\n```\n\n$\\rightarrow$ **`pytest`** 백엔드로 **`anyio+uvloop`** 를 사용하기 위한 설정 추가\n\n> ### backend/tests/test_cleanings.py\n\n```python\npytestmark = pytest.mark.asyncio\n```\n\n$\\rightarrow$ **`pytest`** 백엔드로 **`anyio+uvloop`** 를 사용하기 위한 설정 추가\n\n```python\npytestmark = pytest.mark.anyio\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```python\nfrom fastapi import status\n```\n\n> ### 신규 생성) backend/pytest.ini\n\n```bash\n❯ touch backend/pytest.ini\n```\n\n```yaml\n[pytest]\nfilterwarnings =\n    ignore::sqlalchemy.exc.SAWarning\n```\n\n$\\rightarrow$ **`sqlalchemy`** 에서 보내는 경고를 **`pytest`** 에서 출력하지 않도록 설정\n\n위 수정에서 확인할 수 있듯이, **`pytest`** 백엔드로 **`anyio`** 를 쓰기 때문에, **`pytest-asyncio`** 는 이제 필요가 없으므로 제거한다.\n\n```bash\n❯ poetry remove --dev pytest-asyncio\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ docker-compose build\n```\n\n깜박하고 넘어간 경우가 있을텐데, 테스트 코드를 실행해보면 금방 수정할 수 있다.\n\n## `TDD` 방법론에 따른 유저 생성 `api` 만들기\n\n### 라우터 존재 확인\n\n원 예제의 **jeffastor**는 회원가입 api에 요청을 보내고 에러 코드를 확인하는 방식으로 만들었지만, 최근에 **RESTful** api 생성과 관련해서 [좋은 글](https://sanghaklee.tistory.com/57)을 확인했기에, **OPTIONS** api로 대신하고자 한다.\n\n```bash\n❯ touch backend/tests/test_users.py\n```\n\n```python\n# backend/tests/test_users.py\nimport pytest\nfrom fastapi import FastAPI, status\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.anyio\n\n\nclass TestUserRoutes:\n    api_name = \"users:get-allowed-methods\"\n\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.options(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_204_NO_CONTENT\n        assert not res.content\n        headers = res.headers\n        assert \"Allow\" in headers\n        allowed_methods_str = headers[\"Allow\"]\n        allowed_methods = {\n            method_str.strip().lower() for method_str in allowed_methods_str.split(\",\")\n        }\n        assert len(allowed_methods) > 0\n        for method_str in (\"post\",):\n            assert method_str in allowed_methods\n```\n\n테스트를 실행해보면 당연히 에러가 나온다.\n\n```bash\nroot@90b2a10bcb6d:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py F                                                                                 [100%]\n\n================================================= FAILURES ==================================================\n_____________________________ TestUserRoutes.test_routes_exist[asyncio+uvloop] ______________________________\ntests/test_users.py:10: in test_routes_exist\n    res = await client.options(app.url_path_for(\"users:get-allowed-methods\"))\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: in url_path_for\n    raise NoMatchFound()\nE   starlette.routing.NoMatchFound\n----------------------------------------- Captured stderr teardown ------------------------------------------\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\n========================================== short test summary info ==========================================\nFAILED tests/test_users.py::TestUserRoutes::test_routes_exist[asyncio+uvloop] - starlette.routing.NoMatchF...\n======================================= 1 failed, 39 passed in 4.52s ========================================\n```\n\n이제 에러를 해결하기 위한 라우터를 생성한다.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter, Response, status\n\nfrom ...services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.options(\"\", name=\"users:get-allowed-methods\")\nasync def get_allowed_user_methods() -> Response:\n    from functools import reduce\n\n    method_sets = [getattr(route, \"methods\") for route in router.routes]\n    all_methods = reduce(lambda left, right: left | right, method_sets, set())\n    all_methods_str = \", \".join(all_methods)\n\n    return Response(\n        status_code=status.HTTP_204_NO_CONTENT, headers={\"Allow\": all_methods_str}\n    )\n\n\n@router.post(\"\")\nasync def post_temp():\n    ...\n```\n\n임시로 가짜 **POST** api를 정의했기에, 테스트를 실행해도 에러가 발생하지 않는다.\n\n```bash\nroot@96deef95611e:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py .                                                                                 [100%]\n\n============================================ 40 passed in 4.03s =============================================\n```\n\n### 회원가입\n\n우선, 기존에 작성했던 유저 모델에 대해 이메일로 검색할 수 있는 메소드를 하나 생성한다. 관련해서 종종 쓰이기 때문.\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar, cast\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlmodel.sql.expression import Select\n\n(...)\n\n_T = TypeVar(\"_T\", bound=\"user_model\")\n\n(...)\n\nclass user(user_base, models.BaseUserDB):\n    def to_model(self) -> \"user_model\":\n        return user_model.validate(self)\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: AsyncSession, email: str\n    ) -> _T | None:\n        is_user_cur = await session.exec(\n            cast(Select[_T], select(cls).where(cls.email == email))\n        )\n        return is_user_cur.first()\n```\n\n> 아직 **`sqlmodel`** 의 `async` 지원이 부족해서, `typing.cast`를 이용해서 `Select` 타입으로 강제해서 사용했다.\n\n> `user`와 `user_model`을 하나로 합칠 수 있을 것 같은데, 이건 나중에 시간내서 확인해볼 생각.\n\n이제 **`fastapi-users`** 를 사용할 때가 왔다. 우선 테스트 코드부터 작성한다.\n\n```python\n# backend/tests/test_users.py\nfrom app.models import user\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\nclass TestUserRegistration:\n    api_name = \"users:register-new-user\"\n\n    async def test_users_can_register_successfully(\n        self, app: FastAPI, client: AsyncClient, engine: AsyncEngine\n    ) -> None:\n        new_user = {\n            \"email\": \"shakira@shakira.io\",\n            \"name\": \"shakirashakira\",\n            \"password\": \"chantaje@1\",\n        }\n        # make sure user doesn't exist yet\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is None\n        # send post request to create user and ensure it is successful\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status.HTTP_201_CREATED\n        # ensure that the user now exists in the db\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is not None\n        assert is_user.email == new_user[\"email\"]\n        assert is_user.name == new_user[\"name\"]\n        # check that the user returned in the response is equal to the user in the database\n        created_user = user.user_model.validate(\n            res.json() | {\"hashed_password\": \"whatever\"}\n        )\n        exclude_attr_set = user.user_model.datetime_attrs | {\"id\", \"hashed_password\"}\n        assert created_user.dict(exclude=exclude_attr_set) == is_user.dict(\n            exclude=exclude_attr_set\n        )\n\n    @pytest.mark.parametrize(\n        \"attr, value, status_code\",\n        (\n            (\"email\", \"shakira@shakira.io\", 400),\n            (\"name\", \"sha\", 422),\n            (\"name\", \"shafasdfsdwerewfsdfxcvxcvxcv\", 422),\n            (\"email\", \"invalid_email@one@two.io\", 422),\n            (\"password\", \"short\", 422),\n            (\n                \"password\",\n                (\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                ),\n                422,\n            ),\n            (\"password\", \"pattern@\", 422),\n            (\"name\", \"shakira@#$%^<>\", 422),\n            (\"name\", \"ab\", 422),\n        ),\n    )\n    async def test_user_registration_fails_when_credentials_are_taken(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        attr: str,\n        value: str,\n        status_code: int,\n    ) -> None:\n        new_user = {\n            \"email\": \"nottaken@email.io\",\n            \"name\": \"not_taken_username\",\n            \"password\": \"freepassword@1\",\n        }\n        new_user[attr] = value\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status_code\n```\n\n이제 위 테스트 코드를 통과할 수 있을 것 같은 api를 생성한다.\n\n```python\nimport re\n\nimport orjson\nfrom fastapi import Body, HTTPException, Request\nfrom fastapi_users.manager import InvalidPasswordException, UserAlreadyExists\nfrom pydantic import ValidationError\n\nfrom ...models import user\nfrom ...services.authentication import user_manager_type\n\n(...)\n\nre_deny_name = re.compile(r\"[^a-zA-Z0-9_-]\")\n\n(...)\n\n@router.post(\n    \"\",\n    name=\"users:register-new-user\",\n    response_model=user.user_read,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def register_new_user(\n    request: Request,\n    new_user: user.user_create = Body(..., embed=True),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n):\n    if re_deny_name.search(new_user.name):\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=(\n                \"The name can only contain the following characters: \"\n                f\"{re_deny_name.pattern.replace('^','')}\"\n            ),\n        )\n\n    try:\n        return await user_manager.create(new_user, safe=True, request=request)\n    except UserAlreadyExists as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=(\n                \"That email is already taken. \"\n                \"Login with that email or register with another one.\"\n            ),\n        )\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=orjson.loads(exc.json()),\n        )\n    except InvalidPasswordException as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=exc.reason,\n        )\n\n```\n\n> 따로 적지는 않았지만, **TDD** 방법론을 충실히 이행하면서 만들어진 테스트 코드와 api다.\n\n위 코드를 기반으로 테스트를 실행해보면, 모두 정상적으로 실행되는 것을 확인할 수 있다.\n\n### 토큰\n\n**`fastapi-users`** 덕분에 토큰 등에 대한 별다른 작업 없이 깔끔하게 끝났지만, 원 예제에서는 토큰과 관련된 몇가지 작업이 진행된다. 해당 과정 중 해보면 좋을 것 같은 부분만 따라서 진행한다.\n\n#### 토큰 관련 설정 수정 및 추가\n\n초기에 대충 작성해놨던 `SECRET_KEY` 등의 값을 지정해준다. 이 값을 직접 작성하기 보다는 그냥 터미널 명령어로 생성된 임의의 값을 사용하는 것이 좋다.\n\n```bash\n❯ openssl rand -hex 32\n```\n\n이제 이 값을 `.env` 파일에 추가하면 된다. 이 외에도 몇몇 값을 추가로 더 설정하는데 각 값은 다음과 같다.\n\n> `ACCESS_TOKEN_EXPIRE_SECONDS`: 토큰의 만료시간(초)\n> `JWT_ALGORITHM`: 토큰 암호화 알고리즘\n> `JWT_AUDIENCE`: 토큰 발급/수신 대상\n> `JWT_TOKEN_PREFIX`: 토큰 타입?(얘는 확실하지 않음)\n\n이제 `config.py`가 위 값을 잘 읽을 수 있게 수정한다.\n\n```python\n# backend/app/core/config.py\n(...)\n\nACCESS_TOKEN_EXPIRE_MINUTES = config(\n    \"ACCESS_TOKEN_EXPIRE_MINUTES\", cast=int, default=60 * 60\n)\nJWT_ALGORITHM = config(\"JWT_ALGORITHM\", cast=str, default=\"HS256\")\nJWT_AUDIENCE = config(\"JWT_AUDIENCE\", cast=str, default=\"phresh:auth\")\nJWT_TOKEN_PREFIX = config(\"JWT_TOKEN_PREFIX\", cast=str, default=\"Bearer\")\n\n(...)\n```\n\n그리고 이 값을 잘 참조할 수 있도록 수정한다.\n\n```python\n# backend/app/services/authentication.py\n(...)\n\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = config.JWT_TOKEN_PREFIX\n\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n\n(...)\n\ndef create_strategy() -> Strategy[user.user_create, user.user]:\n    return JWTStrategy(\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n(...)\n```\n\n테스트 코드에서 사용할 `fixture`를 정의한다. 중복 이메일을 허용하지 않기에 주의해서 작성한다.\n\n```python\n# backend/tests/conftest.py\nfrom app.models import user\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_user(engine: AsyncEngine) -> user.user_model:\n    new_user = user.user_create.parse_obj(\n        dict(\n            email=\"lebron@james.io\",\n            name=\"lebronjames\",\n            password=\"heatcavslakers@1\",\n        )\n    )\n\n    async with AsyncSession(engine, autocommit=False) as session:\n        db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n        manager = UserManager(db)\n\n        try:\n            new_user_db = await manager.get_by_email(new_user.email)\n        except UserNotExists:\n            new_user_db = await manager.create(new_user, safe=True)\n\n    return new_user_db.to_model()\n```\n\n이제 이 `fixture`를 이용해서 토큰을 발급받고, 검증하는 테스트 코드를 작성한다.\n\n> 2022.05.06. 아래 테스트 코드는 사실상 무의미하기에, 없어도 좋다. **TDD**에 익숙하지 않은 것도 있고, 원 예제의 내용과 다른 방식으로 api를 생성하다보니 헷갈려서 잘못 작성한 것 같다. 다음 챕터의 로그인 테스트 코드를 확인하자.\n\n```python\nclass TestAuthTokens:\n    api_name = \"users:create-token\"\n\n    async def test_can_create_access_token_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -> None:\n        access_token = await strategy.write_token(user=test_user)\n        creds = decode_jwt(\n            access_token,\n            str(config.SECRET_KEY),\n            [config.JWT_AUDIENCE],\n            [config.JWT_ALGORITHM],\n        )\n\n        assert creds.get(\"user_id\") is not None\n        user_id = creds[\"user_id\"]\n        assert config.JWT_AUDIENCE in creds[\"aud\"]\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            user_model = await session.get(user.user_model, user_id)\n        assert user_model is not None\n\n        assert user_model.name == test_user.name\n\n    async def test_token_missing_user_is_invalid(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(\n            url=app.url_path_for(self.api_name),\n            data={\"username\": \"unknown\", \"password\": \"testpassword@1\"},\n        )\n        assert res.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n```\n\n원 예제는 테스트 코드가 조금 더 풍부하지만, **`fastapi-users`** 를 사용중이기에, 불필요한 과정이라 생각됐다. 위 테스트 코드에서 `strategy`를 이용하여 직접 `access_token`을 생성해보기도 하고 복호화해보기도 하며, `access_token`로 부터 유저를 불러오기도 한다. 끝으로 이러한 과정이 진행되는 api를 호출해보기도 한다.\n\n테스트는 문제없이 잘 진행됐다.\n\n다음 챕터에서는 지금까지 만든 유저 api로 로그인 등을 시도한다. 참고로, 현재 선택한 전략으로는, 서버가 이미 발급한 토큰에 대해 처리가 불가능하므로, 로그아웃 기능을 생성할 수 없다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","data":{"title":"fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","date":"2022-05-05T06:13:07.421+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `cleanings`, `users` 모델 생성 및 수정\n\n시작부터 마이그레이션을 진행하길래 어떤건가 했더니, 이전에 작성했던 `cleanings` 테이블에 시간 속성(생성, 수정)을 sql 서버에서 자동으로 처리하도록 하는 트리거를 생성하는 과정이 있었다. sql 서버에서 직접 처리하는게 가장 간단한 방법이라고 한다. 일단 무시.\n\n이것과는 별개로, 이전에 마이그레이션 관련 코드 작성시 문제가 있는 형태로 작성한 것 같아서, 관련해서 조금 수정한다.\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -> None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\n이제 원 예제와 같이, 다운그레이드 후, 시간 속성부터 추가한 다음, 유저 관련 테이블을 설정하고 업그레이드를 실시한다. 원 예제와 순서를 맞춰가기 위해 약간 꼬인 느낌이 있는데, 지금 작성하는 유저 테이블은 **`fastapi-users`** 에서 작성하는 모델 형태를 따라간다.\n\n```bash\nroot@c62cf3d05043:/backend# alembic downgrade base\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running downgrade f721febf752b -> , create account table\n```\n\n### 시간 속성 관련 코어 모델 추가\n\n```python\n# backend/app/models/core.py\nfrom datetime import datetime\n\n(...)\n\n_D = TypeVar(\"_D\", bound=\"datetime_model\")\n\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -> _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def attrs(cls) -> set[str]:\n        return set(cls.__fields__.keys())\n```\n\n### 시간 속성 추가로 인한 기존 모델 변경점 대응 수정\n\n> 아래 내용은 단순히 시간 속성 추가로 인해 코드가 너무 나열돼있어서 접어놓고 싶지만 velog가 해당 기능을 지원하지 않는다.. velog에서 자동 생성된 목차를 선택해서 다음 항목으로 넘어갈 수 있다.\n\n```python\n# backend/app/models/cleaning.py\n(...)\n\nfrom .core import base_model, datetime_model, id_model\n\n(...)\n\nclass cleanings(id_model, datetime_model, cleaning_base, table=True):\n    name: str = Field(index=True)\n    cleaning_type: cleaning_type_enum = Field(\n        cleaning_type_enum.spot_clean,\n        sa_column_kwargs={\"server_default\": cleaning_type_enum.spot_clean},\n    )\n    price: price_decimal_type\n\n(...)\n```\n\n```python\n# backend/tests/test_cleaning.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\nimport orjson\nimport pytest\nfrom app.models.cleaning import cleaning_create, cleanings\nfrom app.models.core import datetime_model\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n# decorate all tests with @pytest.mark.asyncio\npytestmark = pytest.mark.asyncio\n\n\n@pytest.fixture\ndef new_cleaning():\n    return cleaning_create.parse_obj(\n        dict(\n            name=\"test cleaning\",\n            description=\"test description\",\n            price=0.00,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n\n\nclass TestCleaningsRoutes:\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCreateCleaning:\n    async def test_valid_input_creates_cleaning(\n        self, app: FastAPI, client: AsyncClient, new_cleaning: cleaning_create\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": orjson.loads(new_cleaning.json())},\n        )\n        assert res.status_code == HTTP_201_CREATED\n\n        created_cleaning = cleaning_create(**res.json())\n        assert created_cleaning == new_cleaning\n\n    @pytest.mark.parametrize(\n        \"invalid_payload, status_code\",\n        (\n            (None, 422),\n            ({}, 422),\n            ({\"name\": \"test_name\"}, 422),\n            ({\"price\": 10.00}, 422),\n            ({\"name\": \"test_name\", \"description\": \"test\"}, 422),\n        ),\n    )\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient, invalid_payload: dict, status_code: int\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": invalid_payload},\n        )\n        assert res.status_code == status_code\n\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning.dict(exclude=datetime_model.attrs) == test_cleaning.dict(\n            exclude=datetime_model.attrs\n        )\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [\n            cleanings.validate(l).dict(exclude=datetime_model.attrs) for l in json\n        ]\n        assert test_cleaning.dict(exclude=datetime_model.attrs) in all_cleanings\n\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(test_cleaning.id),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -> None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -> None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -> None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n    from app.models.core import datetime_model\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\n이렇게 수정하면 추가, 수정 시간 속성을 문제없이 사용할 수 있다..\n큰 문제가 없다면 그냥 트리거를 이용하자.\n\n### `users` 모델 생성\n\n```bash\n❯ poetry add 'fastapi-users[sqlalchemy2]'\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ touch backend/app/models/user.py\n❯ docker-compose up --build\n```\n\n원 예제에서 **`JWT`** 를 사용하기에 따라간다.\n\n```python\n# backend/app/models/user.py\nfrom uuid import uuid4\n\nfrom fastapi_users import models\nfrom pydantic import UUID4, EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field\n\nfrom .core import base_model, datetime_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\nclass user_base(models.BaseUser, datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(models.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(models.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_read(user_base):\n    ...\n\n\nclass user(user_base, models.BaseUserDB):\n    ...\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n위 스크립트에서 정의한 모델은, **`pydantic`** 의 `BaseModel`을 상속받는, **`fastapi-users`** 에서 정의된 모델을 상속받아서 정의한다. 기본적으로 가지고 있는 속성은 다음과 같다.\n\n> `id` : `UUID`로 임의 생성\n> `email`: `xxx@yyy.zz`의 형태로 구성된 문자열\n> `is_active`: 해당 유저 레코드가 활성화된 상태인지 확인\n> `is_superuser`: 해당 유저가 관리자인지 확인\n> `is_verified`: 선택적으로 사용 가능한, 해당 유저에 대한 추가적인 검증 통과 여부를 확인. 흔히 이메일로 검증을 진행함.\n> `password`: 해당 유저가 로그인시 사용하는 비밀번호로, 실제 데이터베이스에는 `hashed_password` 속성으로 암호화 후 저장된다.\n\n추가적으로 필요한 속성이 있다던가, 제약사항이 있다면 위 스크립트와 같이 모델에 새로 정의를 해도 좋고, 이후 정의할 `UserManager` 클래스의 `on_after_register` 등의 메소드에 제약사항을 적용해도 된다.\n\n그리고 추가된 모델을 마이그레이션 설정에 추가한다.\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n\"\"\"create account table\n\nRevision ID: f721febf752b\nRevises:\nCreate Date: 2022-04-27 17:21:25.945460\n\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nimport sqlalchemy as sa\nfrom alembic import op\n\nsys.path.append(Path(__file__).resolve().parents[4].as_posix())\nfrom app.models.cleaning import cleanings\nfrom app.models.core import datetime_model\nfrom app.models.user import user_model\n\n# revision identifiers, used by Alembic.\nrevision = \"f721febf752b\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ncleanings_table = cleanings.get_table()\nusers_table = user_model.get_table()\n\n\ndef create_cleanings_table() -> None:\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        cleanings_table.name,\n        *[col for col in cleanings_table.columns if col.name in col_names]\n    )\n\n\ndef create_user_table() -> None:\n    col_names = {\n        \"id\",\n        \"name\",\n        \"hashed_password\",\n        \"email\",\n        \"is_active\",\n        \"is_superuser\",\n        \"is_verified\",\n    }.union(datetime_model.attrs)\n\n    op.create_table(\n        users_table.name, *[col for col in users_table.columns if col.name in col_names]\n    )\n\n\ndef upgrade():\n    create_cleanings_table()\n    create_user_table()\n\n\ndef downgrade():\n    op.drop_table(cleanings_table.name)\n    op.drop_table(users_table.name)\n```\n\n이제 드디어 마이그레이션을 할 준비가 끝났다.\n\n```bash\nroot@77f86a971288:/backend# alembic upgrade head\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -> f721febf752b, create account table\n```\n\n## `FastAPI-Users`\n\n원 예제에서는 이제 테스트 코드를 작성한다. 하지만 `fastapi-users`를 사용하기 위해서, 사전 작업이 몇가지 필요한데, 지금 진행하는 작업이 다음 챕터나 그 다음 챕터에 나오는 내용과 비슷할 수 있다..\n\n### 간단한 설명\n\n**`fastapi-users`** 의 설명에 따르면, **`fastapi-users`** 는 `Transport`와 `Strategy` 이 두가지를 조합해서 사용하는 방식이다. 지금 이 예제는 **`Bearer`** 와 **`JWT`** 를 조합해서 쓰는 방식이라고 생각할 수 있다.\n\n> - **`Bearer`** : `header`에 토큰을 저장\n> - **`JWT`** : `JSON`형태의 토큰을 암호화 하여 저장(토큰 발행 이후 서버에서 무효화 불가능). 자세한 설명은 [여기](https://jwt.io/introduction)에서 확인할 수 있다.\n\n### 인증 백엔드 설정\n\n인증과 관련한 모듈을 저장할 경로를 생성하고 백엔드부터 앞에서 간략하게 설명한 인증 백엔드부터 생성한다.\n\n```bash\n❯ mkdir backend/app/services\n❯ touch backend/app/services/__init__.py backend/app/services/authentication.py\n```\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ..core.config import SECRET_KEY\nfrom ..db.session import get_session\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n\n\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user, session, user_model)  # type: ignore\n\n\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n\n\ndef create_strategy() -> Strategy:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n\n\ndef create_backend() -> list[AuthenticationBackend]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n\n\nclass UserManager(BaseUserManager[user_create, user]):\n    user_db_model = user\n    reset_password_token_secret = str(SECRET_KEY)\n    verification_token_secret = str(SECRET_KEY)\n\n    async def on_after_register(self, user: user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(user_db=Depends(get_user_db)):\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(*backends: AuthenticationBackend) -> FastAPIUsers:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user_base,\n        user_create_model=user_create,\n        user_update_model=user_update,\n        user_db_model=user,\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n\n    @classmethod\n    def init(cls) -> \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n\n```\n\n뭔가 많이 적었지만 실제로 직접 작성했다고 할만한건 데이터클래스 **`fastapi_user`** 정도 밖에 없다. 전부 **`fastapi-users`** 레퍼런스에 있는 내용이다.\n\n`UserManager` 와 `AuthenticationBackend` 인스턴스는 이후 계정과 관련된 작업을 할때 자주 사용된다.\n\n### 토큰 `api` 생성\n\n이제 토큰을 생성하는 api를 생성한다. 이 api의 엔드포인트는 `Transport`를 생성할 때 사용한 `tokenUrl`의 값과 일치해야한다.\n\n```python\n# backend/app/api/routes/token.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi_users import models\nfrom fastapi_users.authentication import Strategy\nfrom fastapi_users.manager import BaseUserManager\nfrom fastapi_users.router import ErrorCode\nfrom starlette.status import HTTP_400_BAD_REQUEST\n\nfrom .authentication import fastapi_user as fastapi_user_class\nfrom .authentication import get_user_manager\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -> dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n### 인증 백엔드 확인용 임시 `api` 생성\n\n이어서 인증 백엔드 설정이 잘 됐는지 확인해볼 임시 라우터를 생성한다. 실제로 사용할 생각은 아니고, 말 그대로 임시 확인용이다.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter\n\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\nrouter.include_router(\n    fastapi_user.users.get_auth_router(fastapi_user.backends[0]), prefix=\"/auth\"\n)\nrouter.include_router(fastapi_user.users.get_register_router(), prefix=\"/auth\")\nrouter.include_router(fastapi_user.users.get_verify_router(), prefix=\"/auth\")\n```\n\n```python\n# backend/api/routes/__init__.py\nfrom fastapi import APIRouter\n\nfrom .cleanings import router as cleanings_router\nfrom .token import router as token_router\nfrom .users import router as users_router\n\nrouter = APIRouter()\n\nrouter.include_router(cleanings_router, prefix=\"/cleanings\", tags=[\"cleanings\"])\nrouter.include_router(users_router, prefix=\"/users\", tags=[\"users\"])\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n이제 [http://localhost:8000/docs](http://localhost:8000/docs)에서 확인해보면 **`fastapi-users`** 에서 설정한 내용을 바탕으로 생성해놓은 유저 관련 api를 사용할 수 있다. 또한, 로그인시 생성되는 토큰을 헤더에 추가하면 **`swagger`** 에서 로그인을 시도해볼 수 있다.\n\n다음은 이번에 작성한 내용을 좀 더 다듬고, 이전까지 했던 방식으로 **TDD** 방법론에 따라 api를 생성할 생각이다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","data":{"title":"fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","date":"2022-05-03T01:35:06.494+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n아래 문제로 인해 해당 챕터를 진행하면서 이전 챕터의 글을 포함해서 수정하다 보니 제대로 수정이 된건지 아닌지 확인하기가 어렵다..\n어쩌면 [이곳](https://github.com/phi-friday/jeffastor_tutor)에서 코드를 확인하는게 도움이 될 수 있다.\n\n특히 이 챕터의 테스트 코드에 적용된 `Decimal`이나 `f-string`도 원래는 **TDD** 과정 중에서 적용한 것이지만, 이미 글 쓰는 흐름이 다 꼬여서 생략했다.\n\n---\n\n## `SQLModel`의 **validataion** 관련 해결\n\n[링크](https://velog.io/@phi0friday/sqlmodel-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-validation)와 같은 이유로 인해, **`sqlmodel`** 로 생성한 모델에 대한 전반적인 수정이 필요하므로, 아래와 같이 수정을 진행했다.\n\n```python\n# backend/app/models/core.py\nfrom typing import Any, TypeVar, cast\n\nfrom sqlmodel import Field, SQLModel, Table\n\n_T = TypeVar(\"_T\", bound=SQLModel)\n\n\nclass fix_return_type_model(SQLModel):\n    \"\"\"\n    sqlmodel에서 parse_obj 리턴값 정상적으로 수정하기 전까지 사용\n    +\n    validate 또한 같은 문제 있음\n    \"\"\"\n\n    @classmethod\n    def parse_obj(cls: type[_T], obj: Any, update: dict[str, Any] | None = None) -> _T:\n        return cast(_T, super().parse_obj(obj, update))\n\n    @classmethod\n    def validate(cls: type[_T], value: Any) -> _T:\n        return cast(_T, super().validate(value))\n\n\nclass base_model(fix_return_type_model):\n    @classmethod\n    def get_table(cls) -> Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n\n\nclass id_model(fix_return_type_model):\n    id: int | None = Field(None, primary_key=True)\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\nasync def create_new_cleaning(\n    new_cleaning: cleaning_create = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    # data = cleanings.from_orm(new_cleaning) 으로 해도 가능\n    # exclude_none=True, exclude_unset=True 옵션을 위해 parse_obj 사용\n    # sqlmodel table=True 관련 validation 문제로 인해 validate사용\n    data = cleanings.validate(\n        new_cleaning.dict(\n            exclude_none=True,\n            exclude_unset=True,\n        )\n    )\n    session.add(data)\n    await session.flush()\n    await session.commit()\n    await session.refresh(data)\n\n    return data\n```\n\n```python\n# backend/tests.py\n(...)\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning == test_cleaning\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.validate(l) for l in json]\n        assert test_cleaning in all_cleanings\n```\n\n---\n\n## `RESTful` `CRUD` `api` 생성\n\n**RESTful** 표준에 따라, 다음과 같이 엔드포인트를 생성하고자 한다.\n\n| 엔드포인트     | 메소드 | 설명                               |\n| :------------- | :----- | :--------------------------------- |\n| /cleaning      | POST   | 새로운 cleaning 레코드 생성        |\n| /cleaning/{id} | GET    | id에 해당하는 cleaning 레코드 호출 |\n| /cleaning      | GET    | 전체 cleaning 레코드 호출          |\n| /cleaning/{id} | PATCH  | id에 해당하는 cleaning 레코드 수정 |\n| /cleaning/{id} | PUT    | id에 해당하는 cleaning 레코드 교체 |\n| /cleaning/{id} | DELET  | id에 해당하는 cleaning 레코드 제거 |\n\n이전 챕터에서, 새로운 레코드를 생성하는 것과, 기존의 레코드를 `id`를 이용하여 호출하는, 두개의 엔드포인트를 생성했다. 다른 4가지 또한, **TDD** 방법론에 맞게 작성한다.\n\n> 원 예제에서 **jeffastor**는 **PATCH** api를 작성하지 않고 **PUT** api만 작성했다. 그런데 작동 방식을 보면 **jeffastor**가 작성한 **PUT** api는 **PATCH** api처럼 작동한다. 이와 관련해 약간의 수정이 함께 진행된다.\n\n### `GET` `api`\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]\n        assert test_cleaning in all_cleanings\n        assert test_cleaning in all_cleanings\n```\n\n이제 **`pytest`** 를 **`docker`** 컨테이너 내부에서 실행하면, 다음과 같은 에러를 확인할 수 있다.\n\n```bash\n(...)\n\n================================================= FAILURES ==================================================\n_______________________ TestGetCleaning.test_get_all_cleanings_returns_valid_response _______________________\n\nself = <tests.test_cleanings.TestGetCleaning object at 0x7feb2db9b370>\napp = <fastapi.applications.FastAPI object at 0x7feb2b01fd90>\nclient = <httpx.AsyncClient object at 0x7feb2b01e6e0>\ntest_cleaning = cleanings(name='fake cleaning name', price=Decimal('9.99'), id=3, description='fake cleaning description', cleaning_type='spot_clean')\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n>       res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n\ntests/test_cleanings.py:125:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <fastapi.routing.APIRouter object at 0x7feb2b01d180>, name = 'cleanings:get-all-cleanings'\npath_params = {}, route = <fastapi.routing.APIRoute object at 0x7feb2b045480>\n\n    def url_path_for(self, name: str, **path_params: str) -> URLPath:\n        for route in self.routes:\n            try:\n                return route.url_path_for(name, **path_params)\n            except NoMatchFound:\n                pass\n>       raise NoMatchFound()\nE       starlette.routing.NoMatchFound\n\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: NoMatchFound\n\n(...)\n```\n\n> 현재 설정으로는, `test_cleaning`을 사용할 때 마다 새로운 레코드를 생성하고 있다. 만약 `unique` 설정이 있다면 에러를 발생시킬 것이다. 이 문제는 이후 다룰 것이므로, 지금은 신경쓰지 않아도 된다고 **jeffastor**는 밝힌다.\n\n이제 테스트를 통과할 수 있도록, 라우터를 수정합니다. 정말 연습해보기 위해, 이후 내용은 제대로 읽지 않고 직접 코드를 작성해봤습니다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom typing import cast\nfrom sqlmodel import select\n\n(...)\n\n@router.get(\n    \"\", response_model=list[cleaning_public], name=\"cleanings:get-all-cleanings\"\n)\nasync def get_all_cleanings(\n    session: AsyncSession = Depends(get_session),\n) -> list[cleanings]:\n    # 아직 sqlmodel의 async session은 type hint와 관련해서 제대로 지원하지 않습니다.\n    # 제대로 작성된게 맞는지 확인해보고 싶다면,\n    # session.sync_session에서 type hint 관련해서만 확인해보면 됩니다.\n    #\n    # sync_session = session.sync_session\n    # table = sync_session.exec(select(cleanings))\n    # rows = table.all()\n    table = await session.exec(select(cleanings))  # type: ignore\n    rows = cast(list[cleanings], table.all())\n    return rows\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\n\n(...)\n```\n\n테스트 결과 통과했습니다.\n\n> 원 작성자 **jeffator**의 경우, **TDD**에 대해 익숙해지지 위해 처음에는 `None`을 반환하고, 그 다음에는 빈 리스트 `[]`를 반환하고, 그 다음에는 가짜 레코드 `[{ \"id\": 1, \"name\": \"fake cleaning\", \"price\": 0}]`를 반환하고, 끝으로 세션에 연결해서 레코드를 반환합니다.\n\n### `PUT` `api`...? `PATCH` `api`\n\n다음과 같이 테스트 코드를 추가합니다.\n\n```python\n# backend/tests/test_cleanings.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.put(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n첫번째는 **PUT** api가 의도한대로 작동하는지 확인하고, 두번째는 의도한대로 에러를 반환하는지 확인하는 메소드입니다.\n이제 위 테스트 코드를 통과할 수 있도록 **PUT** 메소드를 작성합니다.\n\n> 다만 위 테스트 코드에서 이해가 되지 않는 부분이 있는데,\n\n```python\n# make sure that no other attributes' values have changed\nfor attr, value in updated_cleaning.dict().items():\n    if attr not in attrs_to_change:\n        assert getattr(test_cleaning, attr) == value\n```\n\n> 이다. 이건 **PATCH** 아닌가? 일단 따라가본다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom pydantic import ValidationError\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    try:\n        cleanings.from_orm(update_cleaning)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n`update_cleaning`이 정상적인 `cleanings` 레코드를 생성할 수 있는지 확인하고, `id`에 해당하는 `cleanings` 레코드를 호출 한 다음, 해당 레코드의 값을 수정하고 커밋했다.\n\n테스트 실행결과 이상하다고 생각했던 부분이 맞았다.\n**`pytest`** 에 익숙하지 않아 처음에 알아보지 못한 문제인데,\n\n```python\nattrs_to_change = ['cleaning_type']\nvalues = ['full_clean']\n```\n\n다음과 같이 변수가 정의된다..\n따라서, 위 예제를 모두 **PUT**에서 **PATCH**로 변경 후 다시 진행한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.parse_obj(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n기존에 작성한 **PUT** api는 제거하지 않고 놔둔다. 마지막에 다시 사용할 것이다.\n\n테스트 결과 모두 정상적으로 통과했다.\n\n### `DELETE` `api`\n\n이어서 **DELETE** 테스트 코드와 api를 생성한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -> None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -> None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.delete(\"/{id}/\", response_model=int, name=\"cleanings:delete-cleaning-by-id\")\nasync def delete_cleaning_by_id(\n    id: int = Path(..., ge=1, title=\"The ID of the cleaning to delete.\"),\n    session: AsyncSession = Depends(get_session),\n) -> int:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    await session.delete(cleaning)\n    await session.flush()\n    await session.commit()\n\n    return id\n```\n\n테스트도 정상적으로 통과한다.\n\n```bash\ntests/test_cleanings.py::TestDeleteCleaning::test_can_delete_cleaning_successfully PASSED             [ 86%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[500-404] PASSED [ 90%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[0-422] PASSED [ 93%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[-1-422] PASSED [ 96%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[None-422] PASSED [100%]\n```\n\n> **DELETE**와 같은 api는 `status_code=204`와 함께 `contents`가 없는 `response`를 반환하는게 맞다고 한다. 현재는 적용하지 않는다.\n\n### `PUT` api\n\n원 예제는 여기서 끝이지만, 추가로 **PUT** api에 대해 직접 작성해본다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n나름 여러 과정을 거쳤는데, **`sqlmodel`** 관련 문제를 알아보다 보니 너무 꼬였다. 과정은 생략..\n\n다음은 마이그레이션 진행 후 유저 관련 설정을 추가하는 것 같다. 유저 관련해서는 **`fastapi-users`** 라는 좋은 라이브러리가 있으니, 원 예제와 같은 흐름이지만 **`fastapi-user`** 를 쓰는 쪽으로 진행할 예정.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","data":{"title":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","date":"2022-05-02T20:47:43.741+09:00","tags":["crud","fastapi","restful","tdd","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"sqlmodel 라이브러리 사용시 주의사항 - validation","content":"`sqlmodel`은 `fastapi`의 개발자 `tiangolo`의 주도 하에 개발이 진행중인 `sql`관련 라이브러리입니다. `pydantic`의 모델과 `sqlalchemy`의 테이블을 한번의 정의로 같이 쓸 수 있다는 장점이 있어서, 다소 불안정한 부분이 있더라도 종종 쓰고 있습니다.\n\n그런데 최근 아주 무서운 일을 확인했습니다.. `sqlmodel`로 정의한 모델에 `table=True`옵션을 주면 `pydantic`에서 자랑하는 검증 과정이 전혀 작동하지 않는다는 사실을..\n\n`from_orm`, `parse_obj` 이 두 메소드 모두 정상적으로 작동하지 않으니, `validate` 메소드를 이용해서 레코드를 생성하면 정상적으로 사용할 수 있는 것 같습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/sqlmodel 라이브러리 사용시 주의사항 - validation","data":{"title":"sqlmodel 라이브러리 사용시 주의사항 - validation","date":"2022-05-02T18:53:19.408+09:00","tags":["python","sqlmodel","@all"],"page":null,"summary":"sqlmodel에서 모델에 table=True 옵션을 주면 from_orm, parse_obj에서 validation 과정을 진행하지 않는다."}},{"name":"fastapi 튜토리얼 -4- pytest 적용 및 실행","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `pytest`를 사용한 테스트 코드 작성 및 실행\n\n테스트 코드를 작성하는게 도움이 된다 아니다로 많이 싸우지만, 적어도 **jeffastor** 자신은 이 과정 자체를 즐기고 있다고 밝히며, **`pytest`** 를 적용하는데 한 챕터를 할애한다.\n\n### 패키지 설치\n\n우선 테스트 코드 종속성 패키지부터 설치한다.\n\n```bash\n❯ poetry add --dev pytest pytest-asyncio httpx asgi-lifespan\n```\n\n> **`pytest-asyncio`** 는 비동기로 작성된 api를 테스트하는데 사용하고, **asgi-lifespan`** 은 앱을 실행하지 않고 테스트하기 위해 사용한다.\n\n그리고 이제 **`pytest`** 가 **`docker`** 에서 실행될 수 있게, 개발용 종속성 패키지도 **`docker`** 이미지를 빌드과정에 추가한다.\n\n```bash\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ docker-compose build\n```\n\n### `pytest` 설정 파일 작성\n\n이제 기본적인 테스트 코드를 작성한다.\n\n```bash\n❯ touch backend/tests/__init__.py backend/tests/conftest.py backend/tests/test_cleanings.py\n```\n\n```python\n# backend/tests/conftest.py\nimport os\nimport warnings\nfrom typing import AsyncIterator\n\nimport alembic\nimport pytest\nfrom alembic.config import Config\nfrom asgi_lifespan import LifespanManager\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n\n# Apply migrations at beginning and end of testing session\n@pytest.fixture(scope=\"session\")\ndef apply_migrations():\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n    os.environ[\"TESTING\"] = \"1\"\n    config = Config(\"alembic.ini\")\n\n    alembic.command.upgrade(config, \"head\")  # type: ignore\n    yield\n    alembic.command.downgrade(config, \"base\")  # type: ignore\n\n\n# Create a new application for testing\n@pytest.fixture\ndef app(apply_migrations: None) -> FastAPI:\n    from app.api.server import get_application\n\n    return get_application()\n\n\n# Grab a reference to our database when needed\n@pytest.fixture\ndef engine(app: FastAPI) -> AsyncEngine:\n    return app.state._db\n\n\n@pytest.fixture\nasync def session(engine: AsyncEngine) -> AsyncSession:\n    session = AsyncSession(engine, autoflush=False, autocommit=False)\n    try:\n        return session\n    finally:\n        await session.close()\n\n\n# Make requests in our tests\n@pytest.fixture\nasync def client(app: FastAPI) -> AsyncIterator[AsyncClient]:\n    async with LifespanManager(app):\n        async with AsyncClient(\n            app=app,\n            base_url=\"http://testserver\",\n            headers={\"Content-Type\": \"application/json\"},\n        ) as client:\n            yield client\n\n```\n\n[원문](https://www.jeffastor.com/blog/testing-fastapi-endpoints-with-docker-and-pytest)에 설명이 꽤 있으니 읽어보면 좋을듯.\n\n### 테스트 데이터베이스 엔진 및 마이그레이션 설정\n\n추가로 테스트 환경에서 정상적으로 작동하도록, 기존에 작성한 모듈을 수정한다.\n\n```python\n# backend/app/db/engine.py\nfrom os import getenv\n\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\nfrom sqlalchemy.pool import QueuePool\n\nfrom ..core.config import DATABASE_URL\n\n\ndef is_test() -> bool:\n    return (env_val := getenv(\"TESTING\", None)) is not None and bool(env_val)\n\n\ndef get_test_url(url: URL) -> URL:\n    if url.database is None:\n        raise ValueError(\"database name is None\")\n\n    return url.set(database=f\"{url.database}_test\")\n\n\ndef get_test_engine(engine: AsyncEngine) -> AsyncEngine:\n    if not is_test():\n        return engine\n    return create_engine_from_url(get_test_url(engine.url))\n\n\ndef create_engine_from_url(url: str | URL, **kwargs: Any) -> AsyncEngine:\n    return create_async_engine(\n        url, pool_size=10, poolclass=QueuePool, pool_pre_ping=True, **kwargs\n    )\n\n\nengine = create_engine_from_url(DATABASE_URL)\n```\n\n```python\n# backend/app/db/tasks.py\n(...)\n\nfrom .engine import engine, get_test_engine\n\n(...)\n\nasync def connect_to_db(app: FastAPI) -> None:\n    _engine = get_test_engine(engine)\n\n    try:\n        async with _engine.connect():\n            logger.info(\n                f\"connected db: {_engine.url.render_as_string(hide_password=True)}\"\n            )\n        app.state._db = _engine\n    except Exception as e:\n        logger.warning(\"--- DB CONNECTION ERROR ---\")\n        logger.warning(e)\n        logger.warning(\"--- DB CONNECTION ERROR ---\")\n\n(...)\n```\n\n```python\n# backend/app/db/migrations/env.py\nimport asyncio\nimport logging\nimport pathlib\nimport sys\nfrom logging.config import fileConfig\nfrom typing import cast\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlalchemy.exc import InvalidRequestError\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy.future.engine import Engine\n\nsys.path.append(str(pathlib.Path(__file__).resolve().parents[3]))\nfrom app.db.engine import engine, get_test_url, is_test\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\nlogger = logging.getLogger(\"alembic.env\")\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    if is_test():\n        raise InvalidRequestError(\n            \"Running testing migrations offline currently not permitted.\"\n        )\n\n    # url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        # url=url,\n        url=engine.url.render_as_string(hide_password=False),\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection):\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    url = engine.url\n    if is_test():\n        from sqlalchemy import text\n\n        url = get_test_url(url)\n        async with engine.connect() as conn:\n            conn = await conn.execution_options(isolation_level=\"AUTOCOMMIT\")\n            await conn.execute(text(f\"drop database if exists {url.database}\"))\n            await conn.execute(text(f\"create database {url.database}\"))\n\n    config.set_main_option(\"sqlalchemy.url\", url.render_as_string(hide_password=False))\n    connectable = AsyncEngine(\n        cast(\n            Engine,\n            engine_from_config(\n                config.get_section(config.config_ini_section),\n                prefix=\"sqlalchemy.\",\n                poolclass=pool.NullPool,\n                future=True,\n            ),\n        )\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\nif context.is_offline_mode():\n    logger.info(\"Running migrations offline\")\n    run_migrations_offline()\nelse:\n    logger.info(\"Running migrations online\")\n    asyncio.run(run_migrations_online())\n```\n\n이제 `TESTING`이라는 환경변수 값이 정상적으로 입력되어 있다면 테스트 DB를 사용한다. 또한, 마이그레이션시 테스트 DB가 이미 생성되어 있다면, 해당 DB를 지우고 새로 생성한다.\n\n### 테스트 코드 작성\n\n이제 이전에 작성한 라우터를 테스트 하는 테스트 코드를 작성한다.\n\n```python\n# backend/tests/test_cleanings.py\nimport pytest\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom starlette.status import HTTP_404_NOT_FOUND, HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCleaningsRoutes:\n    @pytest.mark.asyncio\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    @pytest.mark.asyncio\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_422_UNPROCESSABLE_ENTITY\n```\n\n이 테스트 코드는 우선 이전 챕터에서 작성한 `cleanings:create-cleaning` api가 존재하는지, 그리고 정상적으로 작동하는지 확인한다.\n\n이전에 어떻게 사용되는지 몰랐던 `conftest.py`에서 `pytest.fixture`로 데코레이트된 함수 `app`, `client`가 여기서 사용된다. `TestCleaningsRoutes`의 각 메소드의 파라미터와 이름이 일치하는 함수를 호출하여, 리턴값을 파라미터로 사용한다.\n\n`TestCleaningsRoutes.test_invalid_input_raises_error`에서 `json` 파라미터로 빈 딕셔너리를 제공했기에, 이전에 작성한 모델인 `cleaning_create`의 필수 값인 `name`과 `price`이 없어서 에러가 발생할 것으로 예상된다.\n\n이제 실제로 테스트를 실행해본다.\n\n```bash\nroot@3190a4d68f18:/backend# pytest -v\n==================================================== test session starts =====================================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 -- /usr/local/bin/python\ncachedir: .pytest_cache\nrootdir: /backend\nplugins: anyio-3.5.0, asyncio-0.18.3\nasyncio: mode=legacy\ncollected 2 items\n\ntests/test_cleanings.py::TestCleaningsRoutes::test_routes_exist PASSED                                                 [ 50%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error FAILED                                   [100%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error ERROR                                    [100%]\n\n=========================================================== ERRORS ===========================================================\n__________________________ ERROR at teardown of TestCleaningsRoutes.test_invalid_input_raises_error __________________________\n\n    @pytest.fixture(scope=\"session\")\n    def apply_migrations():\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n        os.environ[\"TESTING\"] = \"1\"\n        config = Config(\"alembic.ini\")\n\n        alembic.command.upgrade(config, \"head\")  # type: ignore\n        yield\n>       alembic.command.downgrade(config, \"base\")  # type: ignore\n\ntests/conftest.py:24:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n(...)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\nE   RuntimeError: Task <Task pending name='Task-20' coro=<run_migrations_online() running at /backend/./app/db/migrations/env.py:88> cb=[_run_until_complete_cb() at /usr/local/lib/python3.10/asyncio/base_events.py:184]> got Future <Future pending cb=[Protocol._on_waiter_completed()]> attached to a different loop\n\nasyncpg/protocol/protocol.pyx:338: RuntimeError\n-------------------------------------------------- Captured stderr teardown --------------------------------------------------\nINFO  [alembic.env] Running migrations online\n========================================================== FAILURES ==========================================================\n____________________________________ TestCleaningsRoutes.test_invalid_input_raises_error _____________________________________\n\nself = <tests.test_cleanings.TestCleaningsRoutes object at 0x7fc9e092b610>\napp = <fastapi.applications.FastAPI object at 0x7fc9e0928eb0>, client = <httpx.AsyncClient object at 0x7fc9df873640>\n\n    @pytest.mark.asyncio\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n>       assert res.status_code != HTTP_422_UNPROCESSABLE_ENTITY\nE       assert 422 != 422\nE        +  where 422 = <Response [422 Unprocessable Entity]>.status_code\n\ntests/test_cleanings.py:18: AssertionError\n====================================================== warnings summary ======================================================\n../usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:191\n  /usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:191: DeprecationWarning: The 'asyncio_mode' default value will change to 'strict' in future, please explicitly use 'asyncio_mode=strict' or 'asyncio_mode=auto' in pytest configuration file.\n    config.issue_config_time_warning(LEGACY_MODE, stacklevel=2)\n\n../usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:230\n  /usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:230: DeprecationWarning: '@pytest.fixture' is applied to <fixture client, file=/backend/tests/conftest.py, line=42> in 'legacy' mode, please replace it with '@pytest_asyncio.fixture' as a preparation for switching to 'strict' mode (or use 'auto' mode to seamlessly handle all these fixtures as asyncio-driven).\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n================================================== short test summary info ===================================================\nFAILED tests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error - assert 422 != 422\nERROR tests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error - RuntimeError: Task <Task pending name...\n====================================== 1 failed, 1 passed, 2 warnings, 1 error in 0.44s ======================================\nsys:1: SAWarning: The garbage collector is trying to clean up connection <AdaptedConnection <asyncpg.connection.Connection object at 0x7fc9e082a6c0>>. This feature is unsupported on async dbapi, since no IO can be performed at this stage to reset the connection. Please close out all connections when they are no longer used, calling ``close()`` or using a context manager to manage their lifetime.\n```\n\n예상했던 첫번째와 달리, 두번째 에러가 당황스럽다. 확인해보니 비동기 엔진을 **`pytest`** 에서 사용할 때, 이벤트 루프 때문에 런타임 에러가 발생했다. **`pytest`** 에 익숙하지 않기에, 해결할 방법 또한 당장 알아내기가 어렵다. 급한대로 **`alembic`** 사용시 동기 엔진을 사용하기로 했다.\n\n```bash\n❯ poetry add --dev psycopg2-binary\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ docker-compose build\n```\n\n```python\n# backend/app/db/engine.py\nfrom os import getenv\nfrom typing import Any, Literal, overload\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\nfrom sqlalchemy.future.engine import Engine\nfrom sqlalchemy.pool import QueuePool\n\nfrom ..core.config import DATABASE_URL\n\n\ndef is_test() -> bool:\n    return (env_val := getenv(\"TESTING\", None)) is not None and bool(env_val)\n\n\ndef get_test_url(url: URL) -> URL:\n    if url.database is None:\n        raise ValueError(\"database name is None\")\n\n    return url.set(database=f\"{url.database}_test\")\n\n\ndef get_engine_kwargs(**kwargs: Any) -> dict[str, Any]:\n    return {\n        \"pool_size\": 10,\n        \"poolclass\": QueuePool,\n        \"pool_pre_ping\": True,\n        \"future\": True,\n    } | kwargs\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine) -> AsyncEngine:\n    ...\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine, is_sync: Literal[True] = ...) -> Engine:\n    ...\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine, is_sync: Literal[False] = ...) -> AsyncEngine:\n    ...\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine, is_sync: bool = ...) -> AsyncEngine | Engine:\n    ...\n\n\ndef get_test_engine(engine: AsyncEngine, is_sync: bool = False) -> AsyncEngine | Engine:\n    if is_test():\n        engine = create_engine_from_url(\n            get_test_url(engine.url), pool_pre_ping=pool_pre_ping\n        )\n\n    if is_sync:\n        return convert_async_to_sync(engine)\n    return engine\n\n\ndef convert_async_to_sync(engine: AsyncEngine, **kwargs: Any) -> Engine:\n    return create_sync_engine_from_url(\n        engine.url.set(drivername=engine.url.drivername.split(\"+\")[0]), **kwargs\n    )\n\n\ndef create_sync_engine_from_url(url: str | URL, **kwargs: Any) -> Engine:\n    return create_engine(url, **get_engine_kwargs(**kwargs))\n\n\ndef create_engine_from_url(url: str | URL, **kwargs: Any) -> AsyncEngine:\n    return create_async_engine(url, **get_engine_kwargs(**kwargs))\n\n\nengine = create_engine_from_url(DATABASE_URL)\n```\n\n```python\n# backend/app/db/migrations/env.py\nimport logging\nimport pathlib\nimport sys\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlalchemy.exc import InvalidRequestError\n\nsys.path.append(str(pathlib.Path(__file__).resolve().parents[3]))\nfrom app.db.engine import engine, get_test_engine, is_test\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\nlogger = logging.getLogger(\"alembic.env\")\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    if is_test():\n        raise InvalidRequestError(\n            \"Running testing migrations offline currently not permitted.\"\n        )\n\n    # url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        # url=url,\n        url=engine.url.render_as_string(hide_password=False),\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection):\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    _engine = get_test_engine(engine, is_sync=True)\n    url = _engine.url\n\n    if is_test():\n        from sqlalchemy import text\n\n        with _engine.connect() as conn:\n            conn = conn.execution_options(isolation_level=\"AUTOCOMMIT\")\n            conn.execute(text(f\"drop database if exists {url.database}\"))\n            conn.execute(text(f\"create database {url.database}\"))\n\n    config.set_main_option(\"sqlalchemy.url\", url.render_as_string(hide_password=False))\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n        future=True,\n    )\n\n    with connectable.connect() as connection:\n        do_run_migrations(connection)\n\n    connectable.dispose()\n\n\nif context.is_offline_mode():\n    logger.info(\"Running migrations offline\")\n    run_migrations_offline()\nelse:\n    logger.info(\"Running migrations online\")\n    run_migrations_online()\n```\n\n이제 다시 **`pytest`** 를 실행해보면\n\n```bash\n(...)\n\n================================================== short test summary info ===================================================\nFAILED tests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error - assert 422 != 422\n================================================ 1 failed, 1 passed in 0.35s =================================================\n```\n\n정상적으로 2번째 메소드만 에러를 발생시킨다.\n이제 이전에 작성한 **POST** api에 대한 테스트 코드를 작성해보자.\n\n```python\n# backend/app/models/cleaning.py\n(...)\n\nclass cleaning_update(cleaning_base):\n    cleaning_type: cleaning_type_enum | None = None\n\n(...)\n```\n\n```python\n# backend/tests/test_cleanings.py\nimport orjson\nimport pytest\nfrom app.models.cleaning import cleaning_create\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n# decorate all tests with @pytest.mark.asyncio\npytestmark = pytest.mark.asyncio\n\n\n@pytest.fixture\ndef new_cleaning():\n    return cleaning_create.parse_obj(\n        dict(\n            name=\"test cleaning\",\n            description=\"test description\",\n            price=0.00,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n\n\nclass TestCleaningsRoutes:\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCreateCleaning:\n    async def test_valid_input_creates_cleaning(\n        self, app: FastAPI, client: AsyncClient, new_cleaning: cleaning_create\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": orjson.loads(new_cleaning.json())},\n        )\n        assert res.status_code == HTTP_201_CREATED\n\n        created_cleaning = cleaning_create(**res.json())\n        assert created_cleaning == new_cleaning\n\n    @pytest.mark.parametrize(\n        \"invalid_payload, status_code\",\n        (\n            (None, 422),\n            ({}, 422),\n            ({\"name\": \"test_name\"}, 422),\n            ({\"price\": 10.00}, 422),\n            ({\"name\": \"test_name\", \"description\": \"test\"}, 422),\n        ),\n    )\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient, invalid_payload: dict, status_code: int\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": invalid_payload},\n        )\n        assert res.status_code == status_code\n```\n\n`cleanings:create-cleaning` api가 의도한대로 데이터를 추가하고, 반환하는지 확인하는 코드가 추가됐다.\n\n또한, 에러를 발생하는 `body`의 형태와, 그러한 `body`에 대해 기대하는 `status_code`를 지정해서 확인한다.\n\n결과는 다음과 같이 정상적으로 나와야 한다.\n\n```bash\n==================================================== test session starts =====================================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 -- /usr/local/bin/python\ncachedir: .pytest_cache\nrootdir: /backend\nplugins: anyio-3.5.0, asyncio-0.18.3\nasyncio: mode=auto\ncollected 8 items\n\ntests/test_cleanings.py::TestCleaningsRoutes::test_routes_exist PASSED                                                 [ 12%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error PASSED                                   [ 25%]\ntests/test_cleanings.py::TestCreateCleaning::test_valid_input_creates_cleaning PASSED                                  [ 37%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[None-422] PASSED                          [ 50%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload1-422] PASSED              [ 62%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload2-422] PASSED              [ 75%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload3-422] PASSED              [ 87%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload4-422] PASSED              [100%]\n\n===================================================== 8 passed in 0.54s ======================================================\n```\n\n## TDD 방법론에 따른 개발 연습\n\n이제 **`pytest`** 를 사용하는 방식에 대해 어느정도 감이 잡히는 느낌이다.\n**jeffastor**는 이러한 테스트 코드를 이용해서, **TDD**(테스트 주도 개발)을 권장하는 것 같다.\n**TDD**는 다음의 3단계 프로세스를 따른다.\n\n> 1. 실패를 확인할 수 있는 테스트 코드를 작성한다.\n> 2. 테스트 코드를 통과할 수 있도록 코드를 작성한다.\n> 3. 자신이 만족할 수준으로 코드를 수정, 테스트, 리팩토링, 모듈화 등을 실시한다.\n\n### `GET` `api` 생성\n\n위 프로세스를 따라서 **GET** api를 생성해보자.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nfrom app.models.cleaning import cleaning_create, cleanings\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n(...)\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-cleaning-by-id\", id=\"1\"))\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings(**res.json())\n        assert cleaning.id == 1\n```\n\n작성한 테스트 코드의 `TestGetCleaning.test_get_cleaning_by_id` 메소드를 통과할 수 있도록, **GET** api를 작성해보자.\n\n```python\n# backend/app/api/routes/cleanings.py\nfrom fastapi import APIRouter, Body, Depends, HTTPException, Path\nfrom starlette.status import HTTP_201_CREATED, HTTP_404_NOT_FOUND\n\n(...)\n\n@router.get(\n    \"/{id}\", response_model=cleaning_public, name=\"cleanings:get-cleaning-by-id\"\n)\nasync def get_cleaning_by_id(\n    id: int = Path(..., ge=1),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n    return cleaning\n```\n\n확인해본 결과, 모두 잘 작동한다.\n하지만 테스트 코드에 문제가 있다. `id=1`로 하드코딩된 상태이기 때문. 따라서 하드코딩을 제거하기 위한 새로운 `fixture`를 생성할 필요가 있다.\n\n```python\n# backend/tests/test_cleanings.py\n\n(...)\n\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_cleaning(session: AsyncSession) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.from_orm(new_cleaning_create)\n    session.add(new_cleaning)\n    await session.commit()\n    await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        print(test_cleaning)\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.parse_obj(res.json())\n        assert cleaning == test_cleaning\n```\n\n`refresh` 메소드를 사용하여 정확한 id를 가지고 비교를 해서 에러가 없을거라 생각했는데,\n\n```bash\n================================================== short test summary info ===================================================\nERROR tests/test_cleanings.py::TestGetCleaning::test_get_cleaning_by_id - sqlalchemy.exc.OperationalError: (psycopg2.errors...\n================================================= 9 passed, 1 error in 5.74s =================================================\nsys:1: SAWarning: The garbage collector is trying to clean up connection <AdaptedConnection <asyncpg.connection.Connection object at 0x7fabadaffbc0>>. This feature is unsupported on async dbapi, since no IO can be performed at this stage to reset the connection. Please close out all connections when they are no longer used, calling ``close()`` or using a context manager to manage their lifetime.\n```\n\n**`pytest`** 에서 `fixture`를 생성할 때 연결한 `session`을 제대로 정리하지 않아서 에러가 발생했다. **`pytest`** 에서는 `NullPool`을 사용하고, **`pytest`** 에서 `session` 객체를 `fixture`로 사용하지 않도록 하자.\n\n```python\nfrom sqlalchemy.pool import AsyncAdaptedQueuePool, NullPool, QueuePool\n\n(...)\n\ndef get_engine_kwargs(\n    is_sync: bool, is_test: bool = False, **kwargs: Any\n) -> dict[str, Any]:\n    params: dict[str, Any] = {\"pool_pre_ping\": True, \"future\": True}\n\n    if is_test:\n        params[\"poolclass\"] = NullPool\n    else:\n        params[\"pool_size\"] = 10\n        params[\"poolclass\"] = QueuePool\n\n    return params | kwargs\n\n\n(...)\n\ndef get_test_engine(engine: AsyncEngine, is_sync: bool = False) -> AsyncEngine | Engine:\n    if _is_test := is_test():\n        engine = create_engine_from_url(get_test_url(engine.url), is_test=_is_test)\n\n    if is_sync:\n        return convert_async_to_sync(engine, is_test=_is_test)\n    return engine\n\n(...)\n```\n\n```python\n# backend/tests/conftest.py\nimport os\nimport warnings\nfrom typing import AsyncIterator\n\nimport alembic\nimport pytest\nfrom alembic.config import Config\nfrom asgi_lifespan import LifespanManager\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\n\n# Apply migrations at beginning and end of testing session\n@pytest.fixture(scope=\"session\")\ndef apply_migrations():\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n    os.environ[\"TESTING\"] = \"1\"\n    config = Config(\"alembic.ini\")\n\n    alembic.command.upgrade(config, \"head\")  # type: ignore\n    yield\n    alembic.command.downgrade(config, \"base\")  # type: ignore\n\n\n# Create a new application for testing\n@pytest.fixture\ndef app(apply_migrations: None) -> FastAPI:\n    from app.api.server import get_application\n\n    return get_application()\n\n\n# Grab a reference to our database when needed\n@pytest.fixture\ndef engine(app: FastAPI) -> AsyncEngine:\n    return app.state._db\n\n\n# Make requests in our tests\n@pytest.fixture\nasync def client(app: FastAPI) -> AsyncIterator[AsyncClient]:\n    async with LifespanManager(app):\n        async with AsyncClient(\n            app=app,\n            base_url=\"http://testserver\",\n            headers={\"Content-Type\": \"application/json\"},\n        ) as client:\n            yield client\n```\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.from_orm(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n(...)\n```\n\n다시 **`pytest`** 를 실행했을 때, 정상적으로 잘 되는 것을 확인했다.\n\n### `GET` `api`에 유효하지 않은 값에 대한 테스트 코드\n\n이어서, 유효하지 않은 값에 대한 테스트 코드를 추가한다.\n원 예제는 `id=-1`에 대해 404 에러 코드를 반환하지만, 이전에 **GET** api를 정의할 때 `id: int = Path(..., ge=1)` 으로 정의했기에 422에러가 반환된다. 따라서 그 부분만 수정했다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        print(test_cleaning)\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.parse_obj(res.json())\n        assert cleaning == test_cleaning\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n```\n\n테스트시, 별 문제 없이 통과한다.\n\n```bash\nroot@5984264d864d:/backend# pytest -v --asyncio-mode=auto\n==================================================== test session starts =====================================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 -- /usr/local/bin/python\ncachedir: .pytest_cache\nrootdir: /backend\nplugins: anyio-3.5.0, asyncio-0.18.3\nasyncio: mode=auto\ncollected 12 items\n\ntests/test_cleanings.py::TestCleaningsRoutes::test_routes_exist PASSED                                                 [  8%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error PASSED                                   [ 16%]\ntests/test_cleanings.py::TestCreateCleaning::test_valid_input_creates_cleaning PASSED                                  [ 25%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[None-422] PASSED                          [ 33%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload1-422] PASSED              [ 41%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload2-422] PASSED              [ 50%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload3-422] PASSED              [ 58%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload4-422] PASSED              [ 66%]\ntests/test_cleanings.py::TestGetCleaning::test_get_cleaning_by_id PASSED                                               [ 75%]\ntests/test_cleanings.py::TestGetCleaning::test_wrong_id_returns_error[500-404] PASSED                                  [ 83%]\ntests/test_cleanings.py::TestGetCleaning::test_wrong_id_returns_error[-1-422] PASSED                                   [ 91%]\ntests/test_cleanings.py::TestGetCleaning::test_wrong_id_returns_error[None-422] PASSED                                 [100%]\n\n===================================================== 12 passed in 0.86s =====================================================\n```\n\n다음 챕터는 CRUD api를 잘 생성하기 위한 작업으로 보인다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -4- pytest 적용 및 실행","data":{"title":"fastapi 튜토리얼 -4- pytest 적용 및 실행","date":"2022-04-30T02:43:31.082+09:00","tags":["fastapi","tdd","pytest","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}}]},"__N_SSG":true}