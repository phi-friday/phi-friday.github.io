{"pageProps":{"tag":"@all","page":1,"max_page":6,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"returns2","content":"\n# `ROP`\n## `ROP`에 대한 간략한 설명\n> 오개념이 있을 가능성이 높으니, 따로 더 검색해서 알아보기를 권장합니다.\n\n`ROP`는 __Railway oriented programming__ 의 약어로, 직역하면 __철도 지향 프로그래밍__ 이다. 이름 그대로 `input`과 `output`를 적절한 철도(함수)로 이어준다.\n\n전통적인 방식에서는, 각 철도(함수)마다 예외처리를 실시하여 에러에 대응하지만, 프로그램의 규모가 커질수록 유지보수에 어려움이 발생한다.\n\n이를 해결하기 위해, 각 철도(함수)에서 발생하는 에러는 프로그램의 오작동을 유발하는 것이 아닌 적합한 `output`으로 간주하며, 다음 철도(함수)에서 `input`으로 활용한다.\n\n즉, 각 철도(함수)의 `input`과 `output`은 개발자가 의도한 정상적인 값과 의도하지 않은 비정상적인 값(에러)으로 구분된다.\n\n이렇게 작성된 프로그램은 각 철도(함수)별 예외처리가 없더라도, 각 철도(함수)별 `output`의 상태를 구분지을 수 있고, `output`은 단 두가지로 구분되므로, 다음 철도(함수)의 `input`으로 활용하는데 있어서 깔끔한 조작을 가능하게 한다. \n\n> 위 글을 포함한 이전 포스트까지 __정상__ 상태와 __비정상__ 상태로 구분지어 표현하였으나, `returns`의 `container`와 용어를 일치하기 위해, 이후 글 부터는 __성공__ 과 __실패__ 로 대신합니다.\n\n## `returns`가 제시하는 `ROP`\n`returns`에서 미리 정의된 `container`는 `alt`, `map`, `lash`, `bind` 메소드를 사용하여 함수(철도)를 잇게 한다.\n\n* `alt`: __실패__ 를 사용하여, __실패__ 로 잇는다.\n* `map`: __성공__ 을 사용하여, __성공__ 으로 잇는다. \n* `lash`: __실패__ 를 사용하여, __성공__ 또는 __실패__ 로 잇는다.\n* `bind`: __성공__ 을 사용하여, __성공__ 또는 __실패__ 로 잇는다.\n\n다만 모든 `container`가 위와 같은 메소드를 가지고 있는 것은 아니다. `returns.interfaces` 모듈에는 이러한 메소드에 대한 인터페이스가 정의되어 있고, 해당하는 인터페이스를 만족하는 `container`가 위와 같은 메소드를 사용할 수 있다.\n\n> `map`과 `bind`에 대한 간략한 설명과 예제는 이전 포스트에 포함되어 있고, `alt`와 `lash`는 `input`의 상태에만 차이가 있으므로 생략한다.\n\n# `container`에서 실제 값을 추출하는 방법\n```python\nfrom returns.maybe import Maybe\nfrom returns.primitives.exceptions import UnwrapFailedError\nfrom returns.result import ResultE\n\nassert ResultE.from_value(1).unwrap() == 1\ntry:\n    result = ResultE.from_failure(1).unwrap()\nexcept Exception as exc:\n    result = exc\nassert isinstance(result, UnwrapFailedError)\nassert ResultE.from_value(1).value_or(2) == 1\nassert ResultE.from_failure(1).value_or(2) == 2\n\nassert Maybe.from_optional(1).unwrap() == 1\ntry:\n    result = Maybe.from_optional(None).unwrap()\nexcept Exception as exc:\n    result = exc\nassert isinstance(result, UnwrapFailedError)\nassert Maybe.from_optional(1).value_or(2) == 1\nassert Maybe.from_optional(None).value_or(2) == 2\nassert Maybe.from_optional(1).or_else_call(lambda: 2) == 1\nassert Maybe.from_optional(None).or_else_call(lambda: 2) == 2\n```\n`Container`로 감싸진 내부의 값을 추출하기 위해서는 `unwrap` 또는 `value_or` 또는 'or_else_call` 메소드를 사용하면 된다.\n\n* `unwrap` 메소드는 __성공__ 일 때만 정상적으로 추출이 가능하다.\n\n* `value_or`는 __실패__ 일 때 처리가 가능하게 만든다.\n\n* `or_else_call`는 __실패__ 일 때 반환할 값을 지연시킬 수 있다.\n> `or_else_call` 메소드는 `Maybe`에는 있고 `Result`에는 없다. `Result`에서는 `alt`가 있기 때문이다.\n>\n> 또한 `unwrap`이 불가능한 경우도 있다. `IO`가 대표적이다.\n\n# 원문\n[Railway oriented programming](https://returns.readthedocs.io/en/latest/pages/railway.html)","mtime":"2022-09-13T22:23:54.967+09:00","href":"python/returns2","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 2 - ROP","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-13T22:22:07.993+09:00"}},{"name":"returns1","content":"\n# `returns`의 주요 기능들\n\n`returns`는 파이썬 스크립트가 실행되면서 생성하는 값을 `Container`로 감싸고, 이 값을 개발자가 주도적으로 관리할 수 있도록 유도한다.\n\n기본적으로 완성된 형태로 제공되는 `Container`는 `Maybe`, `Result`, `IO`, `Future`, `RequiresContext`가 있고, 다음과 같은 경우 사용된다.\n\n* `Maybe`: `None` 일 수 있는 값\n* `Result`: 에러가 발생 할 수 있는 값\n* `IO`: `IO` 작업과 관련된 값\n* `Future`: 비동기 작업과 관련된 값\n* `RequiresContext`: 함수의 의존성과 관련된 값\n\n> `IOResult`, `RequiresContextFutureResult` 등 결합된 형태로 제공하기도 한다. 물론 개발자가 직접 새로운 `Container`를 정의할 수도 있다.\n\n이러한 `Container`들은 `map`, `alt`, `bind`, `lash` 메소드를 이용하여 최종 결과물로 안전하게 도달하고, 개발자는 그 `Container`의 상태를 확인하고, 그 값을 사용하면 된다.\n\n## `Container`의 내부 값에 영향을 미치는 `map`\n설명보다는 코드를 직접 확인하는게 더 빠르다.\n```python\nfrom returns.maybe import Maybe, Nothing, Some\nfrom returns.result import Failure, ResultE, Success\n\n\ndef div_3(value: float) -> float:\n    return value / 3\n\n\ndummy_exc = Exception(\"error\")\nsuccess_value: ResultE[int] = ResultE.from_value(1)\nmaybe_value: Maybe[int] = Maybe.from_optional(1)\nfailure_value: ResultE[int] = ResultE.from_failure(dummy_exc)\nmaybe_non_value: Maybe[int] = Maybe.from_optional(None)\n\nassert success_value == Success(1)\nassert failure_value == Failure(dummy_exc)\nassert maybe_value == Some(1)\nassert maybe_non_value == Nothing\n\nsuccess_result = success_value.map(div_3)\nfailure_result = failure_value.map(div_3)\nmaybe_result = maybe_value.map(div_3)\nmaybe_non_result = maybe_non_value.map(div_3)\n\nassert success_result == Success(div_3(1))\nassert failure_result is failure_value\nassert maybe_result == Some(div_3(1))\nassert maybe_non_result is Nothing\n\nassert success_result.unwrap() == div_3(1)\nassert failure_result.failure() is dummy_exc\nassert maybe_result.value_or(None) == div_3(1)\nassert maybe_non_result.value_or(\"test\") == \"test\"\n```\n`Container`의 내부 값을 사용하는 함수를 `map`메소드의 인수로 전달하면, 그 `Container`의 상태가 정상일 때만 작동하고, 그렇지 않다면 아무 일도 하지 않는다.\n\n즉, `map`은 정상적인 상태인 `Container`의 값만 변화시키는 메소드다.\n\n`map`에 사용되는 함수는 에러가 발생하지 않는 순수함수를 가정하고 사용되기에, 함수 실행중 에러가 발생하더라도 `Result` 객체로 감싸지지 않고 작동을 멈출 것이다.\n\n그렇다면 비정상 상태의 `Container` 내부의 값을 변화시키려면 어떻게 해야할까? 그때는 `alt` 메소드를 사용하면 된다.\n\n## `Container`의 상태를 변화시키는 `bind`\n```python\nfrom returns.maybe import Maybe, Nothing, Some, maybe\nfrom returns.result import Failure, ResultE, Success, safe\n\n\ndef div_3_v1(value: int) -> ResultE[float]:\n    try:\n        return Success(3 / value)\n    except Exception as exc:\n        return Failure(exc)\n\n\n@safe\ndef div_3_v2(value: int) -> float:\n    return 3 / value\n\n\ndef div_3_v3(value: int) -> Maybe[float]:\n    try:\n        return Some(3 / value)\n    except:\n        return Nothing\n\n\n@maybe\ndef div_3_v4(value: int) -> float | None:\n    return 3 / value\n\n\ndummy_exc = Exception(\"error\")\nsuccess_value: ResultE[int] = ResultE.from_value(0)\nmaybe_value: Maybe[int] = Maybe.from_optional(1)\nfailure_value: ResultE[int] = ResultE.from_failure(dummy_exc)\nmaybe_non_value: Maybe[int] = Maybe.from_optional(None)\n\nassert success_value == Success(0)\nassert failure_value == Failure(dummy_exc)\nassert maybe_value == Some(1)\nassert maybe_non_value == Nothing\n\nsuccess_result = success_value.bind(div_3_v1)\nfailure_result = failure_value.bind(div_3_v2)\nmaybe_result = maybe_value.bind(div_3_v3)\nmaybe_non_result = maybe_non_value.bind(div_3_v4)\n\nassert str(success_result) == \"<Failure: division by zero>\"\nassert failure_result is failure_value\nassert maybe_result == div_3_v4(1)\nassert maybe_non_result is Nothing\n\nassert repr(success_result.failure()) == \"ZeroDivisionError('division by zero')\"\nassert failure_result.failure() is dummy_exc\nassert maybe_result.value_or(None) == 3\nassert maybe_non_result.value_or(\"test\") == \"test\"\n```\n`bind`는 `Container`의 값을 사용하여 새로운 `Container`를 반환하는 함수를 받는다. 그 함수가 어떻게 정의됐는가에 따라 정상 상태의 `Container`를 반환할 수도 있고, 비정상 상태의 `Container`를 반환할 수도 있다.\n\n즉, `bind`는 정상적인 상태인 Container의 값과 상태를 변화시키는 메소드다.\n\n이러한 함수를 `div_3_v1`이나 `div_3_v3`처럼 일일이 정의하는 것은 손이 많이 가는 작업이므로, 가능하다면 `div_3_v2`이나 `div_3_v4`처럼 `safe`나 `maybe`와 같은 데코레이터를 사용할 것을 권장한다.\n\n`map`과 `alt`처럼 `bind`에도 대응하는 메소드가 있는데, 바로 `lash`다. `lash`는 비정상 상태의 컨테이너를 정상 상태의 컨테이너로 바꿀 수 있다. 물론 비정상 상태를 유지할 수도 있다.\n\n## 여러개의 `Container`를 함께 사용하는 방법\n\n`Container` 각각에 대해 `map`, `bind` 등을 사용하여 값과 상태를 관리하는 것은 알겠지만, 두개 이상의 `Container`를 복합적으로 사용하려면 어떻게 해야할까?\n\n여러 방법이 있겠지만, 그 중 세가지만 알아보자.\n> `returns`는 `mypy`를 사용한다고 가정하기에, `pylance`에서는 정상적으로 타입추론이 되지 않는 경우가 있다.\n>\n> 대부분의 경우 문제가 없었는데, 후술할 `curry`가 그러했다.\n### 개별적으로 사용하는 방법\n```python\nfrom returns.curry import curry, partial\nfrom returns.io import IO\n\n\ndef sum_v1(left: float, right: float) -> float:\n    return left + right\n\n\nsum_v2 = curry(sum_v1)\n\nleft: IO[float] = IO(1.0)\nright: IO[float] = IO(2.0)\n\nassert right.apply(left.apply(IO(sum_v2))) == IO(3.0) # pylance에서 문제 발생\nassert right.apply(left.apply(IO(lambda x: partial(sum_v1, x)))) == IO(3.0)\nassert right.apply(left.apply(IO(lambda x: lambda y: sum_v1(x, y)))) == IO(3.0)\nassert sum_v2(1.0)(2.0) == 3 # pylance에서 문제 발생\n```\n\n`returns`에서 제공하는 `curry`를 사용하면, 여러개의 인자를 필요로 하는 함수에 인자를 전달할 때, 한번에 모두 전달하지 않아도 된다. 물론 `lambda`와 `partial`을 사용해서 직접 구현해도 문제 없다.\n\n여기서 사용되는 `partial`은 `functools`와 같은 방식으로 사용된다. 차이가 있다면 `returns`의 `partial`은 좀 더 타입추론을 똑똑하게 해준다.\n\n> 성능은 `lambda`로 직접 구현하는게 더 낫다고 한다..\n### `Iterable`로 묶어서 사용하는 방법\n```python\nfrom typing import Callable\n\nfrom returns.curry import partial\nfrom returns.io import IO\nfrom returns.iterables import Fold\n\n\ndef sum_v1(left: float, right: float) -> float:\n    return left + right\n\n\ndef sum_v2(value: float) -> Callable[[float], float]:\n    return partial(sum_v1, value)\n\n\ndef get_one() -> IO[float]:\n    return IO(1)\n\n\nassert Fold.loop([get_one() for _ in range(10)], IO(5), sum_v2) == IO(10 + 5)\nassert Fold.loop([get_one() for _ in range(5)], IO(7), sum_v2) == IO(5 + 7)\n```\n`Fold.loop`는 `Iterable`로 묶여진 `Container`를 사용하는데 유용한 클래스메소드다. 내부 알고리즘은 단순하며, 다음과 같다.\n> 1. `Iterable[Container[T]]`에서 `Container[T]` 하나를 선택한다.\n> \n> 2. 선택한 `Container[T]`로 `Callable[[R], R]` 객체를 생성한다. (`T`가 아니다!)\n>\n> 3. 초기값으로 지정된 `Container[R]`를 사용하여 새로운 초기값 `Container[R]`을 생성한다.\n>\n> 4. 반복\n\n### 여러개로 나눠진 `Container`를 하나로 합치는 방법\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.iterables import Fold\nfrom returns.maybe import Maybe, Nothing, Some, maybe\nfrom returns.result import Failure, Result, Success\n\ninit_data = dict(zip(list(\"abc\"), range(3)))\n\n\n@maybe\ndef get(key: str) -> int | None:\n    return init_data.get(key)\n\n\nvalues_abc: list[Maybe[int]] = [get(key) for key in \"abc\"]\nvalues_abcd: list[Maybe[int]] = [get(key) for key in \"abcd\"]\nresult_abc: list[Result[int, None]] = [maybe_to_result(x) for x in values_abc]\nresult_abcd: list[Result[int, None]] = [maybe_to_result(x) for x in values_abcd]\n\nassert Fold.collect(values_abc, Some(())) == Some((0, 1, 2))\nassert Fold.collect(result_abc, Success(())) == Success((0, 1, 2))\nassert Fold.collect(values_abc, Some((100,))) == Some((100, 0, 1, 2))\nassert Fold.collect(result_abc, Success((200,))) == Success((200, 0, 1, 2))\n\nassert Fold.collect(values_abcd, Some(())) is Nothing\nassert Fold.collect(result_abcd, Success(())) == Failure(None)\n\nassert Fold.collect_all(values_abcd, Some(())) == Some((0, 1, 2))\nassert Fold.collect_all(result_abcd, Success(())) == Success((0, 1, 2))\nassert Fold.collect_all(values_abcd, Some((10, 20))) == Some((10, 20, 0, 1, 2))\nassert Fold.collect_all(result_abcd, Success((10, 20))) == Success((10, 20, 0, 1, 2))\n```\n\n`Fold.collect`를 사용하면, 모든 `Container`가 정상인 경우에 대해서만 수집을 진행하고,\n\n`Fold.collect_all`를 사용하면, 비정상 상태의 `Container`를 제외하고 수집을 진행한다.\n\n# 원문\n[Container: the concept](https://returns.readthedocs.io/en/latest/pages/container.html)\n","mtime":"2022-09-13T20:54:28.507+09:00","href":"python/returns1","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 1 - 주요 기능들","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-09T23:18:43.310+09:00"}},{"name":"returns0","content":"\n# 2% 부족한 `python`의 `type-hint`\n`python`에서 `type-hint` 지원이 점점 강력해지고, 이를 반영한 라이브러리들이 늘어나다 보니, 나도 `type-hint`를 적용해가며 개발을 하고 있다.\n\n하지만 아직 몇몇 아쉬운 부분이 보이는데,\n\n특정 클래스 메소드의 리턴값을 그 클래스의 인스턴스로 나타내려 할 때, `TypeVar`를 사용해서 `bound`를 일일이 지정해줘서 나타내야 한다던가..\n> 이전에는 `TypeVar`를 사용해야 했지만, 이제는 PEP 673이 반영된 `typing_extensions`의 `Self`를 사용하면 된다.\n>\n> 하지만 아직 많은 라이브러리가 `Self`를 사용하고 있지는 않다.(이미 `TypeVar`로 많은 부분이 작성되어 있으므로)\n\n나중에 정의될 클래스를 `type-hint`로 사용하려면 문자열로 표현해야 한다던가..\n> 3.11에서 수정될 예정이고, `__future__` 에서 `annotation` 모듈을 가져오면 미리 사용할 수 있다.\n\n`TypeVar`로 정의된 값을 이용해서 상위 제네릭을 표현할 수 없다던가..\n```python\nfrom typing import TypeVar, Generic\n\n_T = TypeVar(\"_T\")\n_Test = TypeVar(\"_Test\", bound=\"Test\")\n\nclass Test(Generic[_T]):\n    def __init__(self, data: _T):\n        self.data = data\n\ndef test(value: _T[int]) -> _T[int]:\n    ...\n# TypeError: 'TypeVar' object is not subscriptable\n```\n\n쓰다보니 뭔가 대부분 `TypeVar` 관련인데, 이 중에서 `TypeVar`를 사용한 상위 제네릭과 관련해서 좀 더 알아봤더니, 제한적으로나마 이를 해결한 라이브러리가 있었는데, 그게 바로 [returns](https://github.com/dry-python/returns)다.\n\n> 앞서 상위 제네릭이라 표현한 것은, 일반적으로 __Higher Kinded Type__ 이라고 하는 것 같다.\n\n# 함수형 프로그래밍에 적합한 `returns`\n라이브러리 이름이 범용적으로 쓰이는 `return`과 너무 유사해서, 제대로 검색이 되지 않는다. 마치 구글의 `go`를 보는 듯 하다..\n\n다행히 `returns` 자체 [문서](https://returns.readthedocs.io/en/latest/index.html)가 아주 잘 만들어져 있어서, 이해하는데 큰 문제는 없었다.\n\n또한 라이브러리 기능이 간단하면서도 강력해서, `type-hint` 외에도 쓸데가 많아보인다. 특히, 함수형 프로그래밍을 하고자 한다면 꽤 유용하지 않을까, 싶었는데 `readme`에서 함수형 프로그래밍을 위해 만들어진 라이브러리라고 직접 소개하고 있다.\n> _Brings functional programming to Python land_\n\n처음에는 단순히 __Higher Kinded Type__ 를 위해 알아봤는데, 이제는 이 라이브러리를 어떻게 사용하면 잘 사용할 수 있을까 고민하게 됐다.\n\n`returns`의 대표적인 기능 두가지만 미리 소개하자면,\n\n## `Optional`을 대신 할 `Maybe`\n\n```python\nfrom returns.maybe import Maybe, maybe\n\n\n@maybe\ndef one_or_none(value: int) -> int | None:\n    if value == 1:\n        return value\n    return None\n\n\nmaybe_one0: Maybe[int] = one_or_none(1)\nmaybe_one1: Maybe[int] = one_or_none(2)\n# or\n# maybe_one0: Maybe[int] = Maybe.from_optional(1)\n# maybe_one1: Maybe[int] = Maybe.from_optional(None)\n\nmaybe_str0 = maybe_one0.bind_optional(str)\nmaybe_str1 = maybe_one1.bind_optional(str)\n\nassert maybe_str0.value_or(\"error\") == \"1\"\nassert maybe_str1.value_or(\"error\") == \"error\"\n```\n원래라면 `if`문을 사용해서 `None` 타입 확인을 하고 진행했겠지만,\n\n`Maybe`는 마치 `js`의 `some_object?.some_attr`과 같은 방식으로 전개할 수 있게 만들어준다.\n\n\n## `try`, `except`를 대신할 `Result`\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Result, safe\n\n\n@safe\ndef div(left: float, right: float) -> float:\n    # if right == 0:\n    # raise ZeroDivisionError\n    return left / right\n\n\nresult0: Result[float, Exception] = div(2, 3)\n# or\n# result0: Result[float, ZeroDivisionError]\n# or\n# from returns.result import ResultE\n# result0: ResultE[float] = div(2, 3)\nresult1: Result[float, Exception] = div(4, 0)\n\nassert (\n    result_to_maybe(result0.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == 4 / 9\n\nassert (\n    result_to_maybe(result1.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == \"error\"\n```\n\n에러에 대해 미리 고민 할 필요 없이, 기본적으로 제공되는 `map`, `bind`, `alt`, `lash` 등의 메소드를 사용하면 된다.\n\n올바른 타입이 아니라면 작동하지 않고, 추가적인 에러도 발생하지 않는다.\n\n위 예시에서는 문자열 `error`를 표시했지만, 원한다면 그 에러를 발생시킬 수도 있다.\n\n# 앞으로\n시간이 될 때, `returns`의 공식 문서를 나름대로 정리해서 포스팅을 하고자 한다. 하지만 이것도 다른 것과 마찬가지로 하다가 중단될 수 있다..\n","mtime":"2022-09-13T20:54:24.447+09:00","href":"python/returns0","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 0","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-09T02:10:44.645+09:00"}},{"name":"wsl2를 localhost로 연결할 수 없을 때","content":"\n# `localhost` 연결이 왜 안돼\n`wsl2`(이하 `wsl`)에서 \n```bash\npython -m http.server\n```\n위와 같이 서버를 실행 한 다음, ```localhost:8000```으로 접근하면 해당 디렉토리를 탐색할 수 있는 페이지에 접근 할 수 있다.\n\n그런데 정확한 이유는 모르겠지만 이게 정상적으로 작동하지 않을 때가 있다.\n\n# `wsl`의 주소에 직접 접근하자\n`wslconfig`를 수정해봐도 동일한 문제가 반복되는게 짜증나서, `localhost`대신 `wsl`의 로컬 주소를 매핑하는 글을 찾아봤다.\n\n[Fixing WSL2 localhost access issue](https://abdus.dev/posts/fixing-wsl2-localhost-access-issue/)\n\n> 위 글에서 가져온, 아래에서 사용할 코드\n>```powershell {filename=remote-port-hosts.ps1}\n>$hostname = \"wslhost\"\n>\n># find ip of eth0\n>$ifconfig = (wsl -- ip -4 addr show eth0)\n>$ipPattern = \"((\\d+\\.?){4})\"\n>$ip = ([regex]\"inet $ipPattern\").Match($ifconfig).Groups[1].Value\n>if (-not $ip) {\n>    exit\n>}\n>Write-Host $ip\n>\n>$hostsPath = \"$env:windir/system32/drivers/etc/hosts\"\n>\n>$hosts = (Get-Content -Path $hostsPath -Raw -ErrorAction Ignore)\n>if ($null -eq $hosts) {\n>    $hosts = \"\"\n>}\n>$hosts = $hosts.Trim()\n>\n># update or add wsl ip\n>$find = \"$ipPattern\\s+$hostname\"\n>$entry = \"$ip $hostname\"\n>\n>if ($hosts -match $find) {\n>    $hosts = $hosts -replace $find, $entry\n>}\n>else {\n>    $hosts = \"$hosts`n$entry\".Trim()\n>}\n>\n>try {\n>    $temp = \"$hostsPath.new\"\n>    New-Item -Path $temp -ItemType File -Force | Out-Null\n>    Set-Content -Path $temp $hosts\n>\n>    Move-Item -Path $temp -Destination $hostsPath -Force\n>}\n>catch {\n>    Write-Error \"cannot update wsl ip\"\n>}\n>```\n\n해당 글에서는 `wsl`이 처음 시작하고, 네트워크가 연결되는 이벤트에 반응하는 스케쥴을 생성해서 관리하는 방식으로 되어있는데, 이전 글인 `Distrod`와 같이 쓰려니 알 수 없는 에러가 발생했다.\n\n`wsl`으로 지속적인 서비스를 띄워놓을 생각은 없으므로, 터미널 접근시 실행하는 스크립트를 하나 작성하기로 했다.\n\n```bash {filename=hosts.sh}\n#!/usr/bin/env bash\n\nwsl_host_name=wslhost\nwin_ps1='c:\\\\wsl\\\\remote-port-hosts.ps1'\n\nip_pattern='([0-9]{1,3}\\.){3}[0-9]{1,3}'\nwin_hosts='/mnt/c/Windows/System32/drivers/etc/hosts'\npowershell_cmd='Start-Process powershell -verb runas -ArgumentList '\\\n'\"-ExecutionPolicy Bypass -File '${win_ps1}'\"'\n\n# windows의 hosts에 작성되어 있는 wsl ip\nwin_hosts_ip=`cat ${win_hosts} | \\\n    grep ${wsl_host_name} | \\\n    egrep -o ${ip_pattern}`\n# linux의 hosts에 작성되어 있는 wsl ip\nlinux_hosts_ip=`cat /etc/hosts | \\\n    grep ${wsl_host_name} | \\\n    egrep -o ${ip_pattern}`\n# wsl이 실제로 실행되고 있는 ip\nreal_ip=`ip addr | \\\n    awk '/inet/ && /eth0/' | \\\n    awk '{print $2}' | \\\n    egrep -o ${ip_pattern}`\n\nif [ ${win_hosts_ip} == $real_ip ] && \\\n    [ $linux_hosts_ip == $real_ip ]; then\n    exit 0\nfi\n\n# 관리자권한 파워쉘을 실행하여 hosts파일 수정\necho run cmd to change windows hosts\npowershell.exe ${powershell_cmd}\n# 관리자권한으로 wsl의 hosts를 수정\necho change /etc/hosts\nsudo sed -i s/${linux_hosts_ip}/${real_ip}/g /etc/hosts\nexit 0\n```\n\n이제 위 스크립트를 ```.zshrc```와 같은 곳에서 실행하도록 설정하면 된다.\n\n이 스크립트가 정상적으로 실행된다면, 이제 `localhost`대신 `wslhost`로 `wsl`에서 실행한 서비스에 접근할 수 있게 된다.\n\n# 아쉽다\n`wsl`내에서 윈도우의 `hosts` 파일을 수정할 수 있다면 훨씬 간단했지만, 쓰기 권한을 얻을 방법이 보이지 않아 일단 돌아서 처리하기로 했다.\n\n좀 더 깔끔한 방법을 찾는다면 새로 포스팅하자.\n","mtime":"2022-08-20T23:27:38.285+09:00","href":"other/wsl2를 localhost로 연결할 수 없을 때","data":{"title":"wsl2를 localhost로 연결할 수 없을 때","tags":["windows","wsl","@all"],"page":null,"summary":"hosts 파일을 수정할 수 있게 만들자","date":"2022-08-20T22:40:09.881+09:00"}},{"name":"wsl2에서 pid 1을 systemd로 변경하기","content":"\n# `systemd`로 인한 에러\n`wsl2`(이하 `wsl`)를 그냥 실행할 경우, 다음과 같은 에러를 겪을 때가 있다.\n```bash\nSystem has not been booted with systemd as init system (PID 1). Can't operate.\n```\n\n이는 pid 1번이 `systemd` 가 아니어서 생기는 문제로, 해결하기 위해서는 [genie](https://github.com/arkane-systems/genie)와 같은 별도의 프로그램을 실행해줘야 했다. 하지만 최근 처음부터 이를 해결한 상태로 wsl을 실행하는 프로젝트를 발견했는데, 바로 [Distrod](https://github.com/nullpo-head/wsl-distrod)다.\n\n# `Distrod`를 사용하자\n`Distrod`를 설치하는 방법은 크게 두가지로 나뉘는데,\n하나는 이미 해당 패치가 적용된 배포판을 사용하거나,\n기존에 사용하던 `wsl`환경에 해당 패치를 적용하는 것이다.\n\n## 신규 설치\n[링크](https://github.com/nullpo-head/wsl-distrod/releases/latest/download/distrod_wsl_launcher-x86_64.zip)의 압축 파일을 해제하면, 단일 exe 파일이 존재하는데, 해당 실행 파일을 실행시키면 끝이다.\n\n굉장히 다양한 배포판(아치, 데비안, 젠투, 보이드 등)을 지원하기에, 대부분의 경우, 선택권을 제한당한다는 기분은 느끼지 못할 것이다.\n\n## 기존 환경에 패치\n이것 또한 아주 간단하다. \n1. 패치 스크립트를 다운로드 한 다음, 실행한다.(아직 적용되지 않았다.)\n```bash\ncurl -L -O \"https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh\"\nchmod +x install.sh\nsudo ./install.sh install\n```\n\n2. wsl이 처음 실행됐을 때, 다음 명령어를 관리자 권한으로 실행하던가,\n```bash\n/opt/distrod/bin/distrod enable\n```\n3. 또는 다음 명령어로 윈도우 스케쥴러에 자동으로 해당 패치가 정상적으로 실행될 수 있도록 한다.\n```bash\n/opt/distrod/bin/distrod enable --start-on-windows-boot\n```\n\n이제 ```ps -ef | head -n 2```으로 확인해보면,\n```bash\nUID          PID    PPID  C STIME TTY          TIME CMD\nroot           1       0  0 21:34 ?        00:00:00 /sbin/init systemd.setenv=WSL_DISTRO_NAME=Distrod systemd.setenv=WSL_INTEROP=/run/WSL/11_interop systemd.setenv=WSLENV=WT_SESSION::WT_PROFILE_ID --unit=multi-user.target\n```\n위와 같이 `distrod`의 패치가 적용된 것을 확인할 수 있다.\n\n## 윈도우11은 주의\n`distrod`의 기능 중, `wsl`의 특정 포트를 외부로 포워딩 할 수 있는 `portproxy`라는 서비스가 있는데, 윈도우 11에서는 정상적으로 작동하지 않는 [버그](https://github.com/nullpo-head/wsl-distrod/blob/main/docs/references.md#know-bugs)가 있다고 한다.\n","mtime":"2022-08-20T22:17:59.496+09:00","href":"other/wsl2에서 pid 1을 systemd로 변경하기","data":{"title":"wsl2에서 pid 1을 systemd로 변경하기","tags":["windows","wsl","@all"],"page":null,"summary":"잘 만들어놓은 배포판을 가져다 쓰자","date":"2022-08-14T22:13:27.850+09:00"}}]},"__N_SSG":true}