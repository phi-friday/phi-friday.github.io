{"pageProps":{"tag":"python","page":2,"max_page":5,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## 토큰 발행 방식 수정\n\n### 기존 코드 수정\n\n이전에 토큰 발행 api를 직접 작성했는데, 좀 더 알아보니, **`fastapi-users`** 에서 제공하는 `login` api와 동일하다. 따라서 토큰 발행과 관련해서 약간의 수정을 진행한다.\n\n> #### backend/app/core/config.py\n>\n> 토큰 경로 수정\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token/login\"\n```\n\n---\n\n`AUTH_BACKEND_NAME` 추가\n\n```python\nAUTH_BACKEND_NAME = config(\n    \"AUTH_BACKEND_NAME\", cast=str, default=f\"{JWT_TOKEN_PREFIX}-jwt\"\n)\n```\n\n> #### backend/app/services/authentication.py\n>\n> 토큰 모델 제거\n\n```python\n# class token_model(BaseModel):\n#     access_token: str\n#     token_type: str = config.JWT_TOKEN_PREFIX\n>\n#     @classmethod\n#     def from_token(cls, token: str) -> \"token_model\":\n#         return cls(access_token=toke\n```\n\n---\n\n`AUTH_BACKEND_NAME` 참조 추가\n\n```python\ndef create_backend() -> list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n```\n\n> #### backend/app/api/routes/token.py\n>\n> **`fastapi-users`** 라우터 추가\n> 편의상 당분간 `requires_verification=False`로 한다.\n\n```python\n# name: auth:{backend.name}.login\nrouter.include_router(\n    fastapi_user.users.get_auth_router(\n        fastapi_user.backends[0], requires_verification=False\n    )\n)\n```\n\n---\n\n기존 api 제거\n\n```python\n# @router.post(\"\", name=\"users:create-token\")\n# async def create_token(\n#     credentials: OAuth2PasswordRequestForm = Depends(),\n#     user_manager: user_manager_type = fastapi_user.user_manager_depends,\n#     strategy: strategy_type = fastapi_user.strategy_depends(),\n# ) -> token_model:\n#     get_user = await user_manager.authenticate(credentials)\n#     if get_user is None or not get_user.is_active:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n#         )\n#     if not get_user.is_verified:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n#         )\n>\n#     token = await strategy.write_token(get_user)\n#     return token_model.from_token(token)\n```\n\n> #### backend/tests/test_users.py\n>\n> `api_name` 수정\n\n```python\nclass TestAuthTokens:\n    api_name = f\"auth:{config.AUTH_BACKEND_NAME}.login\"\n```\n\n### **`fastapi-users`** 가 제공하는 `api`의 검증 방식\n\n> 현재 사용중인 **`fastapi-users`** 의 버전은 `9.3.1`이라는 것에 유의한다.\n\n우선 이메일을 기준으로 유저를 조회 한 다음, 비밀번호를 검증한다.\n그리고 해당 유저 레코드의 `is_active`가 `True`인지 확인하고, `requires_verification` 값에 따라 `is_verified`가 `True`인지 확인한다.\n\n유저가 존재하지 않거나, `is_active=False`이거나, `requires_verification=True`이면서 `is_verified=False`인 경우 에러(400)을 반환한다.\n\n## `TDD` 방법론에 따른 로그인 `api`\n\n### 일반적인 로그인 방식\n\n| 사용자                             | 프론트엔드                                    | 백엔드                         |\n| ---------------------------------- | --------------------------------------------- | ------------------------------ |\n| `name`, `password` 입력            |                                               |                                |\n|                                    | `name`, `password` 백엔드로 전송              |                                |\n|                                    |                                               | `name`, `password` 유효성 검사 |\n|                                    |                                               | 토큰 생성                      |\n|                                    |                                               | 토큰 프론트엔드로 전송         |\n|                                    | 토큰 임시 저장                                |\n| 로그인이 필요한 특정 페이지로 이동 |                                               |                                |\n|                                    | 저장된 토큰(Authorization 헤더) 백엔드로 전송 |                                |\n|                                    |                                               | 토큰 유효성 검사               |\n|                                    |                                               | 컨텐츠 전송                    |\n| ...                                | ...                                           | ...                            |\n\n### 로그인 테스트 코드 작성\n\n```python\n# backend/tests/test_users.py\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n(...)\n\nclass TestUserLogin:\n    api_name = \"users:login-email-and-password\"\n\n    async def test_user_can_login_successfully_and_receives_valid_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        login_data = {\"email\": test_user.email, \"password\": \"heatcavslakers@1\"}\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status.HTTP_200_OK\n        # check that token exists in response and has user encoded within it\n        token = res.json().get(\"access_token\")\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n            manager = UserManager(db)\n\n            read_user: user.user_model | None = await strategy.read_token(\n                token, manager\n            )\n        assert read_user is not None\n        assert read_user.name == test_user.name\n        assert read_user.email == test_user.email\n        # check that token is proper type\n        assert \"token_type\" in res.json()\n        assert res.json().get(\"token_type\") == \"bearer\"\n\n    @pytest.mark.parametrize(\n        \"credential, wrong_value, status_code\",\n        (\n            (\"email\", \"wrong@email.com\", 401),\n            (\"email\", None, 401),\n            (\"email\", \"notemail\", 401),\n            (\"password\", \"wrongpassword@1\", 401),\n            (\"password\", None, 401),\n        ),\n    )\n    async def test_user_with_wrong_creds_doesnt_receive_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        credential: str,\n        wrong_value: str,\n        status_code: int,\n    ) -> None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        user_data = test_user.dict()\n        user_data[\"password\"] = \"heatcavslakers@1\"\n        user_data[credential] = wrong_value\n        login_data = {\n            \"username\": user_data[\"email\"],\n            \"password\": user_data[\"password\"],  # insert password from parameters\n        }\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status_code\n        assert \"access_token\" not in res.json()\n```\n\n사용자가 `email`과 `password`를 올바르게 보냈을 때 얻게 되는 토큰으로 부터, **`fastapi_users`** 를 이용해서 불러온 유저 레코드가 `test_user`와 일치하는지 확인한다.\n\n여기서 로그인의 경우 `json` 파라미터가 아닌 `data` 파라미터로 데이터를 전송하고, `content-type` 헤더로 `application/x-www-form-urlencoded`를 가지고 있어야 한다는 점에 유의한다.\n\n### 로그인 `api` 작성\n\n토큰 발행 api가 로그인 api이므로, 따로 작성할 필요가 없다.\n만약 400에러가 아닌 401에러를 반환하고 싶다면, 이전 챕터처럼 직접 작성하면 된다.\n\n### 인증 `Depends` 생성\n\n이제 토큰을 발급받은 경우에만 사용이 가능한 api에 대한 인증 절차를 정의해야한다. **`fastapi`** 에서는 이러한 기능은 `Depends`를 사용해서 생성할 수 있다. 또한, **`fastapi-users`** 에서 관련된 함수를 이미 만들어서 제공하고 있다. 우선 테스트 코드부터 작성한다.\n\n```python\n# backend/tests/conftest.py\nfrom app.services.authentication import create_strategy\nfrom sqlmodel import select\n\n(...)\n\n@pytest.fixture\nasync def authorized_client(\n    client: AsyncClient, test_user: user.user_model\n) -> AsyncClient:\n    from app.core import config\n\n    strategy = create_strategy()\n    access_token = await strategy.write_token(user=test_user)  # type: ignore\n\n    client.headers[\"Authorization\"] = f\"{config.JWT_TOKEN_PREFIX} {access_token}\"\n    return client\n```\n\n방금 작성한 `authorized_client`를 이용해서 인증이 필요한 라우터에 접근이 가능하다.\n\n> 쓰다보니 `user.user`와 `user.user_model`이 따로 있는게 너무 불편한데, 언제 한번 합치는 시도를 해봐야 할듯. `AsyncSession` 관련해서도 언제한번 해결을 해야할 것 같고..\n\n```python\n# backend/tests/test_users.py\n(...)\n\nclass TestUserMe:\n    api_name = \"users:get-current-user\"\n\n    async def test_authenticated_user_can_retrieve_own_data(\n        self,\n        app: FastAPI,\n        authorized_client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await authorized_client.get(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_200_OK\n        res_dict: dict = res.json()\n        res_dict[\"hashed_password\"] = \"testpassword@1\"\n        read_user = user.user_model.validate(res_dict)\n        assert read_user.email == test_user.email\n        assert read_user.name == test_user.name\n        assert read_user.id == test_user.id\n\n    async def test_user_cannot_access_own_data_if_not_authenticated(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n    ) -> None:\n        res = await client.get(app.url_path_for(\"users:get-current-user\"))\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n\n    @pytest.mark.parametrize(\n        \"jwt_prefix\",\n        (\n            (\"\",),\n            (\"value\",),\n            (\"Token\",),\n            (\"JWT\",),\n            (\"Swearer\",),\n        ),\n    )\n    async def test_user_cannot_access_own_data_with_incorrect_jwt_prefix(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        jwt_prefix: str,\n    ) -> None:\n        token = await strategy.write_token(test_user)\n        res = await client.get(\n            app.url_path_for(\"users:get-current-user\"),\n            headers={\"Authorization\": f\"{jwt_prefix} {token}\"},\n        )\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n```\n\n위 테스트를 통과할 수 있는 api를 작성한다.\n\n```python\nfrom fastapi import Depends\n\n(...)\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\n\n(...)\n\n@router.get(\"/me\", response_model=user.user_read, name=\"users:get-current-user\")\nasync def get_currently_authenticated_user(\n    current_user: user.user = Depends(get_current_user),\n) -> user.user_model:\n    return current_user.to_model()\n```\n\n`optional=False, active=True, verified=False, superuser=False`으로 값을 지정했기에, 해당 함수는 일치하는 유저가 없거나 `is_active` 값이 `False`이면 에러(401)을 반환한다.\n\n테스트 통과도 잘되고, **`swagger`** 에서도 확인이 간단한 api가 생성됐다. 유저 인증 관련해서는 사실상 이게 끝이다. 코드를 조금 더 정리할 수는 있지만 핵심은 비슷할 것이다.\n\n다음 챕터에서는 유저 프로필을 설정한다.\n그 전에 앞에서 언급한 유저 모델과 관련된 수정을 진행할 수도 있다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","data":{"title":"fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","date":"2022-05-06T06:26:51.932+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## 시작하기 전 변경사항\n\n이전 챕터에서 밝힌 것 처럼, 다소 난잡하다고 생각되는 부분 몇가지를 수정하자. 지금 수정한 부분이 나중에 원 예제에서 다른 방향으로 수정될 수도 있지만, 그때 가서 생각하자.\n\n> ### backend/app/core/config.py\n>\n> $\\rightarrow$ 1개 설정 변수 생성\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token\"\n```\n\n> ### backend/app/db/engine.py\n\n```python\nfrom ..core.config import DATABASE_URL\n```\n\n$\\rightarrow$ `core.config` 에서 값을 불러오는 방식으로\n\n```python\nfrom ..core import config\n```\n\n> ### backend/app/models/user.py\n\n```python\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n>\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n$\\rightarrow$ `unique=True`대신 `index=True`로 변경\n\n```python경\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n>\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n> ### backend/app/services/authentication.py\n\n```python\nfrom ..core.config import SECRET_KEY\n```\n\n$\\rightarrow$ `core.config` 에서 값을 불러오는 방식으로\n\n```python\nfrom ..core import config\n```\n\n---\n\n```python\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n```\n\n$\\rightarrow$ `models.user` 에서 모델을 불러오는 방식으로\n\n```python\nfrom ..models import user\n```\n\n---\n\n```python\nfrom pydantic import BaseModel\n>\n(...)\n>\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n>\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n>\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n```\n\n$\\rightarrow$ 새로 정의\n\n---\n\n```python\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n```\n\n$\\rightarrow$ `config.TOKEN_PREFIX` 설정 변수 참조\n\n```python\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n```\n\n---\n\n```python\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n>\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+<>@\\#$%&\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n>\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -> None:\n        if len(password) < self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) > self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n>\n        for pattern in self.re_password_deny_list:\n            if pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n>\n        for pattern in self.re_password_need_list:\n            if not pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n```\n\n$\\rightarrow$ 비밀번호 유효성 검사 로직 추가\n\n---\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n```\n\n$\\rightarrow$ 원래는 삭제하려 했으나, 특정 기능 추가 후 사용. 의존성이 마음에 들지 않지만, 사실상 설정용 객체라 일단 무시.\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n>\n    @property\n    def backends(self) -> Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n>\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n>\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n---\n\n끝으로, **`fastapi-users`** 의 각 클래스가 제네릭인 것을 확인해서, 이전에 정의한 유저 모델을 이용해서 타입 힌트를 추가했다. 이하 스크립트 전문\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\nfrom typing import AsyncGenerator, Sequence\n>\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom pydantic import BaseModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n>\nfrom ..core import config\nfrom ..db.session import get_session\nfrom ..models import user\n>\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n>\n>\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n>\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n>\n>\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n>\n>\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n>\n>\ndef create_strategy() -> Strategy[user.user_create, user.user]:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n>\n>\ndef create_backend() -> list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n>\n>\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n>\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n>\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n>\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n>\n>\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -> AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n>\n>\ndef create_fastapi_users(\n    *backends: AuthenticationBackend[user.user_create, user.user],\n) -> FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user.user_base,\n        user_create_model=user.user_create,\n        user_update_model=user.user_update,\n        user_db_model=user.user,\n    )\n>\n>\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n>\n    @classmethod\n    def init(cls) -> \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n>\n    @property\n    def backends(self) -> Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n>\n    @property\n    def user_manager_depends(self) -> user_manager_type:\n        return Depends(self.users.get_user_manager)\n>\n    def strategy_depends(self, num: int = 0, /) -> strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n> ### backend/app/services/token.py\n\n#### 위치 변경\n\n`backend/app/services/token.py`\n$\\rightarrow$ `backend/app/api/routes/token.py`\n\n---\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ 클래스 이름 변경에 따른 수정\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import HTTP_400_BAD_REQUEST\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```pyhon\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom fastapi_users import models\n>\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -> dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n>\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n$\\rightarrow$ 최상위 엔드포인트 사용 + `user_manager_type`, `strategy_type`, `token_model` 사용\n\n```python\nfrom ...services.authentication import strategy_type, token_model, user_manager_type\n>\n(...)\n>\n@router.post(\"\", name=\"users:create-token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n    strategy: strategy_type = fastapi_user.strategy_depends(),\n) -> token_model:\n    get_user = await user_manager.authenticate(credentials)\n    if get_user is None or not get_user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not get_user.is_verified:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n>\n    token = await strategy.write_token(get_user)\n    return token_model.from_token(token)\n```\n\n> ### backend/app/api/routes/cleanings.py\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ 클래스 이름 변경에 따른 수정\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```python\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom ...models.cleaning import (\n    cleaning_create,\n    cleaning_public,\n    cleaning_update,\n    cleanings,\n)\n```\n\n$\\rightarrow$ `models.cleaning` 에서 모델을 불러오는 방식으로\n\n```python\nfrom ...models import cleaning\n```\n\n> ### backend/app/api/routes/\\_\\_init\\_\\_.py\n\n```python\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n$\\rightarrow$ `auth` 대신 `token`으로 단일화\n\n```python\nrouter.include_router(token_router, prefix=\"/token\", tags=[\"token\"])\n```\n\n> ### backend/tests/conftest.py\n\n```python\n@pytest.fixture(\n    params=[pytest.param((\"asyncio\", {\"use_uvloop\": True}), id=\"asyncio+uvloop\")]\n)\ndef anyio_backend(request):\n    return request.param\n```\n\n$\\rightarrow$ **`pytest`** 백엔드로 **`anyio+uvloop`** 를 사용하기 위한 설정 추가\n\n> ### backend/tests/test_cleanings.py\n\n```python\npytestmark = pytest.mark.asyncio\n```\n\n$\\rightarrow$ **`pytest`** 백엔드로 **`anyio+uvloop`** 를 사용하기 위한 설정 추가\n\n```python\npytestmark = pytest.mark.anyio\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```python\nfrom fastapi import status\n```\n\n> ### 신규 생성) backend/pytest.ini\n\n```bash\n❯ touch backend/pytest.ini\n```\n\n```yaml\n[pytest]\nfilterwarnings =\n    ignore::sqlalchemy.exc.SAWarning\n```\n\n$\\rightarrow$ **`sqlalchemy`** 에서 보내는 경고를 **`pytest`** 에서 출력하지 않도록 설정\n\n위 수정에서 확인할 수 있듯이, **`pytest`** 백엔드로 **`anyio`** 를 쓰기 때문에, **`pytest-asyncio`** 는 이제 필요가 없으므로 제거한다.\n\n```bash\n❯ poetry remove --dev pytest-asyncio\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ docker-compose build\n```\n\n깜박하고 넘어간 경우가 있을텐데, 테스트 코드를 실행해보면 금방 수정할 수 있다.\n\n## `TDD` 방법론에 따른 유저 생성 `api` 만들기\n\n### 라우터 존재 확인\n\n원 예제의 **jeffastor**는 회원가입 api에 요청을 보내고 에러 코드를 확인하는 방식으로 만들었지만, 최근에 **RESTful** api 생성과 관련해서 [좋은 글](https://sanghaklee.tistory.com/57)을 확인했기에, **OPTIONS** api로 대신하고자 한다.\n\n```bash\n❯ touch backend/tests/test_users.py\n```\n\n```python\n# backend/tests/test_users.py\nimport pytest\nfrom fastapi import FastAPI, status\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.anyio\n\n\nclass TestUserRoutes:\n    api_name = \"users:get-allowed-methods\"\n\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.options(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_204_NO_CONTENT\n        assert not res.content\n        headers = res.headers\n        assert \"Allow\" in headers\n        allowed_methods_str = headers[\"Allow\"]\n        allowed_methods = {\n            method_str.strip().lower() for method_str in allowed_methods_str.split(\",\")\n        }\n        assert len(allowed_methods) > 0\n        for method_str in (\"post\",):\n            assert method_str in allowed_methods\n```\n\n테스트를 실행해보면 당연히 에러가 나온다.\n\n```bash\nroot@90b2a10bcb6d:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py F                                                                                 [100%]\n\n================================================= FAILURES ==================================================\n_____________________________ TestUserRoutes.test_routes_exist[asyncio+uvloop] ______________________________\ntests/test_users.py:10: in test_routes_exist\n    res = await client.options(app.url_path_for(\"users:get-allowed-methods\"))\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: in url_path_for\n    raise NoMatchFound()\nE   starlette.routing.NoMatchFound\n----------------------------------------- Captured stderr teardown ------------------------------------------\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\n========================================== short test summary info ==========================================\nFAILED tests/test_users.py::TestUserRoutes::test_routes_exist[asyncio+uvloop] - starlette.routing.NoMatchF...\n======================================= 1 failed, 39 passed in 4.52s ========================================\n```\n\n이제 에러를 해결하기 위한 라우터를 생성한다.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter, Response, status\n\nfrom ...services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.options(\"\", name=\"users:get-allowed-methods\")\nasync def get_allowed_user_methods() -> Response:\n    from functools import reduce\n\n    method_sets = [getattr(route, \"methods\") for route in router.routes]\n    all_methods = reduce(lambda left, right: left | right, method_sets, set())\n    all_methods_str = \", \".join(all_methods)\n\n    return Response(\n        status_code=status.HTTP_204_NO_CONTENT, headers={\"Allow\": all_methods_str}\n    )\n\n\n@router.post(\"\")\nasync def post_temp():\n    ...\n```\n\n임시로 가짜 **POST** api를 정의했기에, 테스트를 실행해도 에러가 발생하지 않는다.\n\n```bash\nroot@96deef95611e:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py .                                                                                 [100%]\n\n============================================ 40 passed in 4.03s =============================================\n```\n\n### 회원가입\n\n우선, 기존에 작성했던 유저 모델에 대해 이메일로 검색할 수 있는 메소드를 하나 생성한다. 관련해서 종종 쓰이기 때문.\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar, cast\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlmodel.sql.expression import Select\n\n(...)\n\n_T = TypeVar(\"_T\", bound=\"user_model\")\n\n(...)\n\nclass user(user_base, models.BaseUserDB):\n    def to_model(self) -> \"user_model\":\n        return user_model.validate(self)\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: AsyncSession, email: str\n    ) -> _T | None:\n        is_user_cur = await session.exec(\n            cast(Select[_T], select(cls).where(cls.email == email))\n        )\n        return is_user_cur.first()\n```\n\n> 아직 **`sqlmodel`** 의 `async` 지원이 부족해서, `typing.cast`를 이용해서 `Select` 타입으로 강제해서 사용했다.\n\n> `user`와 `user_model`을 하나로 합칠 수 있을 것 같은데, 이건 나중에 시간내서 확인해볼 생각.\n\n이제 **`fastapi-users`** 를 사용할 때가 왔다. 우선 테스트 코드부터 작성한다.\n\n```python\n# backend/tests/test_users.py\nfrom app.models import user\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\nclass TestUserRegistration:\n    api_name = \"users:register-new-user\"\n\n    async def test_users_can_register_successfully(\n        self, app: FastAPI, client: AsyncClient, engine: AsyncEngine\n    ) -> None:\n        new_user = {\n            \"email\": \"shakira@shakira.io\",\n            \"name\": \"shakirashakira\",\n            \"password\": \"chantaje@1\",\n        }\n        # make sure user doesn't exist yet\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is None\n        # send post request to create user and ensure it is successful\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status.HTTP_201_CREATED\n        # ensure that the user now exists in the db\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is not None\n        assert is_user.email == new_user[\"email\"]\n        assert is_user.name == new_user[\"name\"]\n        # check that the user returned in the response is equal to the user in the database\n        created_user = user.user_model.validate(\n            res.json() | {\"hashed_password\": \"whatever\"}\n        )\n        exclude_attr_set = user.user_model.datetime_attrs | {\"id\", \"hashed_password\"}\n        assert created_user.dict(exclude=exclude_attr_set) == is_user.dict(\n            exclude=exclude_attr_set\n        )\n\n    @pytest.mark.parametrize(\n        \"attr, value, status_code\",\n        (\n            (\"email\", \"shakira@shakira.io\", 400),\n            (\"name\", \"sha\", 422),\n            (\"name\", \"shafasdfsdwerewfsdfxcvxcvxcv\", 422),\n            (\"email\", \"invalid_email@one@two.io\", 422),\n            (\"password\", \"short\", 422),\n            (\n                \"password\",\n                (\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                ),\n                422,\n            ),\n            (\"password\", \"pattern@\", 422),\n            (\"name\", \"shakira@#$%^<>\", 422),\n            (\"name\", \"ab\", 422),\n        ),\n    )\n    async def test_user_registration_fails_when_credentials_are_taken(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        attr: str,\n        value: str,\n        status_code: int,\n    ) -> None:\n        new_user = {\n            \"email\": \"nottaken@email.io\",\n            \"name\": \"not_taken_username\",\n            \"password\": \"freepassword@1\",\n        }\n        new_user[attr] = value\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status_code\n```\n\n이제 위 테스트 코드를 통과할 수 있을 것 같은 api를 생성한다.\n\n```python\nimport re\n\nimport orjson\nfrom fastapi import Body, HTTPException, Request\nfrom fastapi_users.manager import InvalidPasswordException, UserAlreadyExists\nfrom pydantic import ValidationError\n\nfrom ...models import user\nfrom ...services.authentication import user_manager_type\n\n(...)\n\nre_deny_name = re.compile(r\"[^a-zA-Z0-9_-]\")\n\n(...)\n\n@router.post(\n    \"\",\n    name=\"users:register-new-user\",\n    response_model=user.user_read,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def register_new_user(\n    request: Request,\n    new_user: user.user_create = Body(..., embed=True),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n):\n    if re_deny_name.search(new_user.name):\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=(\n                \"The name can only contain the following characters: \"\n                f\"{re_deny_name.pattern.replace('^','')}\"\n            ),\n        )\n\n    try:\n        return await user_manager.create(new_user, safe=True, request=request)\n    except UserAlreadyExists as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=(\n                \"That email is already taken. \"\n                \"Login with that email or register with another one.\"\n            ),\n        )\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=orjson.loads(exc.json()),\n        )\n    except InvalidPasswordException as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=exc.reason,\n        )\n\n```\n\n> 따로 적지는 않았지만, **TDD** 방법론을 충실히 이행하면서 만들어진 테스트 코드와 api다.\n\n위 코드를 기반으로 테스트를 실행해보면, 모두 정상적으로 실행되는 것을 확인할 수 있다.\n\n### 토큰\n\n**`fastapi-users`** 덕분에 토큰 등에 대한 별다른 작업 없이 깔끔하게 끝났지만, 원 예제에서는 토큰과 관련된 몇가지 작업이 진행된다. 해당 과정 중 해보면 좋을 것 같은 부분만 따라서 진행한다.\n\n#### 토큰 관련 설정 수정 및 추가\n\n초기에 대충 작성해놨던 `SECRET_KEY` 등의 값을 지정해준다. 이 값을 직접 작성하기 보다는 그냥 터미널 명령어로 생성된 임의의 값을 사용하는 것이 좋다.\n\n```bash\n❯ openssl rand -hex 32\n```\n\n이제 이 값을 `.env` 파일에 추가하면 된다. 이 외에도 몇몇 값을 추가로 더 설정하는데 각 값은 다음과 같다.\n\n> `ACCESS_TOKEN_EXPIRE_SECONDS`: 토큰의 만료시간(초)\n> `JWT_ALGORITHM`: 토큰 암호화 알고리즘\n> `JWT_AUDIENCE`: 토큰 발급/수신 대상\n> `JWT_TOKEN_PREFIX`: 토큰 타입?(얘는 확실하지 않음)\n\n이제 `config.py`가 위 값을 잘 읽을 수 있게 수정한다.\n\n```python\n# backend/app/core/config.py\n(...)\n\nACCESS_TOKEN_EXPIRE_MINUTES = config(\n    \"ACCESS_TOKEN_EXPIRE_MINUTES\", cast=int, default=60 * 60\n)\nJWT_ALGORITHM = config(\"JWT_ALGORITHM\", cast=str, default=\"HS256\")\nJWT_AUDIENCE = config(\"JWT_AUDIENCE\", cast=str, default=\"phresh:auth\")\nJWT_TOKEN_PREFIX = config(\"JWT_TOKEN_PREFIX\", cast=str, default=\"Bearer\")\n\n(...)\n```\n\n그리고 이 값을 잘 참조할 수 있도록 수정한다.\n\n```python\n# backend/app/services/authentication.py\n(...)\n\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = config.JWT_TOKEN_PREFIX\n\n    @classmethod\n    def from_token(cls, token: str) -> \"token_model\":\n        return cls(access_token=token)\n\n(...)\n\ndef create_strategy() -> Strategy[user.user_create, user.user]:\n    return JWTStrategy(\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n(...)\n```\n\n테스트 코드에서 사용할 `fixture`를 정의한다. 중복 이메일을 허용하지 않기에 주의해서 작성한다.\n\n```python\n# backend/tests/conftest.py\nfrom app.models import user\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_user(engine: AsyncEngine) -> user.user_model:\n    new_user = user.user_create.parse_obj(\n        dict(\n            email=\"lebron@james.io\",\n            name=\"lebronjames\",\n            password=\"heatcavslakers@1\",\n        )\n    )\n\n    async with AsyncSession(engine, autocommit=False) as session:\n        db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n        manager = UserManager(db)\n\n        try:\n            new_user_db = await manager.get_by_email(new_user.email)\n        except UserNotExists:\n            new_user_db = await manager.create(new_user, safe=True)\n\n    return new_user_db.to_model()\n```\n\n이제 이 `fixture`를 이용해서 토큰을 발급받고, 검증하는 테스트 코드를 작성한다.\n\n> 2022.05.06. 아래 테스트 코드는 사실상 무의미하기에, 없어도 좋다. **TDD**에 익숙하지 않은 것도 있고, 원 예제의 내용과 다른 방식으로 api를 생성하다보니 헷갈려서 잘못 작성한 것 같다. 다음 챕터의 로그인 테스트 코드를 확인하자.\n\n```python\nclass TestAuthTokens:\n    api_name = \"users:create-token\"\n\n    async def test_can_create_access_token_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -> None:\n        access_token = await strategy.write_token(user=test_user)\n        creds = decode_jwt(\n            access_token,\n            str(config.SECRET_KEY),\n            [config.JWT_AUDIENCE],\n            [config.JWT_ALGORITHM],\n        )\n\n        assert creds.get(\"user_id\") is not None\n        user_id = creds[\"user_id\"]\n        assert config.JWT_AUDIENCE in creds[\"aud\"]\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            user_model = await session.get(user.user_model, user_id)\n        assert user_model is not None\n\n        assert user_model.name == test_user.name\n\n    async def test_token_missing_user_is_invalid(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(\n            url=app.url_path_for(self.api_name),\n            data={\"username\": \"unknown\", \"password\": \"testpassword@1\"},\n        )\n        assert res.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n```\n\n원 예제는 테스트 코드가 조금 더 풍부하지만, **`fastapi-users`** 를 사용중이기에, 불필요한 과정이라 생각됐다. 위 테스트 코드에서 `strategy`를 이용하여 직접 `access_token`을 생성해보기도 하고 복호화해보기도 하며, `access_token`로 부터 유저를 불러오기도 한다. 끝으로 이러한 과정이 진행되는 api를 호출해보기도 한다.\n\n테스트는 문제없이 잘 진행됐다.\n\n다음 챕터에서는 지금까지 만든 유저 api로 로그인 등을 시도한다. 참고로, 현재 선택한 전략으로는, 서버가 이미 발급한 토큰에 대해 처리가 불가능하므로, 로그아웃 기능을 생성할 수 없다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","data":{"title":"fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","date":"2022-05-05T06:13:07.421+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `cleanings`, `users` 모델 생성 및 수정\n\n시작부터 마이그레이션을 진행하길래 어떤건가 했더니, 이전에 작성했던 `cleanings` 테이블에 시간 속성(생성, 수정)을 sql 서버에서 자동으로 처리하도록 하는 트리거를 생성하는 과정이 있었다. sql 서버에서 직접 처리하는게 가장 간단한 방법이라고 한다. 일단 무시.\n\n이것과는 별개로, 이전에 마이그레이션 관련 코드 작성시 문제가 있는 형태로 작성한 것 같아서, 관련해서 조금 수정한다.\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -> None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\n이제 원 예제와 같이, 다운그레이드 후, 시간 속성부터 추가한 다음, 유저 관련 테이블을 설정하고 업그레이드를 실시한다. 원 예제와 순서를 맞춰가기 위해 약간 꼬인 느낌이 있는데, 지금 작성하는 유저 테이블은 **`fastapi-users`** 에서 작성하는 모델 형태를 따라간다.\n\n```bash\nroot@c62cf3d05043:/backend# alembic downgrade base\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running downgrade f721febf752b -> , create account table\n```\n\n### 시간 속성 관련 코어 모델 추가\n\n```python\n# backend/app/models/core.py\nfrom datetime import datetime\n\n(...)\n\n_D = TypeVar(\"_D\", bound=\"datetime_model\")\n\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -> _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def attrs(cls) -> set[str]:\n        return set(cls.__fields__.keys())\n```\n\n### 시간 속성 추가로 인한 기존 모델 변경점 대응 수정\n\n> 아래 내용은 단순히 시간 속성 추가로 인해 코드가 너무 나열돼있어서 접어놓고 싶지만 velog가 해당 기능을 지원하지 않는다.. velog에서 자동 생성된 목차를 선택해서 다음 항목으로 넘어갈 수 있다.\n\n```python\n# backend/app/models/cleaning.py\n(...)\n\nfrom .core import base_model, datetime_model, id_model\n\n(...)\n\nclass cleanings(id_model, datetime_model, cleaning_base, table=True):\n    name: str = Field(index=True)\n    cleaning_type: cleaning_type_enum = Field(\n        cleaning_type_enum.spot_clean,\n        sa_column_kwargs={\"server_default\": cleaning_type_enum.spot_clean},\n    )\n    price: price_decimal_type\n\n(...)\n```\n\n```python\n# backend/tests/test_cleaning.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\nimport orjson\nimport pytest\nfrom app.models.cleaning import cleaning_create, cleanings\nfrom app.models.core import datetime_model\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n# decorate all tests with @pytest.mark.asyncio\npytestmark = pytest.mark.asyncio\n\n\n@pytest.fixture\ndef new_cleaning():\n    return cleaning_create.parse_obj(\n        dict(\n            name=\"test cleaning\",\n            description=\"test description\",\n            price=0.00,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n\n\nclass TestCleaningsRoutes:\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -> None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCreateCleaning:\n    async def test_valid_input_creates_cleaning(\n        self, app: FastAPI, client: AsyncClient, new_cleaning: cleaning_create\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": orjson.loads(new_cleaning.json())},\n        )\n        assert res.status_code == HTTP_201_CREATED\n\n        created_cleaning = cleaning_create(**res.json())\n        assert created_cleaning == new_cleaning\n\n    @pytest.mark.parametrize(\n        \"invalid_payload, status_code\",\n        (\n            (None, 422),\n            ({}, 422),\n            ({\"name\": \"test_name\"}, 422),\n            ({\"price\": 10.00}, 422),\n            ({\"name\": \"test_name\", \"description\": \"test\"}, 422),\n        ),\n    )\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient, invalid_payload: dict, status_code: int\n    ) -> None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": invalid_payload},\n        )\n        assert res.status_code == status_code\n\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning.dict(exclude=datetime_model.attrs) == test_cleaning.dict(\n            exclude=datetime_model.attrs\n        )\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [\n            cleanings.validate(l).dict(exclude=datetime_model.attrs) for l in json\n        ]\n        assert test_cleaning.dict(exclude=datetime_model.attrs) in all_cleanings\n\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(test_cleaning.id),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -> None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -> None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -> None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n    from app.models.core import datetime_model\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\n이렇게 수정하면 추가, 수정 시간 속성을 문제없이 사용할 수 있다..\n큰 문제가 없다면 그냥 트리거를 이용하자.\n\n### `users` 모델 생성\n\n```bash\n❯ poetry add 'fastapi-users[sqlalchemy2]'\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ touch backend/app/models/user.py\n❯ docker-compose up --build\n```\n\n원 예제에서 **`JWT`** 를 사용하기에 따라간다.\n\n```python\n# backend/app/models/user.py\nfrom uuid import uuid4\n\nfrom fastapi_users import models\nfrom pydantic import UUID4, EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field\n\nfrom .core import base_model, datetime_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\nclass user_base(models.BaseUser, datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(models.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(models.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_read(user_base):\n    ...\n\n\nclass user(user_base, models.BaseUserDB):\n    ...\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n위 스크립트에서 정의한 모델은, **`pydantic`** 의 `BaseModel`을 상속받는, **`fastapi-users`** 에서 정의된 모델을 상속받아서 정의한다. 기본적으로 가지고 있는 속성은 다음과 같다.\n\n> `id` : `UUID`로 임의 생성\n> `email`: `xxx@yyy.zz`의 형태로 구성된 문자열\n> `is_active`: 해당 유저 레코드가 활성화된 상태인지 확인\n> `is_superuser`: 해당 유저가 관리자인지 확인\n> `is_verified`: 선택적으로 사용 가능한, 해당 유저에 대한 추가적인 검증 통과 여부를 확인. 흔히 이메일로 검증을 진행함.\n> `password`: 해당 유저가 로그인시 사용하는 비밀번호로, 실제 데이터베이스에는 `hashed_password` 속성으로 암호화 후 저장된다.\n\n추가적으로 필요한 속성이 있다던가, 제약사항이 있다면 위 스크립트와 같이 모델에 새로 정의를 해도 좋고, 이후 정의할 `UserManager` 클래스의 `on_after_register` 등의 메소드에 제약사항을 적용해도 된다.\n\n그리고 추가된 모델을 마이그레이션 설정에 추가한다.\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n\"\"\"create account table\n\nRevision ID: f721febf752b\nRevises:\nCreate Date: 2022-04-27 17:21:25.945460\n\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nimport sqlalchemy as sa\nfrom alembic import op\n\nsys.path.append(Path(__file__).resolve().parents[4].as_posix())\nfrom app.models.cleaning import cleanings\nfrom app.models.core import datetime_model\nfrom app.models.user import user_model\n\n# revision identifiers, used by Alembic.\nrevision = \"f721febf752b\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ncleanings_table = cleanings.get_table()\nusers_table = user_model.get_table()\n\n\ndef create_cleanings_table() -> None:\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        cleanings_table.name,\n        *[col for col in cleanings_table.columns if col.name in col_names]\n    )\n\n\ndef create_user_table() -> None:\n    col_names = {\n        \"id\",\n        \"name\",\n        \"hashed_password\",\n        \"email\",\n        \"is_active\",\n        \"is_superuser\",\n        \"is_verified\",\n    }.union(datetime_model.attrs)\n\n    op.create_table(\n        users_table.name, *[col for col in users_table.columns if col.name in col_names]\n    )\n\n\ndef upgrade():\n    create_cleanings_table()\n    create_user_table()\n\n\ndef downgrade():\n    op.drop_table(cleanings_table.name)\n    op.drop_table(users_table.name)\n```\n\n이제 드디어 마이그레이션을 할 준비가 끝났다.\n\n```bash\nroot@77f86a971288:/backend# alembic upgrade head\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -> f721febf752b, create account table\n```\n\n## `FastAPI-Users`\n\n원 예제에서는 이제 테스트 코드를 작성한다. 하지만 `fastapi-users`를 사용하기 위해서, 사전 작업이 몇가지 필요한데, 지금 진행하는 작업이 다음 챕터나 그 다음 챕터에 나오는 내용과 비슷할 수 있다..\n\n### 간단한 설명\n\n**`fastapi-users`** 의 설명에 따르면, **`fastapi-users`** 는 `Transport`와 `Strategy` 이 두가지를 조합해서 사용하는 방식이다. 지금 이 예제는 **`Bearer`** 와 **`JWT`** 를 조합해서 쓰는 방식이라고 생각할 수 있다.\n\n> - **`Bearer`** : `header`에 토큰을 저장\n> - **`JWT`** : `JSON`형태의 토큰을 암호화 하여 저장(토큰 발행 이후 서버에서 무효화 불가능). 자세한 설명은 [여기](https://jwt.io/introduction)에서 확인할 수 있다.\n\n### 인증 백엔드 설정\n\n인증과 관련한 모듈을 저장할 경로를 생성하고 백엔드부터 앞에서 간략하게 설명한 인증 백엔드부터 생성한다.\n\n```bash\n❯ mkdir backend/app/services\n❯ touch backend/app/services/__init__.py backend/app/services/authentication.py\n```\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ..core.config import SECRET_KEY\nfrom ..db.session import get_session\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n\n\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user, session, user_model)  # type: ignore\n\n\ndef create_transport() -> Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n\n\ndef create_strategy() -> Strategy:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n\n\ndef create_backend() -> list[AuthenticationBackend]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n\n\nclass UserManager(BaseUserManager[user_create, user]):\n    user_db_model = user\n    reset_password_token_secret = str(SECRET_KEY)\n    verification_token_secret = str(SECRET_KEY)\n\n    async def on_after_register(self, user: user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(user_db=Depends(get_user_db)):\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(*backends: AuthenticationBackend) -> FastAPIUsers:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user_base,\n        user_create_model=user_create,\n        user_update_model=user_update,\n        user_db_model=user,\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n\n    @classmethod\n    def init(cls) -> \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n\n```\n\n뭔가 많이 적었지만 실제로 직접 작성했다고 할만한건 데이터클래스 **`fastapi_user`** 정도 밖에 없다. 전부 **`fastapi-users`** 레퍼런스에 있는 내용이다.\n\n`UserManager` 와 `AuthenticationBackend` 인스턴스는 이후 계정과 관련된 작업을 할때 자주 사용된다.\n\n### 토큰 `api` 생성\n\n이제 토큰을 생성하는 api를 생성한다. 이 api의 엔드포인트는 `Transport`를 생성할 때 사용한 `tokenUrl`의 값과 일치해야한다.\n\n```python\n# backend/app/api/routes/token.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi_users import models\nfrom fastapi_users.authentication import Strategy\nfrom fastapi_users.manager import BaseUserManager\nfrom fastapi_users.router import ErrorCode\nfrom starlette.status import HTTP_400_BAD_REQUEST\n\nfrom .authentication import fastapi_user as fastapi_user_class\nfrom .authentication import get_user_manager\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -> dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n### 인증 백엔드 확인용 임시 `api` 생성\n\n이어서 인증 백엔드 설정이 잘 됐는지 확인해볼 임시 라우터를 생성한다. 실제로 사용할 생각은 아니고, 말 그대로 임시 확인용이다.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter\n\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\nrouter.include_router(\n    fastapi_user.users.get_auth_router(fastapi_user.backends[0]), prefix=\"/auth\"\n)\nrouter.include_router(fastapi_user.users.get_register_router(), prefix=\"/auth\")\nrouter.include_router(fastapi_user.users.get_verify_router(), prefix=\"/auth\")\n```\n\n```python\n# backend/api/routes/__init__.py\nfrom fastapi import APIRouter\n\nfrom .cleanings import router as cleanings_router\nfrom .token import router as token_router\nfrom .users import router as users_router\n\nrouter = APIRouter()\n\nrouter.include_router(cleanings_router, prefix=\"/cleanings\", tags=[\"cleanings\"])\nrouter.include_router(users_router, prefix=\"/users\", tags=[\"users\"])\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n이제 [http://localhost:8000/docs](http://localhost:8000/docs)에서 확인해보면 **`fastapi-users`** 에서 설정한 내용을 바탕으로 생성해놓은 유저 관련 api를 사용할 수 있다. 또한, 로그인시 생성되는 토큰을 헤더에 추가하면 **`swagger`** 에서 로그인을 시도해볼 수 있다.\n\n다음은 이번에 작성한 내용을 좀 더 다듬고, 이전까지 했던 방식으로 **TDD** 방법론에 따라 api를 생성할 생각이다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","data":{"title":"fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","date":"2022-05-03T01:35:06.494+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n아래 문제로 인해 해당 챕터를 진행하면서 이전 챕터의 글을 포함해서 수정하다 보니 제대로 수정이 된건지 아닌지 확인하기가 어렵다..\n어쩌면 [이곳](https://github.com/phi-friday/jeffastor_tutor)에서 코드를 확인하는게 도움이 될 수 있다.\n\n특히 이 챕터의 테스트 코드에 적용된 `Decimal`이나 `f-string`도 원래는 **TDD** 과정 중에서 적용한 것이지만, 이미 글 쓰는 흐름이 다 꼬여서 생략했다.\n\n---\n\n## `SQLModel`의 **validataion** 관련 해결\n\n[링크](https://velog.io/@phi0friday/sqlmodel-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-validation)와 같은 이유로 인해, **`sqlmodel`** 로 생성한 모델에 대한 전반적인 수정이 필요하므로, 아래와 같이 수정을 진행했다.\n\n```python\n# backend/app/models/core.py\nfrom typing import Any, TypeVar, cast\n\nfrom sqlmodel import Field, SQLModel, Table\n\n_T = TypeVar(\"_T\", bound=SQLModel)\n\n\nclass fix_return_type_model(SQLModel):\n    \"\"\"\n    sqlmodel에서 parse_obj 리턴값 정상적으로 수정하기 전까지 사용\n    +\n    validate 또한 같은 문제 있음\n    \"\"\"\n\n    @classmethod\n    def parse_obj(cls: type[_T], obj: Any, update: dict[str, Any] | None = None) -> _T:\n        return cast(_T, super().parse_obj(obj, update))\n\n    @classmethod\n    def validate(cls: type[_T], value: Any) -> _T:\n        return cast(_T, super().validate(value))\n\n\nclass base_model(fix_return_type_model):\n    @classmethod\n    def get_table(cls) -> Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n\n\nclass id_model(fix_return_type_model):\n    id: int | None = Field(None, primary_key=True)\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\nasync def create_new_cleaning(\n    new_cleaning: cleaning_create = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    # data = cleanings.from_orm(new_cleaning) 으로 해도 가능\n    # exclude_none=True, exclude_unset=True 옵션을 위해 parse_obj 사용\n    # sqlmodel table=True 관련 validation 문제로 인해 validate사용\n    data = cleanings.validate(\n        new_cleaning.dict(\n            exclude_none=True,\n            exclude_unset=True,\n        )\n    )\n    session.add(data)\n    await session.flush()\n    await session.commit()\n    await session.refresh(data)\n\n    return data\n```\n\n```python\n# backend/tests.py\n(...)\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning == test_cleaning\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.validate(l) for l in json]\n        assert test_cleaning in all_cleanings\n```\n\n---\n\n## `RESTful` `CRUD` `api` 생성\n\n**RESTful** 표준에 따라, 다음과 같이 엔드포인트를 생성하고자 한다.\n\n| 엔드포인트     | 메소드 | 설명                               |\n| :------------- | :----- | :--------------------------------- |\n| /cleaning      | POST   | 새로운 cleaning 레코드 생성        |\n| /cleaning/{id} | GET    | id에 해당하는 cleaning 레코드 호출 |\n| /cleaning      | GET    | 전체 cleaning 레코드 호출          |\n| /cleaning/{id} | PATCH  | id에 해당하는 cleaning 레코드 수정 |\n| /cleaning/{id} | PUT    | id에 해당하는 cleaning 레코드 교체 |\n| /cleaning/{id} | DELET  | id에 해당하는 cleaning 레코드 제거 |\n\n이전 챕터에서, 새로운 레코드를 생성하는 것과, 기존의 레코드를 `id`를 이용하여 호출하는, 두개의 엔드포인트를 생성했다. 다른 4가지 또한, **TDD** 방법론에 맞게 작성한다.\n\n> 원 예제에서 **jeffastor**는 **PATCH** api를 작성하지 않고 **PUT** api만 작성했다. 그런데 작동 방식을 보면 **jeffastor**가 작성한 **PUT** api는 **PATCH** api처럼 작동한다. 이와 관련해 약간의 수정이 함께 진행된다.\n\n### `GET` `api`\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]\n        assert test_cleaning in all_cleanings\n        assert test_cleaning in all_cleanings\n```\n\n이제 **`pytest`** 를 **`docker`** 컨테이너 내부에서 실행하면, 다음과 같은 에러를 확인할 수 있다.\n\n```bash\n(...)\n\n================================================= FAILURES ==================================================\n_______________________ TestGetCleaning.test_get_all_cleanings_returns_valid_response _______________________\n\nself = <tests.test_cleanings.TestGetCleaning object at 0x7feb2db9b370>\napp = <fastapi.applications.FastAPI object at 0x7feb2b01fd90>\nclient = <httpx.AsyncClient object at 0x7feb2b01e6e0>\ntest_cleaning = cleanings(name='fake cleaning name', price=Decimal('9.99'), id=3, description='fake cleaning description', cleaning_type='spot_clean')\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n>       res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n\ntests/test_cleanings.py:125:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <fastapi.routing.APIRouter object at 0x7feb2b01d180>, name = 'cleanings:get-all-cleanings'\npath_params = {}, route = <fastapi.routing.APIRoute object at 0x7feb2b045480>\n\n    def url_path_for(self, name: str, **path_params: str) -> URLPath:\n        for route in self.routes:\n            try:\n                return route.url_path_for(name, **path_params)\n            except NoMatchFound:\n                pass\n>       raise NoMatchFound()\nE       starlette.routing.NoMatchFound\n\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: NoMatchFound\n\n(...)\n```\n\n> 현재 설정으로는, `test_cleaning`을 사용할 때 마다 새로운 레코드를 생성하고 있다. 만약 `unique` 설정이 있다면 에러를 발생시킬 것이다. 이 문제는 이후 다룰 것이므로, 지금은 신경쓰지 않아도 된다고 **jeffastor**는 밝힌다.\n\n이제 테스트를 통과할 수 있도록, 라우터를 수정합니다. 정말 연습해보기 위해, 이후 내용은 제대로 읽지 않고 직접 코드를 작성해봤습니다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom typing import cast\nfrom sqlmodel import select\n\n(...)\n\n@router.get(\n    \"\", response_model=list[cleaning_public], name=\"cleanings:get-all-cleanings\"\n)\nasync def get_all_cleanings(\n    session: AsyncSession = Depends(get_session),\n) -> list[cleanings]:\n    # 아직 sqlmodel의 async session은 type hint와 관련해서 제대로 지원하지 않습니다.\n    # 제대로 작성된게 맞는지 확인해보고 싶다면,\n    # session.sync_session에서 type hint 관련해서만 확인해보면 됩니다.\n    #\n    # sync_session = session.sync_session\n    # table = sync_session.exec(select(cleanings))\n    # rows = table.all()\n    table = await session.exec(select(cleanings))  # type: ignore\n    rows = cast(list[cleanings], table.all())\n    return rows\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\n\n(...)\n```\n\n테스트 결과 통과했습니다.\n\n> 원 작성자 **jeffator**의 경우, **TDD**에 대해 익숙해지지 위해 처음에는 `None`을 반환하고, 그 다음에는 빈 리스트 `[]`를 반환하고, 그 다음에는 가짜 레코드 `[{ \"id\": 1, \"name\": \"fake cleaning\", \"price\": 0}]`를 반환하고, 끝으로 세션에 연결해서 레코드를 반환합니다.\n\n### `PUT` `api`...? `PATCH` `api`\n\n다음과 같이 테스트 코드를 추가합니다.\n\n```python\n# backend/tests/test_cleanings.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.put(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n첫번째는 **PUT** api가 의도한대로 작동하는지 확인하고, 두번째는 의도한대로 에러를 반환하는지 확인하는 메소드입니다.\n이제 위 테스트 코드를 통과할 수 있도록 **PUT** 메소드를 작성합니다.\n\n> 다만 위 테스트 코드에서 이해가 되지 않는 부분이 있는데,\n\n```python\n# make sure that no other attributes' values have changed\nfor attr, value in updated_cleaning.dict().items():\n    if attr not in attrs_to_change:\n        assert getattr(test_cleaning, attr) == value\n```\n\n> 이다. 이건 **PATCH** 아닌가? 일단 따라가본다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom pydantic import ValidationError\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    try:\n        cleanings.from_orm(update_cleaning)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n`update_cleaning`이 정상적인 `cleanings` 레코드를 생성할 수 있는지 확인하고, `id`에 해당하는 `cleanings` 레코드를 호출 한 다음, 해당 레코드의 값을 수정하고 커밋했다.\n\n테스트 실행결과 이상하다고 생각했던 부분이 맞았다.\n**`pytest`** 에 익숙하지 않아 처음에 알아보지 못한 문제인데,\n\n```python\nattrs_to_change = ['cleaning_type']\nvalues = ['full_clean']\n```\n\n다음과 같이 변수가 정의된다..\n따라서, 위 예제를 모두 **PUT**에서 **PATCH**로 변경 후 다시 진행한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.parse_obj(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n기존에 작성한 **PUT** api는 제거하지 않고 놔둔다. 마지막에 다시 사용할 것이다.\n\n테스트 결과 모두 정상적으로 통과했다.\n\n### `DELETE` `api`\n\n이어서 **DELETE** 테스트 코드와 api를 생성한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -> None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -> None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.delete(\"/{id}/\", response_model=int, name=\"cleanings:delete-cleaning-by-id\")\nasync def delete_cleaning_by_id(\n    id: int = Path(..., ge=1, title=\"The ID of the cleaning to delete.\"),\n    session: AsyncSession = Depends(get_session),\n) -> int:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    await session.delete(cleaning)\n    await session.flush()\n    await session.commit()\n\n    return id\n```\n\n테스트도 정상적으로 통과한다.\n\n```bash\ntests/test_cleanings.py::TestDeleteCleaning::test_can_delete_cleaning_successfully PASSED             [ 86%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[500-404] PASSED [ 90%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[0-422] PASSED [ 93%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[-1-422] PASSED [ 96%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[None-422] PASSED [100%]\n```\n\n> **DELETE**와 같은 api는 `status_code=204`와 함께 `contents`가 없는 `response`를 반환하는게 맞다고 한다. 현재는 적용하지 않는다.\n\n### `PUT` api\n\n원 예제는 여기서 끝이지만, 추가로 **PUT** api에 대해 직접 작성해본다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n나름 여러 과정을 거쳤는데, **`sqlmodel`** 관련 문제를 알아보다 보니 너무 꼬였다. 과정은 생략..\n\n다음은 마이그레이션 진행 후 유저 관련 설정을 추가하는 것 같다. 유저 관련해서는 **`fastapi-users`** 라는 좋은 라이브러리가 있으니, 원 예제와 같은 흐름이지만 **`fastapi-user`** 를 쓰는 쪽으로 진행할 예정.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","data":{"title":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","date":"2022-05-02T20:47:43.741+09:00","tags":["crud","fastapi","restful","tdd","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"sqlmodel 라이브러리 사용시 주의사항 - validation","content":"`sqlmodel`은 `fastapi`의 개발자 `tiangolo`의 주도 하에 개발이 진행중인 `sql`관련 라이브러리입니다. `pydantic`의 모델과 `sqlalchemy`의 테이블을 한번의 정의로 같이 쓸 수 있다는 장점이 있어서, 다소 불안정한 부분이 있더라도 종종 쓰고 있습니다.\n\n그런데 최근 아주 무서운 일을 확인했습니다.. `sqlmodel`로 정의한 모델에 `table=True`옵션을 주면 `pydantic`에서 자랑하는 검증 과정이 전혀 작동하지 않는다는 사실을..\n\n`from_orm`, `parse_obj` 이 두 메소드 모두 정상적으로 작동하지 않으니, `validate` 메소드를 이용해서 레코드를 생성하면 정상적으로 사용할 수 있는 것 같습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/sqlmodel 라이브러리 사용시 주의사항 - validation","data":{"title":"sqlmodel 라이브러리 사용시 주의사항 - validation","date":"2022-05-02T18:53:19.408+09:00","tags":["python","sqlmodel","@all"],"page":null,"summary":"sqlmodel에서 모델에 table=True 옵션을 주면 from_orm, parse_obj에서 validation 과정을 진행하지 않는다."}}]},"__N_SSG":true}