{"pageProps":{"tag":"python","page":5,"max_page":5,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"FastAPI, sqlmodel로 간단한 crud api 생성","content":"\n## 사용 라이브러리?프레임워크? 간단 소개\n\n### [FastAPI](https://fastapi.tiangolo.com/ko/)\n\npython type hint를 적극적으로 활용해서\n`rest api`를 만들때 생산성이 아주 좋습니다.\n`uvicorn`을 사용하기 때문에, `uvloop`로 성능도 준수해서 더욱 좋습니다.\n공식 [document](https://fastapi.tiangolo.com/ko/tutorial/)가 아주 잘 작성돼서 혼자 공부하기도 좋습니다.\n\n정말 좋으니까, `flask`를 써야할 일이 생긴다면 **꼭** `FastAPI`를 사용해보세요.\n\n### [SQLModel](https://sqlmodel.tiangolo.com/)\n\n`pydantic`과 `sqlalchemy`를 정교하게 섞어서 사용할 수 있도록 만든 라이브러리입니다.\n`FastAPI`와 작성자가 같습니다.\n`FastAPI`는 쿼리나 바디 등의 변수 타입 검증을 위해 `pydantic`을 사용하는데, `crud`용 테이블은 정작 `sqlalchemy`로 따로 작성해야해서 두번 작성하는 귀찮은 일이 많았습니다.\n`SQLModel`을 사용하면 그런 일이 없으니 편합니다.\n다만 아직 초기 개발 단계이고, 공식 [document](https://sqlmodel.tiangolo.com/tutorial/)도 그렇게 좋지는 않습니다.\n\n## api 작성 전 초기작업\n\npython 버전은 `3.9.9`를 사용합니다.\ndb는 `postgres`를 사용합니다.\n간단하게 만들 생각이기 때문에, 많이 설치하지 않습니다.\n`fastapi`, `uvicorn`, `email-validator`, `sqlmodel`, `asyncpg`\n이렇게 5개만 설치하겠습니다.\n\n`podman`를 간단하게나마 사용할 예정이기 때문에, `dockerfile`을 작성합니다.\n\n> `podman`을 사용하지만 `dockerfile`을 사용하는 것 처럼, 그냥 `docker`를 사용하셔도 아무 문제가 없습니다.\n>\n> > 저는 zshrc에 `podman`과 `podman-compose`를 각각 `docker`와 `docker-compose`로 alias설정했습니다.\n\n```\n# dockerfile\nFROM python:3.9-bullseye\n\nWORKDIR /api\n\nADD https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh /\nRUN [\"chmod\", \"+x\", \"/wait-for-it.sh\"]\n\nCOPY ./requirements.txt /requirements.txt\nRUN pip install --no-cache-dir --upgrade -r /requirements.txt\n```\n\n처음에 추가한 `wait-for-it.sh`는 db가 정상적으로 생성되고, 연결이 가능한지 확인하기 위한 쉘스크립트입니다.\n\n`wait-for-it.sh`를 다운로드 한 다음 실행권한을 주고,\n로컬에 존재하는 `requirements.txt`를 가져와서 pip로 필요한 패키지를 설치하는 간단한 구성의 `dockerfile`입니다.\n\n이어서 db와 api에서 사용할 환경변수를 `.env`파일로 작성합니다.\n\n```bash\n# .env\nPOSTGRES_USER=safeuser\nPOSTGRES_PASSWORD=s@fep@ssw0rd\nPOSTGRES_DB=restapi\nPOSTGRES_PORT=8081\n\nRESTAPI_PORT=8000\nRESTAPI_OUT_PORT=8000\nRESTAPI_DEBUG=1\n```\n\n순서대로, sql에서 사용할 아이디, 비밀번호, database이름, 포트,\n그리고 FastAPI가 실행될 포트, 도커 외부에서 api에 접속할 포트, 디버그 여부 플래그입니다.\n\n그리고 `docker-compose.yml`을 작성합니다.\n\n```yml\n# docker-compose.yml\nversion: '3'\n\nservices:\n  db:\n    image: postgres:latest\n    env_file:\n      - .env\n    command: -p ${POSTGRES_PORT}\n    volumes:\n      - ./db:/var/lib/postgresql/data\n\n  api:\n    build:\n      context: .\n      dockerfile: ./dockerfile\n    image: restapi:latest\n    env_file:\n      - .env\n    command:\n      - bash\n      - -c\n      - |\n        /wait-for-it.sh db:${POSTGRES_PORT} -t 10\n        python main.py\n    ports:\n      - '${RESTAPI_OUT_PORT}:${RESTAPI_PORT}'\n    depends_on:\n      - db\n    volumes:\n      - ./api:/api\n      - /etc/localtime:/etc/localtime:ro\n```\n\n컨테이너가 종료되더라도 db가 유지될 수 있게 로컬경로의 db폴더를 마운트 할 예정입니다. `docker volume`을 사용해도 되지만, 지금은 별로 중요한게 아닙니다.\n\n빌드되는 이미지 명은 별 생각없이 restapi라고 했습니다.\napi 컨테이너는 우선 db가 연결 가능한 상태인지 확인하고, 최대 10초간 대기합니다.\n연결이 가능하거나, 10초가 지나면, 현재 폴더의 `main.py`를 실행하도록 했습니다.\n\nvolumes에 작성된 것 처럼, 로컬 경로의 api폴더를 컨테이너 내부의 /api에 마운트했습니다.\n당연하게도, 로컬 경로의 api폴더에 FastAPI로 작성할 모든 결과물이 들어가게 됩니다.\n\n끝으로 실제로 실행할 `main.py`를 작성합니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef index():\n    return {\"hello\": \"world\"}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=int(environ[\"RESTAPI_PORT\"]),\n        reload=bool(int(environ[\"RESTAPI_DEBUG\"])),\n    )\n```\n\ndb를 생성하긴 하지만, 당장은 db와 관련된 작업을 하지 않겠습니다. 다음 글에서 이어서 하는걸로..\n\n정상적으로 따라오셨다면, 다음과 같은 구조입니다.\n\n```\n.\n├── .env\n├── api\n│   └── main.py\n├── db\n├── docker-compose.yml\n├── dockerfile\n└── requirements.txt\n```\n\n이제 실행해봅시다.\n`docker-compose up`으로 실행이 가능합니다.\n\n이제 http://localhost:8000 에 접속하면\n\n```python\n{\"hello\":\"world\"}\n```\n\n을 확인할 수 있습니다.\n\n작성된 api를 확인하기 위해\nhttp://localhost:8000/docs 에 접속하면\n다음과 같이 확인할 수 있습니다.\n![](/images/dbba2083-54d9-4406-89d2-dfc5b61cf360-docs.png)\n\n다음에는 `SQLModel`을 사용해서 모델을 만들고,\n그 모델을 이용한 간단한 형태의 `crud` api를 생성해보겠습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성","date":"2021-11-25T22:13:02.346+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"fastapi로 index만 구성하는 것 까지 진행"}}]},"__N_SSG":true}