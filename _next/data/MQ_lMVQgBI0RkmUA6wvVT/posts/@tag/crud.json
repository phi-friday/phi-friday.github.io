{"pageProps":{"tag":"crud","page":1,"max_page":1,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n아래 문제로 인해 해당 챕터를 진행하면서 이전 챕터의 글을 포함해서 수정하다 보니 제대로 수정이 된건지 아닌지 확인하기가 어렵다..\n어쩌면 [이곳](https://github.com/phi-friday/jeffastor_tutor)에서 코드를 확인하는게 도움이 될 수 있다.\n\n특히 이 챕터의 테스트 코드에 적용된 `Decimal`이나 `f-string`도 원래는 **TDD** 과정 중에서 적용한 것이지만, 이미 글 쓰는 흐름이 다 꼬여서 생략했다.\n\n---\n\n## `SQLModel`의 **validataion** 관련 해결\n\n[링크](https://velog.io/@phi0friday/sqlmodel-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-validation)와 같은 이유로 인해, **`sqlmodel`** 로 생성한 모델에 대한 전반적인 수정이 필요하므로, 아래와 같이 수정을 진행했다.\n\n```python\n# backend/app/models/core.py\nfrom typing import Any, TypeVar, cast\n\nfrom sqlmodel import Field, SQLModel, Table\n\n_T = TypeVar(\"_T\", bound=SQLModel)\n\n\nclass fix_return_type_model(SQLModel):\n    \"\"\"\n    sqlmodel에서 parse_obj 리턴값 정상적으로 수정하기 전까지 사용\n    +\n    validate 또한 같은 문제 있음\n    \"\"\"\n\n    @classmethod\n    def parse_obj(cls: type[_T], obj: Any, update: dict[str, Any] | None = None) -> _T:\n        return cast(_T, super().parse_obj(obj, update))\n\n    @classmethod\n    def validate(cls: type[_T], value: Any) -> _T:\n        return cast(_T, super().validate(value))\n\n\nclass base_model(fix_return_type_model):\n    @classmethod\n    def get_table(cls) -> Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n\n\nclass id_model(fix_return_type_model):\n    id: int | None = Field(None, primary_key=True)\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\nasync def create_new_cleaning(\n    new_cleaning: cleaning_create = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    # data = cleanings.from_orm(new_cleaning) 으로 해도 가능\n    # exclude_none=True, exclude_unset=True 옵션을 위해 parse_obj 사용\n    # sqlmodel table=True 관련 validation 문제로 인해 validate사용\n    data = cleanings.validate(\n        new_cleaning.dict(\n            exclude_none=True,\n            exclude_unset=True,\n        )\n    )\n    session.add(data)\n    await session.flush()\n    await session.commit()\n    await session.refresh(data)\n\n    return data\n```\n\n```python\n# backend/tests.py\n(...)\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -> cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning == test_cleaning\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -> None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.validate(l) for l in json]\n        assert test_cleaning in all_cleanings\n```\n\n---\n\n## `RESTful` `CRUD` `api` 생성\n\n**RESTful** 표준에 따라, 다음과 같이 엔드포인트를 생성하고자 한다.\n\n| 엔드포인트     | 메소드 | 설명                               |\n| :------------- | :----- | :--------------------------------- |\n| /cleaning      | POST   | 새로운 cleaning 레코드 생성        |\n| /cleaning/{id} | GET    | id에 해당하는 cleaning 레코드 호출 |\n| /cleaning      | GET    | 전체 cleaning 레코드 호출          |\n| /cleaning/{id} | PATCH  | id에 해당하는 cleaning 레코드 수정 |\n| /cleaning/{id} | PUT    | id에 해당하는 cleaning 레코드 교체 |\n| /cleaning/{id} | DELET  | id에 해당하는 cleaning 레코드 제거 |\n\n이전 챕터에서, 새로운 레코드를 생성하는 것과, 기존의 레코드를 `id`를 이용하여 호출하는, 두개의 엔드포인트를 생성했다. 다른 4가지 또한, **TDD** 방법론에 맞게 작성한다.\n\n> 원 예제에서 **jeffastor**는 **PATCH** api를 작성하지 않고 **PUT** api만 작성했다. 그런데 작동 방식을 보면 **jeffastor**가 작성한 **PUT** api는 **PATCH** api처럼 작동한다. 이와 관련해 약간의 수정이 함께 진행된다.\n\n### `GET` `api`\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) > 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]\n        assert test_cleaning in all_cleanings\n        assert test_cleaning in all_cleanings\n```\n\n이제 **`pytest`** 를 **`docker`** 컨테이너 내부에서 실행하면, 다음과 같은 에러를 확인할 수 있다.\n\n```bash\n(...)\n\n================================================= FAILURES ==================================================\n_______________________ TestGetCleaning.test_get_all_cleanings_returns_valid_response _______________________\n\nself = <tests.test_cleanings.TestGetCleaning object at 0x7feb2db9b370>\napp = <fastapi.applications.FastAPI object at 0x7feb2b01fd90>\nclient = <httpx.AsyncClient object at 0x7feb2b01e6e0>\ntest_cleaning = cleanings(name='fake cleaning name', price=Decimal('9.99'), id=3, description='fake cleaning description', cleaning_type='spot_clean')\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -> None:\n>       res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n\ntests/test_cleanings.py:125:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <fastapi.routing.APIRouter object at 0x7feb2b01d180>, name = 'cleanings:get-all-cleanings'\npath_params = {}, route = <fastapi.routing.APIRoute object at 0x7feb2b045480>\n\n    def url_path_for(self, name: str, **path_params: str) -> URLPath:\n        for route in self.routes:\n            try:\n                return route.url_path_for(name, **path_params)\n            except NoMatchFound:\n                pass\n>       raise NoMatchFound()\nE       starlette.routing.NoMatchFound\n\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: NoMatchFound\n\n(...)\n```\n\n> 현재 설정으로는, `test_cleaning`을 사용할 때 마다 새로운 레코드를 생성하고 있다. 만약 `unique` 설정이 있다면 에러를 발생시킬 것이다. 이 문제는 이후 다룰 것이므로, 지금은 신경쓰지 않아도 된다고 **jeffastor**는 밝힌다.\n\n이제 테스트를 통과할 수 있도록, 라우터를 수정합니다. 정말 연습해보기 위해, 이후 내용은 제대로 읽지 않고 직접 코드를 작성해봤습니다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom typing import cast\nfrom sqlmodel import select\n\n(...)\n\n@router.get(\n    \"\", response_model=list[cleaning_public], name=\"cleanings:get-all-cleanings\"\n)\nasync def get_all_cleanings(\n    session: AsyncSession = Depends(get_session),\n) -> list[cleanings]:\n    # 아직 sqlmodel의 async session은 type hint와 관련해서 제대로 지원하지 않습니다.\n    # 제대로 작성된게 맞는지 확인해보고 싶다면,\n    # session.sync_session에서 type hint 관련해서만 확인해보면 됩니다.\n    #\n    # sync_session = session.sync_session\n    # table = sync_session.exec(select(cleanings))\n    # rows = table.all()\n    table = await session.exec(select(cleanings))  # type: ignore\n    rows = cast(list[cleanings], table.all())\n    return rows\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\n\n(...)\n```\n\n테스트 결과 통과했습니다.\n\n> 원 작성자 **jeffator**의 경우, **TDD**에 대해 익숙해지지 위해 처음에는 `None`을 반환하고, 그 다음에는 빈 리스트 `[]`를 반환하고, 그 다음에는 가짜 레코드 `[{ \"id\": 1, \"name\": \"fake cleaning\", \"price\": 0}]`를 반환하고, 끝으로 세션에 연결해서 레코드를 반환합니다.\n\n### `PUT` `api`...? `PATCH` `api`\n\n다음과 같이 테스트 코드를 추가합니다.\n\n```python\n# backend/tests/test_cleanings.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.put(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n첫번째는 **PUT** api가 의도한대로 작동하는지 확인하고, 두번째는 의도한대로 에러를 반환하는지 확인하는 메소드입니다.\n이제 위 테스트 코드를 통과할 수 있도록 **PUT** 메소드를 작성합니다.\n\n> 다만 위 테스트 코드에서 이해가 되지 않는 부분이 있는데,\n\n```python\n# make sure that no other attributes' values have changed\nfor attr, value in updated_cleaning.dict().items():\n    if attr not in attrs_to_change:\n        assert getattr(test_cleaning, attr) == value\n```\n\n> 이다. 이건 **PATCH** 아닌가? 일단 따라가본다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom pydantic import ValidationError\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    try:\n        cleanings.from_orm(update_cleaning)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n`update_cleaning`이 정상적인 `cleanings` 레코드를 생성할 수 있는지 확인하고, `id`에 해당하는 `cleanings` 레코드를 호출 한 다음, 해당 레코드의 값을 수정하고 커밋했다.\n\n테스트 실행결과 이상하다고 생각했던 부분이 맞았다.\n**`pytest`** 에 익숙하지 않아 처음에 알아보지 못한 문제인데,\n\n```python\nattrs_to_change = ['cleaning_type']\nvalues = ['full_clean']\n```\n\n다음과 같이 변수가 정의된다..\n따라서, 위 예제를 모두 **PUT**에서 **PATCH**로 변경 후 다시 진행한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.parse_obj(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n기존에 작성한 **PUT** api는 제거하지 않고 놔둔다. 마지막에 다시 사용할 것이다.\n\n테스트 결과 모두 정상적으로 통과했다.\n\n### `DELETE` `api`\n\n이어서 **DELETE** 테스트 코드와 api를 생성한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -> None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -> None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.delete(\"/{id}/\", response_model=int, name=\"cleanings:delete-cleaning-by-id\")\nasync def delete_cleaning_by_id(\n    id: int = Path(..., ge=1, title=\"The ID of the cleaning to delete.\"),\n    session: AsyncSession = Depends(get_session),\n) -> int:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    await session.delete(cleaning)\n    await session.flush()\n    await session.commit()\n\n    return id\n```\n\n테스트도 정상적으로 통과한다.\n\n```bash\ntests/test_cleanings.py::TestDeleteCleaning::test_can_delete_cleaning_successfully PASSED             [ 86%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[500-404] PASSED [ 90%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[0-422] PASSED [ 93%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[-1-422] PASSED [ 96%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[None-422] PASSED [100%]\n```\n\n> **DELETE**와 같은 api는 `status_code=204`와 함께 `contents`가 없는 `response`를 반환하는게 맞다고 한다. 현재는 적용하지 않는다.\n\n### `PUT` api\n\n원 예제는 여기서 끝이지만, 추가로 **PUT** api에 대해 직접 작성해본다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -> None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -> cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n나름 여러 과정을 거쳤는데, **`sqlmodel`** 관련 문제를 알아보다 보니 너무 꼬였다. 과정은 생략..\n\n다음은 마이그레이션 진행 후 유저 관련 설정을 추가하는 것 같다. 유저 관련해서는 **`fastapi-users`** 라는 좋은 라이브러리가 있으니, 원 예제와 같은 흐름이지만 **`fastapi-user`** 를 쓰는 쪽으로 진행할 예정.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","data":{"title":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","date":"2022-05-02T20:47:43.741+09:00","tags":["crud","fastapi","restful","tdd","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"FastAPI, sqlmodel로 간단한 crud api 생성 4","content":"\n이제 기존에 작성한 `crud` api를 보완해보겠습니다.\n\n## 유저를 추가할때 중복 확인\n\n기존 작성된 `create` api는 입력받은 `body`를 그대로 db에 새로운 레코드로 추가하는 역할만 했습니다.\n이제 `email`속성을 기준으로 중복을 확인 한 다음 레코드로 추가할 수 있게 코드를 수정하겠습니다.\n\n```python\n# api/scripts/routes/user/crud.py\n(전략)\n\n@app.post(\"/create_user\", response_model=user.user)\nasync def create_user(data: user.user, *, session: AsyncSession = Depends(get_session)):\n    user_email = await session.exec(select(user.user.email))  # type: ignore\n    if data.email in user_email: # type: ignore\n        raise HTTPException(status_code=400, detail=\"동일한 email 유저 있음\")\n\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n(후략)\n```\n\n이제 중복된 유저 데이터를 입력하면 다음과 같은 400에러와 함께 다음과 같은 값을 반환합니다.\n\n```json\n{\n  \"detail\": \"동일한 email 유저 있음\"\n}\n```\n\n로그를 확인해보면 다음과 같이 에러를 반환하는 것을 확인할 수 있습니다.\n\n```sql\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".email\nFROM \"user\"\nINFO sqlalchemy.engine.Engine [no key 0.00018s] ()\nINFO:     10.0.2.100:43750 - \"POST /user/create_user HTTP/1.1\" 400 Bad Request\nINFO sqlalchemy.engine.Engine ROLLBACK\n```\n\n만약 중복이 아닌 데이터를 입력하면, 다음과 같은 로그를 확인할 수 있습니다.\n\n```sql\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".email\nFROM \"user\"\nINFO sqlalchemy.engine.Engine [no key 0.00016s] ()\nINFO sqlalchemy.engine.Engine INSERT INTO \"user\" (name, email, registered_date) VALUES (%s, %s, %s) RETURNING \"user\".id\nINFO sqlalchemy.engine.Engine [cached since 276.6s ago] ('test', 'test@example.com', datetime.datetime(--))\nINFO sqlalchemy.engine.Engine COMMIT\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".id, \"user\".name, \"user\".email, \"user\".registered_date\nFROM \"user\"\nWHERE \"user\".id = %s\nINFO sqlalchemy.engine.Engine [cached since 276.6s ago] (3,)\nINFO:     10.0.2.100:43796 - \"POST /user/create_user HTTP/1.1\" 200 OK\nINFO sqlalchemy.engine.Engine ROLLBACK\n```\n\n> 지금은 api 서버에서 처리하는 방법을 보이기 위해 이렇게 코드를 작성했습니다.\n> 하지만 **더 간단하게 중복을 제외하는 방법**이 있습니다.\n> `user.user` 모델을 정의할 때, `email` 필드에 `sa_column_kwargs={\"unique\": True}` 파라미터를 추가하면 됩니다.\n> 그러면 api 서버가 아닌, db에서 중복을 확인하고, 에러를 반환할 것입니다.\n> 다만, **이 에러에 대한 예외처리는 직접 해야합니다.**\n\n## 유저 정보를 수정한 최종 일자 기록\n\n기존 `user` 모델은 최초 입력 일자에 대한 정보만 보존하고, 수정한 일자에 대해서는 보존하지 않습니다. 이는 테이블에 새로운 필드를 추가해야 가능한 일이므로, `user`모델을 직접적으로 수정하겠습니다.\n\n```python\n# api/scripts/models/user/__init__.py\n(전략)\n\nclass user(SQLModel, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n    registered_date: datetime = Field(default_factory=datetime.today)\n    last_updated_date: datetime = Field(default_factory=datetime.today)\n```\n\n`last_updated_date` 필드만 추가하고 끝냈습니다.\n지금 이상태 그대로 진행하면 `update` api를 수정하더라도, 에러를 반환할 것입니다. 기존에 db 생성한 `user`테이블에는 `last_updated_date` 필드가 없기 때문입니다.\nsql의 `alter` 쿼리를 사용해도 되고, `sqlalchemy`의 `drop_all` 메소드를 사용해도 됩니다.\n지금은 개발 초기중의 초기이므로 `drop_all`로 해결하겠습니다.\n\n```python\n# api/scripts/database/default.py\n(전략)\n\nasync def create_model_table() -> None:\n    async with engine.begin() as conn:\n        if settings.debug:\n            await conn.run_sync(SQLModel.metadata.drop_all)\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\n기존에 없던 `await conn.run_sync(SQLModel.metadata.drop_all)`를 추가했습니다.\n`create_model_table`함수가 이미 서버를 시작할때 실행되도록 설정돼 있기 때문에, 이제 서버를 시작하면 작성한 모델에 대응하는 테이블을 모두 `drop`하고 다시 `create`할 것입니다.\n개발중에만 사용하자는 의미로 `settings.debug`를 확인하도록 했습니다. 실제로는 더 엄격하게 확인하는게 맞습니다.\n\n이제 `update` api를 수정하겠습니다.\n\n```python\n# api/scripts/routes/user/crud.py\n\nfrom datetime import datetime\n\nfrom fastapi import Depends, HTTPException, Path\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ...database import get_session\nfrom ...models import user\nfrom .app import app\n\n(중략)\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user)\nasync def update_user(\n    data: user.user,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    user_instance.last_updated_date = datetime.today()\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n(후략)\n```\n\n`user_instance.last_updated_date = datetime.today()`가 추가됐습니다.\n이제 정상적으로 `update` api가 실행되면, `last_update_date` 값이 변합니다.\n\n실제로 실행해보면, 다음과 같은 결과를 반환받습니다.\n\n```json\n{\n  \"id\": 1,\n  \"registered_date\": \"2021-11-26T23:59:37.359332\",\n  \"last_updated_date\": \"2021-11-26T23:59:52.837064\",\n  \"name\": \"aaa\",\n  \"email\": \"user@example.com\"\n}\n```\n\n## 각 api의 `response_model`과 `body` 형태 수정\n\n지금까지 작성된 `crud` api는 `delete`를 제외하고 `response_model=user.user` 파라미터를 가지고 있습니다. 이것은 반환한 값이 `user.user` 인스턴스이고, `user.user` 의 스키마로 데이터를 반환해라는 의미입니다.\n\n하지만 모든 api에서 그렇게 하는 것은 **위험한 일**입니다.\n지금은 따로 설정하지 않았지만 사용자의 **비밀번호**가 필드에 있을 수도 있고, **민감한 개인정보** 또한 가능합니다.\n\n또한 입력받는 `body` 역시 `user.user`의 스키마로 구성된 데이터를 받습니다. 하지만 이것은 불필요한 일이고, 어쩌면 **오류를 발생시킬 수도 있습니다.**\n\n사용자가 `user`를 추가할 때, `id`나 `registered_date`와 같이 레코드에 자동으로 입력되는 값은 **사용자가 입력한 값을 받을 필요도 없고, 받아선 안되는 값입니다.**\n\n따라서, 사용자가 입력하는 값과, 사용자에게 반환할 값에 대한 새로운 스키마가 필요합니다. 이에 대한 모델을 새로 생성하면서, 기존의 모델을 정의하는데 있어서 **약간의 변화**를 주겠습니다.\n\n```python\n# api/scripts/models/user/__init__.py\n\n(전략)\n\nclass user_base(SQLModel):\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n\n\nclass user_create(user_base):\n    pass\n\n\nclass user_read(user_base):\n    id: int\n\n\nclass user_update(user_base):\n    name: Optional[str] = Field(None, min_length=1)\n    email: Optional[EmailStr] = None\n\n\nclass user(user_base, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    registered_date: datetime = Field(default_factory=datetime.today)\n    last_updated_date: datetime = Field(default_factory=datetime.today)\n```\n\n`user_base`를 기준으로 `create`, `read`, `update`에 대응하는 모델과 `user` 테이블에 해당하는 모델을 생성했습니다.\n\n> `user_update`는 `user_base`에서 정의된 모든 필드를 덮어씌우지만, 그렇지 않은 경우도 있을 수 있으니 일단 상속했습니다.\n\n이전에 `table=True` 파라미터가 있어야 db에 테이블이 생성된다고 한 적이 있습니다. 위 코드에서 확인할 수 있듯이, `user` 클래스만 `table=True` 파라미터를 가지고 있습니다. 따라서 `user` 클래스를 제외한 모델은 사실상 `pydantic`의 모델로 활용하게 됩니다.\n\n이제 이 모델을 적용한 `crud` api를 수정합니다.\n\n```python\n# api/scripts/routes/user/crud.py\n\n(전략)\n\n@app.post(\"/create_user\", response_model=user.user_read)\nasync def create_user(\n    data: user.user_create, *, session: AsyncSession = Depends(get_session)\n):\n    user_email = await session.exec(select(user.user.email))  # type: ignore\n    if data.email in user_email:  # type: ignore\n        raise HTTPException(status_code=400, detail=\"동일한 email 유저 있음\")\n\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.get(\"/get_user/{user_id}\", response_model=user.user_read)\nasync def get_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    return user_instance\n\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user_read)\nasync def update_user(\n    data: user.user_update,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    user_instance.last_updated_date = datetime.today()\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.delete(\"/delete_user/{user_id}\")\nasync def delete_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    await session.delete(user_instance)\n    await session.commit()\n\n    return user_id\n```\n\n`reponse_model`을 `user.user_read`로 수정하고, `body`에 해당하는 `data`의 타입을 `user.user_create` 또는 `user.user_update`로 수정했습니다.\n`response_model`을 `user.user_read`로 정했기 때문에, `user.user` 인스턴스를 반환하더라도, `user.user_read`의 스키마에 따라 값이 반환됩니다.\n![](/images/9a191a49-09af-4cad-acf6-fe48c31b5fa5-docs.png)\ndocs에서 한 눈에 확인 가능합니다.\n\n## 끝으로..\n\n더 적고 싶은데, 더 적을게 뭐가 있을지 잘 모르겠어요.\n일단 여기서 중단\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성 4","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성 4","date":"2021-11-27T00:28:51.285+09:00","tags":["crud","fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"이제 기존에 작성한 crud api를 보완해보겠습니다."}},{"name":"FastAPI, sqlmodel로 간단한 crud api 생성 3","content":"\n이전 글에서 몇가지 의문점을 남겨놨습니다.\n\n- 유저를 추가할때 중복을 확인하지 않는다.\n- 유저를 수정한 일자가 없다.\n- 왜 response_model은 user로 고정이지?\n- etc...\n\n**다음 글**에서, 이러한 부분들을 고쳐가겠습니다.\n\n## 그 전에...\n\n지난 글까지 작성한 스크립트는 모두 한 폴더에 모여있습니다. 이런 구조는 지금같이 간단한 수준일때는 문제가 없지만, 점점 개발을 힘들게 만듭니다.\n그렇기 때문에, 간단한 형태로 구조화할 생각입니다.\n**아직 많이 부족하여, 효율적인 구조일지는 장담할 수 없습니다..**\n\n계획은 이렇습니다.\n\n> 1. api 서버를 실행하는 스크립트를 최상위 폴더에 위치하고, `scripts` 폴더를 생성\n> 2. `scripts` 폴더에 `config`, `database`, `models`, `routes` 폴더를 생성\n>    > `config` : 환경설정과 관련된 스크립트를 모아놓습니다. **다른 경로의 스크립트를 참조하지 않습니다.** >> `database` : db와 관련된 기본적인 작업에 대한 스크립트를 모아놓습니다.\n>    > `models` : 여러 api를 작성할 때 사용될 모델에 대한 스크립트를 모아놓습니다.\n>    > `routes` : 여러 api에 대해 입맛에 맞게 구조화하여 배치합니다.\n>\n> ### 왜 최상위 폴더가 아닌 `scripts` 폴더에?\n>\n> 파이썬에는 상대참조와 절대참조가 있습니다.\n> 아직 많이 부족하여, 정확히 이건 어떻고 저건 어떻다 말할 수준은 못되지만, **상대참조는 패키지로 구성된 스크립트에서만 가능하다고 알고 있습니다.**\n> 그렇기에, `scripts`폴더를 최상위 경로에서 사용할 수 있는 로컬 패키지처럼 사용하기 위해 `scripts`폴더를 생성 후, 하위 경로로 다른 폴더를 위치하게 했습니다.\n\n### 1. config\n\n앞으로 사용할 `settings` 클래스를 정의할 스크립트인 `default.py`를 생성하겠습니다.\n\n```python\n# api/scripts/config/default.py\nfrom typing import Any\n\nfrom pydantic import BaseSettings, Field\n\n\nclass database(BaseSettings):\n    drivername: str = \"postgresql+asyncpg\"\n    host: str = \"db\"\n\n    username: str = Field(..., env=\"POSTGRES_USER\")\n    password: str = Field(..., env=\"POSTGRES_PASSWORD\")\n    port: int = Field(..., env=\"POSTGRES_PORT\")\n    database: str = Field(..., env=\"POSTGRES_DB\")\n\n    query: dict[str, Any] = Field(default_factory=dict)\n\n\nclass settings(BaseSettings):\n    debug: bool = Field(..., env=\"RESTAPI_DEBUG\")\n\n    run_port: int = Field(..., env=\"RESTAPI_PORT\")\n    access_port: int = Field(..., env=\"RESTAPI_OUT_PORT\")\n\n    database: database = database()\n```\n\n그리고 `__ init__.py`를 생성해서 `settings` 클래스의 인스턴스를 생성합니다.\n\n```python\n# api/scripts/config/__init__.py\nfrom .default import settings\n\n__all__ = (\"settings\",)\n\nsettings = settings()\n```\n\n이제 `scripts.config.settings`로 설정값에 접근할 수 있습니다.\n\n### 2. database\n\n`routes`에서 빈번하게 사용될 `get_session`과 같은 범용적인 db관련 스크립트를 작성합니다.\n\n```python\n# api/scripts/database/default.py\nfrom typing import AsyncGenerator\n\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio.engine import create_async_engine\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ..config import settings\n\nurl = URL.create(**settings.database.dict())\nengine = create_async_engine(url, echo=settings.debug)\n\n\nasync def get_session() -> AsyncGenerator[AsyncSession, None]:\n    async with AsyncSession(engine) as session:\n        yield session\n\n\nasync def create_model_table() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\n기존에 최상위 경로에 생성했던 `database.py`와 달라진 점은, **직접 환경변수를 불러오지 않고,** 이전에 작성한 `scripts.config.settings`를 불러와서 사용한다는 것입니다.\n\n이어서 `__ init__.py`를 작성해서, 실제로 사용할 함수를 모아놓습니다.\n\n```python\n# api/scripts/database/__init__.py\nfrom .default import create_model_table, get_session\n\n__all__ = (\"get_session\", \"create_model_table\")\n```\n\n### 3. models\n\n우선 `user`폴더를 생성한 다음, 그 폴더에 `__ init__.py`를 작성하겠습니다.\n\n> 굳이 이렇게 하는 이유는\n\n- 각 라우트 혹은 모델별로 다른 폴더에 관리하면 편했던 기억이 있어서 그렇고,\n- 지금은 사용하지 않지만, `orjson`으로 `json`을 loads, dumps 할때, `pydantic`의 `BaseModel`을 상속한 새로운 모델을 만들어서 사용하는데, 그 모델을 `models.__init__.py`에 작성해두면 나중에 쓸때 편했기 때문입니다.\n\n**`api/scripts/models/user/__init__.py`는 기존 `model.py`와 같으므로 생략합니다.**\n\n### 4. routes\n\n기존에 `main.py`에 있던 `crud` api를 옮깁니다.\n이것도 `models`와 같이, `user`폴더를 생성 한 다음 해당 폴더에 스크립트를 작성합니다.\n\n우선 `main.py`에 정의된 `app`에 연결할 라우터를 정의할 `app.py`부터 작성합니다.\n\n```python\n# api/scripts/routes/user/app.py\nfrom fastapi import APIRouter\n\napp = APIRouter()\n```\n\n굳이 이렇게 따로 뺀 이유는 순환 참조 오류를 방지하기 위해서 입니다.\n\n여기서 `tags`와 `prefix`를 설정할 수도 있지만, 개인적으로 `main.py`에서 일괄적으로 확인하고 수정할 수 있는게 편해서 지금은 하지 않았습니다.\n\n다음으로 이전에 작성한 `crud` api를 모아놓은 `crud.py`를 작성합니다.\n\n```python\n# api/scripts/scripts/routes/user/crud.py\nfrom fastapi import Depends, HTTPException, Path\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ...database import get_session\nfrom ...models import user\nfrom .app import app\n\n\n@app.post(\"/create_user\", response_model=user.user)\nasync def create_user(data: user.user, *, session: AsyncSession = Depends(get_session)):\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.get(\"/get_user/{user_id}\", response_model=user.user)\nasync def get_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    return user_instance\n\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user)\nasync def update_user(\n    data: user.user,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.delete(\"/delete_user/{user_id}\")\nasync def delete_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    await session.delete(user_instance)\n    await session.commit()\n\n    return user_id\n```\n\n여기서 사용되는 `app`은 `main.py`의 `app`이 아닌, 같은 폴더의 `app.py`의 `app`입니다.\n\n마지막으로 `__ init__.py`를 작성합니다.\n\n```python\n# api/scripts/routes/user/__init__.py\nfrom .crud import app\n```\n\n여기서 불러온 앱은 `crud` api가 기억된 상태로, 나중에 `main.py`에서 불러옵니다.\n\n이제 `main.py`를 정리합니다.\n\n```python\n# api/main.py\nimport uvicorn\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom scripts.config import settings\nfrom scripts.database import create_model_table, get_session\nfrom scripts.routes import user\n\napp = FastAPI()\napp.on_event(\"startup\")(create_model_table)\napp.include_router(user.app, prefix=\"/user\", tags=[\"user\"])\n\n\n@app.get(\"/\")\ndef index():\n    return {\"hello\": \"world\"}\n\n\n@app.get(\"/session_test\")\nasync def session_test(*, session: AsyncSession = Depends(get_session)):\n    data = await session.exec(text(\"select 1\"))  # type: ignore\n    return data.all()\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=settings.run_port,\n        reload=settings.debug,\n    )\n```\n\n`api`폴더는 최상위 폴더이므로, `scripts`를 패키지처럼 다루면 됩니다.\n`user` 라우터는 `prefix=\"user\"`, `tags=[\"user\"]`로 파라미터를 줬습니다. 나중에 docs에서 확인해보면 차이를 알 수 있습니다.\n이제는 사용하지 않는 기존 `api/database.py`, `api/model.py`를 제거합니다.\n정상적으로 진행했다면, 다음과 같은 구조를 가지게 됩니다.\n\n```\n.\n├── .env\n├── api\n│   ├── main.py\n│   └── scripts\n│       ├── config\n│       │   ├── __init__.py\n│       │   └── default.py\n│       ├── database\n│       │   ├── __init__.py\n│       │   └── default.py\n│       ├── models\n│       │   └── user\n│       │       └── __init__.py\n│       └── routes\n│           └── user\n│               ├── __init__.py\n│               ├── app.py\n│               └── crud.py\n├── db [error opening dir]\n├── docker-compose.yml\n├── dockerfile\n└── requirements.txt\n```\n\n`db`폴더에 접근이 불가능 한 것은, 컨테이너 내부에서 관리자 권한으로 작성됐기 때문입니다.\n이제 `docker-compose up`으로 실행해서 docs를 확인해봅시다.\n![](/images/80800d72-874a-4bc0-afd5-80792cf91bef-docs.png)\napi 경로에 `user`가 추가됐고,\n각 api가 사전에 설정한 `tags`를 기준으로 나뉘어 진 것을 확인할 수 있습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성 3","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성 3","date":"2021-11-26T22:52:37.564+09:00","tags":["crud","fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"crud api를 보완하기 전, 구조를 적당히 변환"}},{"name":"FastAPI, sqlmodel로 간단한 crud api 생성 2","content":"\n## db접속 모듈 생성\n\n지난 글에서 db 컨테이너를 생성했지만 사용은 하지 않고 끝냈습니다. 이제 db를 연결하기 위한 작업을 진행하겠습니다.\n\n> 저는 `fastapi`와 `sqlmodel`의 기능을 최대한 사용하기 위해 `Field`나 `Depends`, `Path` 등을 가능하다면 사용하지만, **사용하지 않아도 대부분의 경우 문제가 없습니다.** > `fastapi` 와 `sqlmodel`이 **알아서 해결합니다.**\n\n`fastapi`는 `Depends`라는 재밌는 함수를 가지고 있습니다. 이걸 이용하면 코드를 깔끔하게 작성할 수 있는데, 이때 사용할 수 있는 형태로 database.py를 작성하겠습니다.\n\n```python\n# api/database.py\nfrom os import environ\nfrom typing import AsyncGenerator\n\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio.engine import create_async_engine\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\ndatabase = dict(\n    drivername=\"postgresql+asyncpg\",\n    username=environ[\"POSTGRES_USER\"],\n    password=environ[\"POSTGRES_PASSWORD\"],\n    host=\"db\",\n    port=environ[\"POSTGRES_PORT\"],\n    database=environ[\"POSTGRES_DB\"],\n)\nurl = URL.create(**database)\nengine = create_async_engine(url, echo=bool(int(environ[\"RESTAPI_DEBUG\"])))\n\n\nasync def get_session() -> AsyncGenerator[AsyncSession, None]:\n    async with AsyncSession(engine) as session:\n        yield session\n\n\nasync def create_model_table() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\ndb에서 비동기 세션을 사용할 계획이므로, `create_engine`대신 `create_async_engine`을 사용합니다.\n\n`get_session`함수는 각 요청에서 사용할 session을 생성할때 사용하고,\n`create_model_table`은 작성한 모델에 대응하는 테이블을 db에 생성하는 함수입니다. 나중에 모델을 생성하고 나면, fastapi가 시작할때 자동으로 실행되도록 할 계획입니다.\n\n> 만약 동기 세션을 사용한다면, `from sqlmodel import create_engine`으로 엔진을 생성하고,\n> `AsyncSession` 대신 `from sqlmodel import Session`으로 `Session`을 사용하면 됩니다.\n> 물론 `get_session`을 작성할 때, `async with` 대신 `with`로 바꿔야 합니다.\n> 그리고 `create_model_table` 내부에서 `with context`를 사용할 필요 없이, `create_all` 메소드를 실행하면 됩니다.\n\n## db접속 모듈 테스트\n\n작성한 함수가 잘 실행되는지 확인하기 위해 main.py에 간단한 `get` api를 생성하겠습니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import get_session\n\n# 중략\n\n\n@app.get(\"/session_test\")\nasync def session_test(*, session: AsyncSession = Depends(get_session)):\n    data = await session.exec(text(\"select 1\"))  # type: ignore\n    return data.all()\n\n\n# 후략\n```\n\n> `# type: ignore`는 `vscode`의 확장 프로그램인 `pylance`가 해당 라인의 정적 타입 확인을 하지 않도록 합니다.\n> 이유는 모르겠는데, `text`가 `excutable`한데도 `excutable`한 객체로 인정하지를 않습니다.\n> 사실 `sqlalchemy`자체가 정적 타입 체크시 많은 에러를 뿜긴 합니다.\n\n> `session`의 `exec` 메소드는 `sqlalchemy`에 없는 메소드입니다. 기존 실행 메소드인 `execute`를 사용해도 무방하지만, `exec`는 `execute`의 `wrapper`이면서 type hint가 잘 되어 있으므로, 정적 타입 체크나 `vscode`의 자동완성 등에서 상당한 편의를 얻을 수 있습니다.\n\n`select 1` 쿼리를 실행하는 간단한 형태의 `get` api를 작성했습니다. 정상적으로 작성하셨다면\n\n```json\n[\n  {\n    \"?column?\": 1\n  }\n]\n```\n\n와 같은 결과를 받게 됩니다.\n여기서 사용된 `Depends`는 단순히 `session`을 받는 용도지만, 이 외에도 많은 사용법이 있습니다.\n관련 내용은 [여기](https://fastapi.tiangolo.com/tutorial/dependencies/)에서 확인할 수 있습니다.\n\n> `fastapi`는 비동기 프로그래밍을 아주 잘 지원하기 때문에, **원한다면 그냥 `async def`를 사용하면 되고, 비동기가 아닌 io 작업이 있다면 그냥 `def`를 사용해도 됩니다. await 키워드를 사용하지 않더라도 async def를 사용해도 좋습니다. 어떻게 작성하든 `fastapi`가 알아서 잘 실행합니다.**\n\n## 사용할 모델 및 테이블 생성\n\n세션이 잘 붙은걸 확인했으니, 이제 사용할 모델을 생성하겠습니다.\n\n```python\n# api/model.py\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import EmailStr\nfrom sqlmodel import Field, SQLModel\n\n\nclass user(SQLModel, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n    registered_date: datetime = Field(default_factory=datetime.today)\n```\n\n`user`라는 모델이자 테이블인 클래스를 정의했습니다.\n`name`과 `email`은 필수값이고, `registered_date`는 자동으로 생성되도록 했습니다.\n\n> `table=True` 파라미터는 `user` 클래스가 db에서 사용할 테이블이라는 것을 알려줍니다.\n> 이 파라미터가 없으면, 이전에 작성한 `create_model_table` 함수를 실행해도 db에 테이블이 생성되지 않습니다.\n\npk로 지정한 `id`가 `Optional`이어서 의아할 수 있는데,\napi 서버에서 우선 `id`를 지정하지 않은 상태로 `user`인스턴스를 생성하고, 그 인스턴스를 `session`을 통해 추가하면 `user` 테이블에서는 정상적으로 `id`가 들어가게 됩니다.\n이후 api 서버에서 `id`를 확인하고 싶다면 `refresh`메소드를 사용하면 됩니다.\n\n### 테이블에 레코드를 추가하는 `post` api 생성\n\n이 과정을 담은 `post` api를 하나 생성하겠습니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\napp = FastAPI()\napp.on_event(\"startup\")(create_model_table)\n\n\n# 중략\n\n\n@app.post(\"/create_user\", response_model=user)\nasync def create_user(data: user, *, session: AsyncSession = Depends(get_session)):\n    user_instance = user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n# 후략\n```\n\n기존에 작성했던 `create_model_table`함수를 `app.on_event(...)` 데코레이터를 이용해서 자동으로 실행되도록 했습니다.\n현재 `main.py`에 `user` 클래스가 있으므로 api 서버가 실행될때 `user` 테이블이 db에 없다면 자동으로 생성됩니다.\n\n`.env` 파일에 `RESTAPI_DEBUG=1`로 작성하셨다면, 다음과 같은 쿼리로 테이블이 생성됐다는 것을 로그에서 확인할 수 있습니다.\n\n```sql\nCREATE TABLE \"user\" (\n        id SERIAL,\n        name VARCHAR NOT NULL,\n        email VARCHAR NOT NULL,\n        registered_date TIMESTAMP WITHOUT TIME ZONE,\n        PRIMARY KEY (id)\n)\n```\n\n> 아직 문자열을 `nvarchar`로 간단하게 설정하는 방법은 `sqlmodel`에 없습니다. `sqlalchemy`의 `Column`을 직접 작성해서 `Field`에 대응하는 방식으로만 가능합니다.\n> `type_` 파라미터를 사용할 수 있도록 PR된 상태이니, 다음 버전에서는 가능할 것 같습니다.\n\n다음과 같은 `body`로 `post`를 요청하면\n\n```json\n{\n  \"name\": \"string\",\n  \"email\": \"user@example.com\"\n}\n```\n\n다음과 같은 결과를 받게 됩니다.\n\n```json\n{\n  \"id\": 1,\n  \"registered_date\": \"2021-11-25T23:51:26.156134\",\n  \"name\": \"string\",\n  \"email\": \"user@example.com\"\n}\n```\n\n### 레코드를 조회하는 `get` api 생성\n\n이제 이 유저 정보를 조회하는 `get` api를 생성하겠습니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException, Path\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\n# 중략\n\n\n@app.get(\"/get_user/{user_id}\", response_model=user)\nasync def get_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    return user_instance\n\n\n# 후략\n```\n\n> 여기서 사용된 `Path`는 **없어도 아무 문제가 없습니다.**\n\n`user_id`에 해당하는 `user`가 없을 경우 404에러를 반환하도록 했습니다.\n`fastapi`에서 제공하는 `Path`를 이용해서, `user_id`는 1 이상의 값만 받도록 제한했습니다. 내부적으로 `pydantic`을 사용하기 때문에, 빠르고 정확합니다.\n\n### 레코드를 수정하는 `patch` api 생성\n\n이어서 유저 정보를 수정하는 `patch` api를 작성합니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException, Path\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\n# 중략\n\n\n@app.patch(\"/update_user/{user_id}\", response_model=user)\nasync def update_user(\n    data: user,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n# 후략\n```\n\n`data.dict` 메소드의 `exclude_unset=True` 파라미터는 `user` 클래스에 정의된 속성이면서 사용자가 `body`에 포함하지 않은 값을 제외한 딕셔너리를 반환하게 합니다.\n\n`user_id=1`에 다음과 같은 `body`를 보내면\n\n```json\n{\n  \"name\": \"aaa\",\n  \"email\": \"aaaa@example.com\"\n}\n```\n\n다음과 같은 `user`를 반환합니다.\n\n```json\n{\n  \"id\": 1,\n  \"registered_date\": \"2021-11-25T23:51:26.156134\",\n  \"name\": \"aaa\",\n  \"email\": \"aaaa@example.com\"\n}\n```\n\n이전에 생성한 `get` api로 조회해보면, 정상적으로 수정된 것을 확인할 수 있습니다.\n\n### 레코드를 제거하는 `delete` api 생성\n\n마지막으로 `delete` api를 작성합니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException, Path\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\n# 중략\n\n\n@app.delete(\"/delete_user/{user_id}\")\nasync def delete_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is no {user_id=} user\")\n\n    await session.delete(user_instance)\n    await session.commit()\n\n    return user_id\n\n\n# 후략\n```\n\n`user_id=1`로 `delete` api를 요청 한 다음 `get` api를 요청하면 다음과 같은 메세지를 보냅니다.\n\n```json\n{\n  \"detail\": \"there is no user_id=1 user\"\n}\n```\n\n기초적인 형태의 `crud` api를 작성하고, 정상적으로 실행되는지 확인했습니다.\n몇몇 아쉬운 부분들이 눈에 띕니다.\n\n- 유저를 추가할때 중복을 확인하지 않는다.\n- 유저를 수정한 일자가 없다.\n- 왜 `response_model`은 user로 고정이지?\n- etc...\n\n이러한 부분들은 다음 글에서 확인하겠습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성 2","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성 2","date":"2021-11-26T00:21:45.352+09:00","tags":["crud","fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"db와 연결 후 기초적인 형태의 crud api 생성"}}]},"__N_SSG":true}