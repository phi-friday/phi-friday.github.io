{"pageProps":{"post":{"name":"wsl2를 localhost로 연결할 수 없을 때","content":"\n# `localhost` 연결이 왜 안돼\n`wsl2`(이하 `wsl`)에서 \n```bash\npython -m http.server\n```\n위와 같이 서버를 실행 한 다음, ```localhost:8000```으로 접근하면 해당 디렉토리를 탐색할 수 있는 페이지에 접근 할 수 있다.\n\n그런데 정확한 이유는 모르겠지만 이게 정상적으로 작동하지 않을 때가 있다.\n\n# `wsl`의 주소에 직접 접근하자\n`wslconfig`를 수정해봐도 동일한 문제가 반복되는게 짜증나서, `localhost`대신 `wsl`의 로컬 주소를 매핑하는 글을 찾아봤다.\n\n[Fixing WSL2 localhost access issue](https://abdus.dev/posts/fixing-wsl2-localhost-access-issue/)\n\n> 위 글에서 가져온, 아래에서 사용할 코드\n>```powershell {filename=remote-port-hosts.ps1}\n>$hostname = \"wslhost\"\n>\n># find ip of eth0\n>$ifconfig = (wsl -- ip -4 addr show eth0)\n>$ipPattern = \"((\\d+\\.?){4})\"\n>$ip = ([regex]\"inet $ipPattern\").Match($ifconfig).Groups[1].Value\n>if (-not $ip) {\n>    exit\n>}\n>Write-Host $ip\n>\n>$hostsPath = \"$env:windir/system32/drivers/etc/hosts\"\n>\n>$hosts = (Get-Content -Path $hostsPath -Raw -ErrorAction Ignore)\n>if ($null -eq $hosts) {\n>    $hosts = \"\"\n>}\n>$hosts = $hosts.Trim()\n>\n># update or add wsl ip\n>$find = \"$ipPattern\\s+$hostname\"\n>$entry = \"$ip $hostname\"\n>\n>if ($hosts -match $find) {\n>    $hosts = $hosts -replace $find, $entry\n>}\n>else {\n>    $hosts = \"$hosts`n$entry\".Trim()\n>}\n>\n>try {\n>    $temp = \"$hostsPath.new\"\n>    New-Item -Path $temp -ItemType File -Force | Out-Null\n>    Set-Content -Path $temp $hosts\n>\n>    Move-Item -Path $temp -Destination $hostsPath -Force\n>}\n>catch {\n>    Write-Error \"cannot update wsl ip\"\n>}\n>```\n\n해당 글에서는 `wsl`이 처음 시작하고, 네트워크가 연결되는 이벤트에 반응하는 스케쥴을 생성해서 관리하는 방식으로 되어있는데, 이전 글인 `Distrod`와 같이 쓰려니 알 수 없는 에러가 발생했다.\n\n`wsl`으로 지속적인 서비스를 띄워놓을 생각은 없으므로, 터미널 접근시 실행하는 스크립트를 하나 작성하기로 했다.\n\n```bash {filename=hosts.sh}\n#!/usr/bin/env bash\n\nwsl_host_name=wslhost\nwin_ps1='c:\\\\wsl\\\\remote-port-hosts.ps1'\n\nip_pattern='([0-9]{1,3}\\.){3}[0-9]{1,3}'\nwin_hosts='/mnt/c/Windows/System32/drivers/etc/hosts'\npowershell_cmd='Start-Process powershell -verb runas -ArgumentList '\\\n'\"-ExecutionPolicy Bypass -File '${win_ps1}'\"'\n\n# windows의 hosts에 작성되어 있는 wsl ip\nwin_hosts_ip=`cat ${win_hosts} | \\\n    grep ${wsl_host_name} | \\\n    egrep -o ${ip_pattern}`\n# linux의 hosts에 작성되어 있는 wsl ip\nlinux_hosts_ip=`cat /etc/hosts | \\\n    grep ${wsl_host_name} | \\\n    egrep -o ${ip_pattern}`\n# wsl이 실제로 실행되고 있는 ip\nreal_ip=`ip addr | \\\n    awk '/inet/ && /eth0/' | \\\n    awk '{print $2}' | \\\n    egrep -o ${ip_pattern}`\n\nif [ ${win_hosts_ip} == $real_ip ] && \\\n    [ $linux_hosts_ip == $real_ip ]; then\n    exit 0\nfi\n\n# 관리자권한 파워쉘을 실행하여 hosts파일 수정\necho run cmd to change windows hosts\npowershell.exe ${powershell_cmd}\n# 관리자권한으로 wsl의 hosts를 수정\necho change /etc/hosts\nsudo sed -i s/${linux_hosts_ip}/${real_ip}/g /etc/hosts\nexit 0\n```\n\n이제 위 스크립트를 ```.zshrc```와 같은 곳에서 실행하도록 설정하면 된다.\n\n이 스크립트가 정상적으로 실행된다면, 이제 `localhost`대신 `wslhost`로 `wsl`에서 실행한 서비스에 접근할 수 있게 된다.\n\n# 아쉽다\n`wsl`내에서 윈도우의 `hosts` 파일을 수정할 수 있다면 훨씬 간단했지만, 쓰기 권한을 얻을 방법이 보이지 않아 일단 돌아서 처리하기로 했다.\n\n좀 더 깔끔한 방법을 찾는다면 새로 포스팅하자.\n","mtime":"2022-08-20T23:27:38.285+09:00","href":"other/wsl2를 localhost로 연결할 수 없을 때","data":{"title":"wsl2를 localhost로 연결할 수 없을 때","tags":["windows","wsl","@all"],"page":null,"summary":"hosts 파일을 수정할 수 있게 만들자","date":"2022-08-20T22:40:09.881+09:00"}},"prev_post":{"name":"wsl2에서 pid 1을 systemd로 변경하기","content":"\n# `systemd`로 인한 에러\n`wsl2`(이하 `wsl`)를 그냥 실행할 경우, 다음과 같은 에러를 겪을 때가 있다.\n```bash\nSystem has not been booted with systemd as init system (PID 1). Can't operate.\n```\n\n이는 pid 1번이 `systemd` 가 아니어서 생기는 문제로, 해결하기 위해서는 [genie](https://github.com/arkane-systems/genie)와 같은 별도의 프로그램을 실행해줘야 했다. 하지만 최근 처음부터 이를 해결한 상태로 wsl을 실행하는 프로젝트를 발견했는데, 바로 [Distrod](https://github.com/nullpo-head/wsl-distrod)다.\n\n# `Distrod`를 사용하자\n`Distrod`를 설치하는 방법은 크게 두가지로 나뉘는데,\n하나는 이미 해당 패치가 적용된 배포판을 사용하거나,\n기존에 사용하던 `wsl`환경에 해당 패치를 적용하는 것이다.\n\n## 신규 설치\n[링크](https://github.com/nullpo-head/wsl-distrod/releases/latest/download/distrod_wsl_launcher-x86_64.zip)의 압축 파일을 해제하면, 단일 exe 파일이 존재하는데, 해당 실행 파일을 실행시키면 끝이다.\n\n굉장히 다양한 배포판(아치, 데비안, 젠투, 보이드 등)을 지원하기에, 대부분의 경우, 선택권을 제한당한다는 기분은 느끼지 못할 것이다.\n\n## 기존 환경에 패치\n이것 또한 아주 간단하다. \n1. 패치 스크립트를 다운로드 한 다음, 실행한다.(아직 적용되지 않았다.)\n```bash\ncurl -L -O \"https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh\"\nchmod +x install.sh\nsudo ./install.sh install\n```\n\n2. wsl이 처음 실행됐을 때, 다음 명령어를 관리자 권한으로 실행하던가,\n```bash\n/opt/distrod/bin/distrod enable\n```\n3. 또는 다음 명령어로 윈도우 스케쥴러에 자동으로 해당 패치가 정상적으로 실행될 수 있도록 한다.\n```bash\n/opt/distrod/bin/distrod enable --start-on-windows-boot\n```\n\n이제 ```ps -ef | head -n 2```으로 확인해보면,\n```bash\nUID          PID    PPID  C STIME TTY          TIME CMD\nroot           1       0  0 21:34 ?        00:00:00 /sbin/init systemd.setenv=WSL_DISTRO_NAME=Distrod systemd.setenv=WSL_INTEROP=/run/WSL/11_interop systemd.setenv=WSLENV=WT_SESSION::WT_PROFILE_ID --unit=multi-user.target\n```\n위와 같이 `distrod`의 패치가 적용된 것을 확인할 수 있다.\n\n## 윈도우11은 주의\n`distrod`의 기능 중, `wsl`의 특정 포트를 외부로 포워딩 할 수 있는 `portproxy`라는 서비스가 있는데, 윈도우 11에서는 정상적으로 작동하지 않는 [버그](https://github.com/nullpo-head/wsl-distrod/blob/main/docs/references.md#know-bugs)가 있다고 한다.\n","mtime":"2022-08-20T22:17:59.496+09:00","href":"other/wsl2에서 pid 1을 systemd로 변경하기","data":{"title":"wsl2에서 pid 1을 systemd로 변경하기","tags":["windows","wsl","@all"],"page":null,"summary":"잘 만들어놓은 배포판을 가져다 쓰자","date":"2022-08-14T22:13:27.850+09:00"}},"next_post":{"name":"returns0","content":"\n# 2% 부족한 `python`의 `type-hint`\n`python`에서 `type-hint` 지원이 점점 강력해지고, 이를 반영한 라이브러리들이 늘어나다 보니, 나도 `type-hint`를 적용해가며 개발을 하고 있다.\n\n하지만 아직 몇몇 아쉬운 부분이 보이는데,\n\n특정 클래스 메소드의 리턴값을 그 클래스의 인스턴스로 나타내려 할 때, `TypeVar`를 사용해서 `bound`를 일일이 지정해줘서 나타내야 한다던가..\n> 이전에는 `TypeVar`를 사용해야 했지만, 이제는 PEP 673이 반영된 `typing_extensions`의 `Self`를 사용하면 된다.\n>\n> 하지만 아직 많은 라이브러리가 `Self`를 사용하고 있지는 않다.(이미 `TypeVar`로 많은 부분이 작성되어 있으므로)\n\n나중에 정의될 클래스를 `type-hint`로 사용하려면 문자열로 표현해야 한다던가..\n> 3.11에서 수정될 예정이고, `__future__` 에서 `annotation` 모듈을 가져오면 미리 사용할 수 있다.\n\n`TypeVar`로 정의된 값을 이용해서 상위 제네릭을 표현할 수 없다던가..\n```python\nfrom typing import TypeVar, Generic\n\n_T = TypeVar(\"_T\")\n_Test = TypeVar(\"_Test\", bound=\"Test\")\n\nclass Test(Generic[_T]):\n    def __init__(self, data: _T):\n        self.data = data\n\ndef test(value: _T[int]) -> _T[int]:\n    ...\n# TypeError: 'TypeVar' object is not subscriptable\n```\n\n쓰다보니 뭔가 대부분 `TypeVar` 관련인데, 이 중에서 `TypeVar`를 사용한 상위 제네릭과 관련해서 좀 더 알아봤더니, 제한적으로나마 이를 해결한 라이브러리가 있었는데, 그게 바로 [returns](https://github.com/dry-python/returns)다.\n\n> 앞서 상위 제네릭이라 표현한 것은, 일반적으로 __Higher Kinded Type__ 이라고 하는 것 같다.\n\n# 함수형 프로그래밍에 적합한 `returns`\n라이브러리 이름이 범용적으로 쓰이는 `return`과 너무 유사해서, 제대로 검색이 되지 않는다. 마치 구글의 `go`를 보는 듯 하다..\n\n다행히 `returns` 자체 [문서](https://returns.readthedocs.io/en/latest/index.html)가 아주 잘 만들어져 있어서, 이해하는데 큰 문제는 없었다.\n\n또한 라이브러리 기능이 간단하면서도 강력해서, `type-hint` 외에도 쓸데가 많아보인다. 특히, 함수형 프로그래밍을 하고자 한다면 꽤 유용하지 않을까, 싶었는데 `readme`에서 함수형 프로그래밍을 위해 만들어진 라이브러리라고 직접 소개하고 있다.\n> _Brings functional programming to Python land_\n\n처음에는 단순히 __Higher Kinded Type__ 를 위해 알아봤는데, 이제는 이 라이브러리를 어떻게 사용하면 잘 사용할 수 있을까 고민하게 됐다.\n\n`returns`의 대표적인 기능 두가지만 미리 소개하자면,\n\n## `Optional`을 대신 할 `Maybe`\n\n```python\nfrom returns.maybe import Maybe, maybe\n\n\n@maybe\ndef one_or_none(value: int) -> int | None:\n    if value == 1:\n        return value\n    return None\n\n\nmaybe_one0: Maybe[int] = one_or_none(1)\nmaybe_one1: Maybe[int] = one_or_none(2)\n# or\n# maybe_one0: Maybe[int] = Maybe.from_optional(1)\n# maybe_one1: Maybe[int] = Maybe.from_optional(None)\n\nmaybe_str0 = maybe_one0.bind_optional(str)\nmaybe_str1 = maybe_one1.bind_optional(str)\n\nassert maybe_str0.value_or(\"error\") == \"1\"\nassert maybe_str1.value_or(\"error\") == \"error\"\n```\n원래라면 `if`문을 사용해서 `None` 타입 확인을 하고 진행했겠지만,\n\n`Maybe`는 마치 `js`의 `some_object?.some_attr`과 같은 방식으로 전개할 수 있게 만들어준다.\n\n\n## `try`, `except`를 대신할 `Result`\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Result, safe\n\n\n@safe\ndef div(left: float, right: float) -> float:\n    # if right == 0:\n    # raise ZeroDivisionError\n    return left / right\n\n\nresult0: Result[float, Exception] = div(2, 3)\n# or\n# result0: Result[float, ZeroDivisionError]\n# or\n# from returns.result import ResultE\n# result0: ResultE[float] = div(2, 3)\nresult1: Result[float, Exception] = div(4, 0)\n\nassert (\n    result_to_maybe(result0.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == 4 / 9\n\nassert (\n    result_to_maybe(result1.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == \"error\"\n```\n\n에러에 대해 미리 고민 할 필요 없이, 기본적으로 제공되는 `map`, `bind`, `alt`, `lash` 등의 메소드를 사용하면 된다.\n\n올바른 타입이 아니라면 작동하지 않고, 추가적인 에러도 발생하지 않는다.\n\n위 예시에서는 문자열 `error`를 표시했지만, 원한다면 그 에러를 발생시킬 수도 있다.\n\n# 앞으로\n시간이 될 때, `returns`의 공식 문서를 나름대로 정리해서 포스팅을 하고자 한다. 하지만 이것도 다른 것과 마찬가지로 하다가 중단될 수 있다..\n","mtime":"2022-09-13T20:54:24.447+09:00","href":"python/returns0","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 0","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-09T02:10:44.645+09:00"}},"page_posts":null},"__N_SSG":true}