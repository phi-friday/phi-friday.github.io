<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="author" content="phi.friday@gmail.com, phi"/><meta name="robots" content="index,follow,noarchive"/><meta name="google-site-verification" content="lW107Dj5ageygd67UUzTm-kGls5d-THy9jJQZqLoauw"/><title>phi.log</title><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e61452b80f7f8356.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e61452b80f7f8356.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c0b66b64eb886a29.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0b66b64eb886a29.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-5dc3bdee87ff18dd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f6271bdec05edb1f.js" defer=""></script><script src="/_next/static/chunks/996-f3cf67c2e3ac5e06.js" defer=""></script><script src="/_next/static/chunks/756-1349105dbea71525.js" defer=""></script><script src="/_next/static/chunks/224-ddba219ecdd5c904.js" defer=""></script><script src="/_next/static/chunks/pages/posts/@tag/%5B...tag%5D-5364b6481a3135f4.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_buildManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_ssgManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style>
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: #29D;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow: 0 0 10px #29D, 0 0 5px #29D;
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: #29D;
        border-left-color: #29D;
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style><div class="container" style="max-width:900px;min-width:400px"><div class="container default_app"><header><div class="container"><nav class="navbar-light fixed-top navbar navbar-expand-sm bg-light" role="navigation"><div class="container" style="max-width:900px"><div class="container-fluid"><ul class="navbar-nav w-100"><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-home"></i> Home</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@tag"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-hashtag"></i> Post</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@page"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-blog"></i> Page</div></a></li><div class="container d-flex justify-content-end align-self-center"><div class="row"><div class="col"><form class="input-group w-auto" method="get" action="https://www.google.com/search" target="_blank" style="min-width:230px"><input type="hidden" name="sitesearch" value="phi-friday.github.io"/><input type="search" class="form-control" placeholder="Search in Google" aria-label="Search" name="q" maxLength="255"/><button class="ripple ripple-surface btn btn-outline-primary" role="button"><i class="fa fa-search"></i></button></form></div></div></div></ul></div></div></nav></div></header><main><div class="container"><div class="row"><div><span><span class="badge bg-light mx-1 text-dark">@all<!-- --> <span class="badge bg-danger">25</span></span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> <span class="badge bg-danger">21</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> <span class="badge bg-danger">14</span></span></span><span><span class="badge bg-primary mx-1">#sqlmodel<!-- --> <span class="badge bg-danger">8</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#crud<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#returns<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#함수형 프로그래밍<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#windows<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#wsl<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#tdd<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#anyio<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#async<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vim<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#js<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#ts<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#nextjs<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#velog<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#github<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#restful<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#pytest<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#alembic<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#postgres<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#black<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#isort<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vscode<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#asyncio<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#trio<!-- --> <span class="badge bg-danger">1</span></span></span></div></div><div class="row"><div class="container"><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#sqlmodel<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi 튜토리얼 -8.2- FastAPI Users v10 대응</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-07T23:00:58.369+09:00">작성일: 2022년 5월 7일</time></h6></p></p><p class="card-text">fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#sqlmodel<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-07T22:08:12.781+09:00">작성일: 2022년 5월 7일</time></h6></p></p><p class="card-text">fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#sqlmodel<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">sqlmodel 라이브러리 사용시 주의사항 - validation</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-02T18:53:19.408+09:00">작성일: 2022년 5월 2일</time></h6></p></p><p class="card-text">sqlmodel에서 모델에 table=True 옵션을 주면 from_orm, parse_obj에서 validation 과정을 진행하지 않는다.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#sqlmodel<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi 튜토리얼 -3- sql 모델 정의</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-04-28T21:51:36.869+09:00">작성일: 2022년 4월 28일</time></h6></p></p><p class="card-text">fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#crud<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#sqlmodel<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">FastAPI, sqlmodel로 간단한 crud api 생성 4</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2021-11-27T00:28:51.285+09:00">작성일: 2021년 11월 27일</time></h6></p></p><p class="card-text">이제 기존에 작성한 crud api를 보완해보겠습니다.</p></div></div></div></div><div class="row"><ul class="pagination justify-content-center"><li class="page-item disabled"><a class="page-link" href="/posts/@tag/sqlmodel/1"><i class="fa fa-angle-double-left"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/sqlmodel/0"><i class="fa fa-angle-left"></i></a></li><li class="page-item active"><a class="page-link">1</a></li><li class="page-item" href="/posts/@tag/sqlmodel/2"><a class="page-link">2</a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/sqlmodel/6"><i class="fa fa-angle-right"></i></a></li><li class="page-item"><a class="page-link" href="/posts/@tag/sqlmodel/2"><i class="fa fa-angle-double-right"></i></a></li></ul></div></div></main><footer class="text-center text-muted"></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"sqlmodel","page":1,"max_page":2,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `Breaking` `changes`\n\n이틀전 **`fastapi-users`** 에 큰 변화가 생겼다. `v10` 릴리즈가 공개됐는데, `db` 모델과 여러 제네릭 타입에 대한 변화가 생겨서, `v10`을 이용하려면 대응 패치가 필수적인 상황..\n\n아래는 해당 릴리즈에 대한 전문이다.\n\n\u003e ### [Breaking changes](https://github.com/fastapi-users/fastapi-users/releases/tag/v10.0.0)\n\u003e\n\u003e Version 10 marks important changes in how we manage User models and their ID.\n\u003e\n\u003e Before, we were relying only on Pydantic models to work with users. In particular the current_user dependency would return you an instance of UserDB, a Pydantic model. This proved to be quite problematic with some ORM if you ever needed to retrieve relationship data or make specific requests.\n\u003e\n\u003e Now, FastAPI Users is designed to always return you a native object for your ORM model, whether it's an SQLAlchemy model or a Beanie document. Pydantic models are now only used for validation and serialization inside the API.\n\u003e\n\u003e Before, we were forcing the use of UUID as primary key ID; a consequence of the design above. This proved to be quite problematic on some databases, like MongoDB which uses a special ObjectID format by default. Some SQL folks also prefer to use traditional auto-increment integers.\n\u003e\n\u003e Now, FastAPI Users is designed to use generic ID type. It means that you can use any type you want for your user's ID. By default, SQLAlchemy adapter still use UUID; but you can quite easily switch to another thing, like an integer. Beanie adapter for MongoDB will use native ObjectID by default, but it also can be overriden.\n\n### 유저 모델 생성 및 수정\n\n기존 `fastapi_users.models` 에서 `fastapi_users.schemas`로 바뀐 것 외에 크게 달라진 것은 없다. 사실 이전에 얘기했던 `user` 와 `user_model`을 통합하는 작업을 이미 한 다음 `v10` 릴리즈를 확인했기에 더욱 그렇게 느껴졌다...\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar\n\nfrom fastapi_users import schemas\nfrom pydantic import EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field, select\n\nfrom ..db.session import async_session\nfrom .core import base_model, datetime_model, uuid_id_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\n_T = TypeVar(\"_T\", bound=\"user\")\nid_model = uuid_id_model\nuser_id_type = id_model.id_type\n\n\nclass user(id_model, datetime_model, base_model, table=True):\n    __tablename__: str = \"users\"\n\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: async_session, email: str\n    ) -\u003e _T | None:\n        is_user_cur = await session.exec(select(cls).where(cls.email == email))\n        return is_user_cur.first()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.validate(self)\n\n\nclass user_read(schemas.BaseUser[user_id_type], datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(schemas.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(schemas.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n```\n\n### 인증 모듈 제네릭 타입 덮어씌우기\n\n**`fastapi-users`** 에서 원하는 형태는 `SQLAlchemyBaseUserTable`를 상속한 클래스를 사용하는 것이지만, **`sqlmodel`** 도 그대로 사용하고 **`fastapi-users`** 의 타입 힌트도 그대로 사용하고 싶기에, 두 라이브러리를 엮어줄 새로운 제네릭 클래스를 생성한다.\n`# type: ignore`를 남발하기에 그다지 좋은 모습이라고 생각되지 않지만, 이거 외에 당장 생각나는 방법이 없기에 일단 넘어가자.\n\n```bash\n❯ mkdir backend/app/services/authentication\n❯ mv backend/app/services/authentication.py backend/app/services/authentication/authentication.py\n❯ touch backend/app/services/authentication/__init__.py backend/app/services/authentication/convert.py\n```\n\n```python\n# backend/app/services/authentication/__init__.py\nfrom .authentication import *\n```\n\n```python\n# backend/app/services/authentication/convert.py\nfrom typing import Generic, TypeVar\n\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import AuthenticationBackend, JWTStrategy, Strategy\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n\nfrom ...models.core import base_model\nfrom ...models.user import user\n\nuser_id_type = user.id_type\n_T = TypeVar(\"_T\", bound=base_model)\n_D = TypeVar(\"_D\")\n\n# fmt: off\nclass user_db_class(SQLAlchemyUserDatabase[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass strategy_class(Strategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass jwt_strategy_class(JWTStrategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass auth_backend_class(AuthenticationBackend[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass user_manager_class(BaseUserManager[_T, _D], Generic[_T, _D]): ...  # type: ignore\nclass fastapi_users_class(FastAPIUsers[_T, _D], Generic[_T, _D]): ...  # type: ignore\n# fmt: on\n\n\nuser_manager_type = user_manager_class[user, user_id_type]\nstrategy_type = strategy_class[user, user_id_type]\n```\n\n### 변경점 인증 모듈에 적용\n\n```python\n# backend/app/services/authentication/authentication.py\nimport re\nfrom dataclasses import dataclass\nfrom re import Pattern\nfrom typing import AsyncGenerator, Sequence\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import IntegerIDMixin, InvalidPasswordException\nfrom fastapi_users.authentication import BearerTransport, Transport\n\nfrom ...core import config\nfrom ...db.session import async_session, get_session\nfrom ...models import user\nfrom .convert import (\n    auth_backend_class,\n    fastapi_users_class,\n    jwt_strategy_class,\n    strategy_class,\n    strategy_type,\n    user_db_class,\n    user_id_type,\n    user_manager_class,\n    user_manager_type,\n)\n\n\nasync def get_user_db(\n    session: async_session = Depends(get_session),\n) -\u003e AsyncGenerator[user_db_class[user.user, user_id_type], None]:\n    yield user_db_class(session, user.user)\n\n\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\n\ndef create_strategy() -\u003e strategy_class[user.user, user_id_type]:\n    return jwt_strategy_class(  # type: ignore\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n\ndef create_backend() -\u003e list[auth_backend_class[user.user, user_id_type]]:\n    transport = create_transport()\n    return [\n        auth_backend_class(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n\n\nclass UserManager(IntegerIDMixin, user_manager_class[user.user, user_id_type]):\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+\u003c\u003e@\\#$%\u0026\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -\u003e None:\n        if len(password) \u003c self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) \u003e self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\n        for pattern in self.re_password_deny_list:\n            if pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\n        for pattern in self.re_password_need_list:\n            if not pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -\u003e AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(\n    *backends: auth_backend_class[user.user, user_id_type],\n) -\u003e fastapi_users_class[user.user, user_id_type]:\n    return fastapi_users_class(\n        get_user_manager=get_user_manager, auth_backends=backends\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -\u003e Sequence[auth_backend_class[user.user, user_id_type]]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def user_manager_depends(self) -\u003e user_manager_type:\n        return Depends(self.users.get_user_manager)\n\n    def strategy_depends(self, num: int = 0, /) -\u003e strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n꽤 많이 바뀌긴 했지만, 실제로 사용할때는 이름정도만 바뀌지 사용법 자체는 변한게 없다. 바뀐 이름에 맞춰서 라우터와 테스트 코드를 수정해주면, 정상적으로 작동하는 것을 확인할 수 있다.\n\n이번 기회에 테스트 코드가 얼마나 좋은건지 알게됐다.. 긴가민가할때 `pytest --tb=short` 한방이면 의문이 해결된다.\n\n사실 변경할게 하나 더 남긴 했지만, 이거 아직 시도해보지 않았다.\n현재 헤더를 사용한 인증 방식인데, 쿠키를 사용하고, `access-token`과 `refresh-token`을 사용한 방식으로 변경해보려 한다. 다만 **`fastapi-users`** 자체적으로는 지원하지 않기에, 직접 작성할 필요가 있어서 약간 고민이 필요할듯.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","data":{"title":"fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","date":"2022-05-07T23:00:58.369+09:00","tags":["fastapi","fastapi-users","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `Session`의 코드를 그대로 복붙\n\n이전까지 글에서 계속해서 `AsyncSession`의 타입 관련 문제가 발생하는게 너무 짜증나서, 임시로 땜빵용 클래스를 생성해서 사용하기로 했다.\n\n````python\n# backend/app/db/session.py\n(...)\n\n_TSelectParam = TypeVar(\"_TSelectParam\")\n\nclass async_session(AsyncSession):\n    # sqlmodel.orm.session.Session\n    @overload\n    async def exec(\n        self,\n        statement: Select[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Result[_TSelectParam]:\n        ...\n\n    @overload\n    async def exec(\n        self,\n        statement: SelectOfScalar[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e ScalarResult[_TSelectParam]:\n        ...\n\n    async def exec(\n        self,\n        statement: Union[\n            Select[_TSelectParam],\n            SelectOfScalar[_TSelectParam],\n            Executable[_TSelectParam],\n        ],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Union[Result[_TSelectParam], ScalarResult[_TSelectParam]]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().exec(\n            statement,  # type: ignore\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def execute(\n        self,\n        statement: _Executable,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Optional[Mapping[str, Any]] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Result[Any]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        ***\n\n        🚨 You probably want to use `session.exec()` instead of `session.execute()`.\n\n        This is the original SQLAlchemy `session.execute()` method that returns objects\n        of type `Row`, and that you have to call `scalars()` to get the model objects.\n\n        For example:\n\n        ```Python\n        heroes = session.execute(select(Hero)).scalars().all()\n        ```\n\n        instead you could use `exec()`:\n\n        ```Python\n        heroes = session.exec(select(Hero)).all()\n        ```\n        \"\"\"\n        return await super().execute(  # type: ignore\n            statement,\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def get(\n        self,\n        entity: Type[_TSelectParam],\n        ident: Any,\n        options: Optional[Sequence[Any]] = None,\n        populate_existing: bool = False,\n        with_for_update: Optional[Union[Literal[True], Mapping[str, Any]]] = None,\n        identity_token: Optional[Any] = None,\n    ) -\u003e Optional[_TSelectParam]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().get(\n            entity,\n            ident,\n            options=options,\n            populate_existing=populate_existing,\n            with_for_update=with_for_update,\n            identity_token=identity_token,\n        )\n````\n\n주석을 보면 알겠지만, 그냥 `sqlmodel.orm.session.Session` 객체의 각 메소드의 타입 힌트를 그대로 가져왔다. 이에 맞춰서 다른 스크립트의 `AsyncSession`도 모두 `async_session`에 대한 스크립트로 변환해준다. 그리고 테스트 코드를 실행해보면 문제없이 실행되는 것을 확인할 수 있다.\n\n---\n\n## `datetime_model` 관련 문제 해결\n\n`datetime_model`의 `datetime_attrs` 속성이 의도한대로 출려되지 않는 문제가 있어서 추가로 수정했다. `cls.__fields__.keys()` 를 `datetime_model.__fields__.keys()`로 수정한 것외에 모두 동일하다.\n\n```python\n# backend/app/models/core.py\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -\u003e _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def datetime_attrs(cls) -\u003e set[str]:\n        return set(datetime_model.__fields__.keys())\n```\n\n## `id_model` 세분화\n\n기존에 사용하던 `id_model`을 `int_id_model`과 `uuid_id_model`로 세분화해서 사용하기로 했다.\n\n```python\n# backend/app/models/core.py\nfrom uuid import uuid4\nfrom pydantic import UUID4\n\n(...)\n\nclass id_model(fix_return_type_model):\n    @classmethod\n    @property\n    def id_type(cls) -\u003e Any:\n        return cls.__fields__[\"id\"].type_\n\n\nclass int_id_model(id_model):\n    id: int | None = Field(None, primary_key=True)\n\n\nclass uuid_id_model(id_model):\n    id: UUID4 | None = Field(default_factory=uuid4, primary_key=True)\n```\n\n## `dependencies` 모듈 생성\n\n기존에 사용하던 `get_session`이나 `get_current_user`같은 `Depends`와 함께 사용하던 함수를 따로 관리하기로 했다.\n\n```python\n# backend/app/dependencies/database.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\nfrom ..db.session import async_session\n\n\nasync def get_database(request: Request) -\u003e AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -\u003e AsyncIterator[async_session]:\n    async with async_session(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n```python\n# backend/app/dependencies/auth.py\nfrom ..services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\nget_user_manager = fastapi_user.get_user_manager\nget_backend = fastapi_user.get_backend\nget_transport = fastapi_user.get_transport\nget_strategy = fastapi_user.get_strategy\n```\n\n```python\n# backend/app/services/authentication/authentication.py\n(...)\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n    named_backends: dict[str, auth_backend_type] = field(default_factory=dict)\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -\u003e Sequence[auth_backend_type]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def get_user_manager(self):\n        return self.users.get_user_manager\n\n    def find_backend(self, _val: str, /) -\u003e auth_backend_type:\n        for backend in self.backends:\n            if backend.name == _val:\n                return backend\n        raise IndexError(f\"there is not auth_backend name: {_val}\")\n\n    def get_backend(self, _val: int | str = 0, /) -\u003e auth_backend_type:\n        if isinstance(_val, int):\n            return self.backends[_val]\n\n        if (backend := self.named_backends.get(_val)) is None:\n            backend = self.named_backends[_val] = self.find_backend(_val)\n        return backend\n\n    def get_transport(self, _val: int | str = 0, /) -\u003e Transport:\n        backend = self.get_backend(_val)\n        return backend.transport\n\n    def get_strategy(self, _val: int | str = 0, /):\n        backend = self.get_backend(_val)\n        return backend.get_strategy\n```\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","data":{"title":"fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","date":"2022-05-07T22:08:12.781+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"sqlmodel 라이브러리 사용시 주의사항 - validation","content":"`sqlmodel`은 `fastapi`의 개발자 `tiangolo`의 주도 하에 개발이 진행중인 `sql`관련 라이브러리입니다. `pydantic`의 모델과 `sqlalchemy`의 테이블을 한번의 정의로 같이 쓸 수 있다는 장점이 있어서, 다소 불안정한 부분이 있더라도 종종 쓰고 있습니다.\n\n그런데 최근 아주 무서운 일을 확인했습니다.. `sqlmodel`로 정의한 모델에 `table=True`옵션을 주면 `pydantic`에서 자랑하는 검증 과정이 전혀 작동하지 않는다는 사실을..\n\n`from_orm`, `parse_obj` 이 두 메소드 모두 정상적으로 작동하지 않으니, `validate` 메소드를 이용해서 레코드를 생성하면 정상적으로 사용할 수 있는 것 같습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/sqlmodel 라이브러리 사용시 주의사항 - validation","data":{"title":"sqlmodel 라이브러리 사용시 주의사항 - validation","date":"2022-05-02T18:53:19.408+09:00","tags":["python","sqlmodel","@all"],"page":null,"summary":"sqlmodel에서 모델에 table=True 옵션을 주면 from_orm, parse_obj에서 validation 과정을 진행하지 않는다."}},{"name":"fastapi 튜토리얼 -3- sql 모델 정의","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## **cleanings** 모델 생성\n\n### 모델 정의\n\n작성 전 미리 전반적인 내용을 훑어보니, `repository`는 **`sqlmodel`** 사용시 딱히 의미가 없는 모듈이므로 제거하자.\n또한, 지난 글에서 임시로 생성한 `models`의 위치가 `db`의 하위 모듈이 아닌 `app`의 하위 모듈로 결정됐기에 같이 수정한다.\n\n```bash\n❯ rm -rf backend/app/db/repositories\n❯ mv backend/app/db/models backend/app/models\n❯ touch backend/app/models/__init__.py\n❯ mv backend/app/models/base.py backend/app/models/core.py\n❯ mv backend/app/models/temp.py backend/app/models/cleaning.py\n```\n\n```python\n# backend/app/models/core.py\nfrom typing import Any, TypeVar, cast\n\nfrom sqlmodel import Field, SQLModel, Table\n\n_T = TypeVar(\"_T\", bound=SQLModel)\n\n\nclass fix_parse_obj_model(SQLModel):\n    \"\"\"\n    sqlmodel에서 parse_obj 리턴값 정상적으로 수정하기 전까지 사용\n    \"\"\"\n    @classmethod\n    def parse_obj(cls: type[_T], obj: Any, update: dict[str, Any] | None = None) -\u003e _T:\n        return cast(_T, super().parse_obj(obj, update))\n\n\nclass base_model(fix_parse_obj_model):\n    @classmethod\n    def get_table(cls) -\u003e Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n\n\nclass id_model(fix_parse_obj_model):\n    id: int | None = Field(None, primary_key=True)\n```\n\n```python\n# backend/app/models/cleaning.py\nfrom enum import Enum\n\nfrom pydantic import condecimal\nfrom sqlmodel import Field\n\nfrom .core import base_model, id_model\n\nprice_decimal_type = condecimal(max_digits=10, decimal_places=2)\n\n\nclass cleaning_type_enum(str, Enum):\n    dust_up = \"dust_up\"\n    spot_clean = \"spot_clean\"\n    full_clean = \"full_clean\"\n\n\nclass cleaning_base(base_model):\n    name: str | None = None\n    description: str | None = None\n    cleaning_type: cleaning_type_enum = cleaning_type_enum.spot_clean\n    price: price_decimal_type | None = None\n\n\nclass cleaning_create(cleaning_base):\n    name: str\n    price: price_decimal_type\n\n\nclass cleaning_update(cleaning_base):\n    cleaning_type: cleaning_type_enum | None = None\n\n\nclass cleanings(id_model, cleaning_base, table=True):\n    name: str = Field(index=True)\n    cleaning_type: cleaning_type_enum = Field(\n        cleaning_type_enum.spot_clean,\n        sa_column_kwargs={\"server_default\": cleaning_type_enum.spot_clean},\n    )\n    price: price_decimal_type\n\n\nclass cleaning_public(id_model, cleaning_base):\n    ...\n```\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -\u003e None:\n    import sys\n    from pathlib import Path\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n\n(...)\n```\n\n`get_table` 메소드가 정의된 `base_model`을 상속하는 5개 모델은 각 리소스에 사용될 패턴을 보여준다.\n\n\u003e - `cleaning_base`: 공유 속성\n\u003e - `cleaning_create`: 새로운 리소스를 생성 ~ **POST**\n\u003e - `cleaning_update`: 기존 리소스를 수정 ~ **PUT**\n\u003e - `cleaning`: 데이터베이스에 정의될 테이블이자 레코드 ~ **GET**, **POST**, **PUT**,...\n\u003e - `cleaning_public`: 레코드에 대한 반환 형태 ~ **GET**, **POST**, **PUT**,...\n\n### `session` 모듈 정의\n\n원 작성자인 **jeffastor**는 이후 `repository` 모듈을 생성하여 CRUD 과정에 필요한 프로세스를 구현했지만, **`sqlmodel`** 을 사용하기에 그러한 과정이 따로 필요하지 않다.\n앱에서 사용할 `session`에 대해서만 따로 정의한다.\n\n```bash\n❯ touch backend/app/db/session.py\n```\n\n```python\n# backend/app/db/session.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n\nasync def get_database(request: Request) -\u003e AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -\u003e AsyncIterator[AsyncSession]:\n    async with AsyncSession(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n## `cleanings` 모델 `api` 예시\n\n### `cleanings` 레코드 추가 `POST` `api` 예시\n\n이제 세션을 활용한 간단한 형태의 **POST** api를 생성한다.\n\n```python\n# backend/app/api/routes/cleanings.py\nfrom fastapi import APIRouter, Body, Depends\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom starlette.status import HTTP_201_CREATED\n\nfrom ...db.session import get_session\nfrom ...models.cleaning import cleaning_create, cleaning_public, cleanings\n\nrouter = APIRouter()\n\n\n@router.get(\"/\")\nasync def get_all_cleanings() -\u003e list[dict]:\n    cleanings = [\n        {\n            \"id\": 1,\n            \"name\": \"My house\",\n            \"cleaning_type\": \"full_clean\",\n            \"price_per_hour\": 29.99,\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Someone else's house\",\n            \"cleaning_type\": \"spot_clean\",\n            \"price_per_hour\": 19.99,\n        },\n    ]\n    return cleanings\n\n\n@router.post(\n    \"/\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\nasync def create_new_cleaning(\n    new_cleaning: cleaning_create = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    # data = cleanings.from_orm(new_cleaning) 으로 해도 가능\n    # exclude_none=True, exclude_unset=True 옵션을 위해 parse_obj 사용\n    data = cleanings.parse_obj(\n        new_cleaning.dict(\n            exclude_none=True,\n            exclude_unset=True,\n        )\n    )\n    session.add(data)\n    await session.flush()\n    await session.commit()\n    await session.refresh(data)\n\n    return data\n```\n\n이제 **`docker`** 로 서비스를 실행하고, [http://localhost:8000/docs](http://localhost:8000/docs)에서 생성한 **POST** api가 정상적으로 작동하는지 확인한다.\n\n`body`에 값을\n\n```yaml\n{\n  'new_cleaning':\n    { 'name': 'string', 'description': 'string', 'cleaning_type': 'asd', 'price': 0 },\n}\n```\n\n이렇게 주면\n\n```yaml\n{\n  'detail':\n    [\n      {\n        'loc': ['body', 'new_cleaning', 'cleaning_type'],\n        'msg': \"value is not a valid enumeration member; permitted: 'dust_up', 'spot_clean', 'full_clean'\",\n        'type': 'type_error.enum',\n        'ctx': { 'enum_values': ['dust_up', 'spot_clean', 'full_clean'] },\n      },\n    ],\n}\n```\n\n이렇게 왜 에러(422)가 나는지 친절하게 설명도 해준다.\n정상적인 값을 넣으면\n\n```yaml\n{\n  'new_cleaning':\n    { 'name': 'test', 'description': 'test', 'cleaning_type': 'dust_up', 'price': 123 },\n}\n```\n\n설정한대로\n\n```yaml\n{\n  'name': 'test',\n  'description': 'test',\n  'cleaning_type': 'dust_up',\n  'price': 123,\n  'id': 1,\n}\n```\n\n`cleaning_public`의 스키마에 맞게 값을 반환(201)한다. 만약 `cleaning_public`가 `id_model`을 상속하도록 정의하지 않았다면 `id`속성은 생략된 채로 반환됐을 것이다.\n\n\u003e **`fastapi`** 가 위 **POST** api에서 실행한 과정\n\u003e\n\u003e 1. **`json`** 형태의 `body`를 읽는다.\n\u003e 2. `body`의 값을 검증한다. ~ **`pydantic`**\n\u003e 3. 검증 결과에 따라 에러를 반환하거나, 생성한 모델 객체로 계산한 결과를 반환한다.\n\n### `FastAPI`의 `DI` 사용법\n\n`Depends`로 변수를 처리하는 방식이 생소할 수 있다. 사용자의 요청을 처리하는 방식을 사전에 호출 가능한 형태로 정의하고, 그 과정을 한번에 실행한 결과를 파라미터로 받아서 사용할 수 있게 한다.\n\n직전에 생성한 `session.py`에서 `get_database`가 `request`를 받고,\n`get_session`이 `get_database`를 받고,\n`create_new_cleaning`이 `get_session`을 받아서 `session`객체를 파라미터로 사용할 수 있게 한다.\n\n마지막으로, sql 서버에서 정상적으로 레코드가 입력됐는지 확인해본다.\n\n```bash\nbash-5.1# psql -h localhost -U postgres --dbname=postgres\npsql (14.2)\nType \"help\" for help.\n\npostgres=# select * from cleanings;\n name | description | cleaning_type | price  | id\n------+-------------+---------------+--------+----\n test | test        | dust_up       | 123.00 |  1\n(1 row)\n```\n\n다음에는 **`pytest`** 를 활용한다.\n**`alembic`** 처럼 사용해본적이 없기에 기대가 된다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -3- sql 모델 정의","data":{"title":"fastapi 튜토리얼 -3- sql 모델 정의","date":"2022-04-28T21:51:36.869+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"FastAPI, sqlmodel로 간단한 crud api 생성 4","content":"\n이제 기존에 작성한 `crud` api를 보완해보겠습니다.\n\n## 유저를 추가할때 중복 확인\n\n기존 작성된 `create` api는 입력받은 `body`를 그대로 db에 새로운 레코드로 추가하는 역할만 했습니다.\n이제 `email`속성을 기준으로 중복을 확인 한 다음 레코드로 추가할 수 있게 코드를 수정하겠습니다.\n\n```python\n# api/scripts/routes/user/crud.py\n(전략)\n\n@app.post(\"/create_user\", response_model=user.user)\nasync def create_user(data: user.user, *, session: AsyncSession = Depends(get_session)):\n    user_email = await session.exec(select(user.user.email))  # type: ignore\n    if data.email in user_email: # type: ignore\n        raise HTTPException(status_code=400, detail=\"동일한 email 유저 있음\")\n\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n(후략)\n```\n\n이제 중복된 유저 데이터를 입력하면 다음과 같은 400에러와 함께 다음과 같은 값을 반환합니다.\n\n```json\n{\n  \"detail\": \"동일한 email 유저 있음\"\n}\n```\n\n로그를 확인해보면 다음과 같이 에러를 반환하는 것을 확인할 수 있습니다.\n\n```sql\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".email\nFROM \"user\"\nINFO sqlalchemy.engine.Engine [no key 0.00018s] ()\nINFO:     10.0.2.100:43750 - \"POST /user/create_user HTTP/1.1\" 400 Bad Request\nINFO sqlalchemy.engine.Engine ROLLBACK\n```\n\n만약 중복이 아닌 데이터를 입력하면, 다음과 같은 로그를 확인할 수 있습니다.\n\n```sql\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".email\nFROM \"user\"\nINFO sqlalchemy.engine.Engine [no key 0.00016s] ()\nINFO sqlalchemy.engine.Engine INSERT INTO \"user\" (name, email, registered_date) VALUES (%s, %s, %s) RETURNING \"user\".id\nINFO sqlalchemy.engine.Engine [cached since 276.6s ago] ('test', 'test@example.com', datetime.datetime(--))\nINFO sqlalchemy.engine.Engine COMMIT\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".id, \"user\".name, \"user\".email, \"user\".registered_date\nFROM \"user\"\nWHERE \"user\".id = %s\nINFO sqlalchemy.engine.Engine [cached since 276.6s ago] (3,)\nINFO:     10.0.2.100:43796 - \"POST /user/create_user HTTP/1.1\" 200 OK\nINFO sqlalchemy.engine.Engine ROLLBACK\n```\n\n\u003e 지금은 api 서버에서 처리하는 방법을 보이기 위해 이렇게 코드를 작성했습니다.\n\u003e 하지만 **더 간단하게 중복을 제외하는 방법**이 있습니다.\n\u003e `user.user` 모델을 정의할 때, `email` 필드에 `sa_column_kwargs={\"unique\": True}` 파라미터를 추가하면 됩니다.\n\u003e 그러면 api 서버가 아닌, db에서 중복을 확인하고, 에러를 반환할 것입니다.\n\u003e 다만, **이 에러에 대한 예외처리는 직접 해야합니다.**\n\n## 유저 정보를 수정한 최종 일자 기록\n\n기존 `user` 모델은 최초 입력 일자에 대한 정보만 보존하고, 수정한 일자에 대해서는 보존하지 않습니다. 이는 테이블에 새로운 필드를 추가해야 가능한 일이므로, `user`모델을 직접적으로 수정하겠습니다.\n\n```python\n# api/scripts/models/user/__init__.py\n(전략)\n\nclass user(SQLModel, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n    registered_date: datetime = Field(default_factory=datetime.today)\n    last_updated_date: datetime = Field(default_factory=datetime.today)\n```\n\n`last_updated_date` 필드만 추가하고 끝냈습니다.\n지금 이상태 그대로 진행하면 `update` api를 수정하더라도, 에러를 반환할 것입니다. 기존에 db 생성한 `user`테이블에는 `last_updated_date` 필드가 없기 때문입니다.\nsql의 `alter` 쿼리를 사용해도 되고, `sqlalchemy`의 `drop_all` 메소드를 사용해도 됩니다.\n지금은 개발 초기중의 초기이므로 `drop_all`로 해결하겠습니다.\n\n```python\n# api/scripts/database/default.py\n(전략)\n\nasync def create_model_table() -\u003e None:\n    async with engine.begin() as conn:\n        if settings.debug:\n            await conn.run_sync(SQLModel.metadata.drop_all)\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\n기존에 없던 `await conn.run_sync(SQLModel.metadata.drop_all)`를 추가했습니다.\n`create_model_table`함수가 이미 서버를 시작할때 실행되도록 설정돼 있기 때문에, 이제 서버를 시작하면 작성한 모델에 대응하는 테이블을 모두 `drop`하고 다시 `create`할 것입니다.\n개발중에만 사용하자는 의미로 `settings.debug`를 확인하도록 했습니다. 실제로는 더 엄격하게 확인하는게 맞습니다.\n\n이제 `update` api를 수정하겠습니다.\n\n```python\n# api/scripts/routes/user/crud.py\n\nfrom datetime import datetime\n\nfrom fastapi import Depends, HTTPException, Path\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ...database import get_session\nfrom ...models import user\nfrom .app import app\n\n(중략)\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user)\nasync def update_user(\n    data: user.user,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    user_instance.last_updated_date = datetime.today()\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n(후략)\n```\n\n`user_instance.last_updated_date = datetime.today()`가 추가됐습니다.\n이제 정상적으로 `update` api가 실행되면, `last_update_date` 값이 변합니다.\n\n실제로 실행해보면, 다음과 같은 결과를 반환받습니다.\n\n```json\n{\n  \"id\": 1,\n  \"registered_date\": \"2021-11-26T23:59:37.359332\",\n  \"last_updated_date\": \"2021-11-26T23:59:52.837064\",\n  \"name\": \"aaa\",\n  \"email\": \"user@example.com\"\n}\n```\n\n## 각 api의 `response_model`과 `body` 형태 수정\n\n지금까지 작성된 `crud` api는 `delete`를 제외하고 `response_model=user.user` 파라미터를 가지고 있습니다. 이것은 반환한 값이 `user.user` 인스턴스이고, `user.user` 의 스키마로 데이터를 반환해라는 의미입니다.\n\n하지만 모든 api에서 그렇게 하는 것은 **위험한 일**입니다.\n지금은 따로 설정하지 않았지만 사용자의 **비밀번호**가 필드에 있을 수도 있고, **민감한 개인정보** 또한 가능합니다.\n\n또한 입력받는 `body` 역시 `user.user`의 스키마로 구성된 데이터를 받습니다. 하지만 이것은 불필요한 일이고, 어쩌면 **오류를 발생시킬 수도 있습니다.**\n\n사용자가 `user`를 추가할 때, `id`나 `registered_date`와 같이 레코드에 자동으로 입력되는 값은 **사용자가 입력한 값을 받을 필요도 없고, 받아선 안되는 값입니다.**\n\n따라서, 사용자가 입력하는 값과, 사용자에게 반환할 값에 대한 새로운 스키마가 필요합니다. 이에 대한 모델을 새로 생성하면서, 기존의 모델을 정의하는데 있어서 **약간의 변화**를 주겠습니다.\n\n```python\n# api/scripts/models/user/__init__.py\n\n(전략)\n\nclass user_base(SQLModel):\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n\n\nclass user_create(user_base):\n    pass\n\n\nclass user_read(user_base):\n    id: int\n\n\nclass user_update(user_base):\n    name: Optional[str] = Field(None, min_length=1)\n    email: Optional[EmailStr] = None\n\n\nclass user(user_base, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    registered_date: datetime = Field(default_factory=datetime.today)\n    last_updated_date: datetime = Field(default_factory=datetime.today)\n```\n\n`user_base`를 기준으로 `create`, `read`, `update`에 대응하는 모델과 `user` 테이블에 해당하는 모델을 생성했습니다.\n\n\u003e `user_update`는 `user_base`에서 정의된 모든 필드를 덮어씌우지만, 그렇지 않은 경우도 있을 수 있으니 일단 상속했습니다.\n\n이전에 `table=True` 파라미터가 있어야 db에 테이블이 생성된다고 한 적이 있습니다. 위 코드에서 확인할 수 있듯이, `user` 클래스만 `table=True` 파라미터를 가지고 있습니다. 따라서 `user` 클래스를 제외한 모델은 사실상 `pydantic`의 모델로 활용하게 됩니다.\n\n이제 이 모델을 적용한 `crud` api를 수정합니다.\n\n```python\n# api/scripts/routes/user/crud.py\n\n(전략)\n\n@app.post(\"/create_user\", response_model=user.user_read)\nasync def create_user(\n    data: user.user_create, *, session: AsyncSession = Depends(get_session)\n):\n    user_email = await session.exec(select(user.user.email))  # type: ignore\n    if data.email in user_email:  # type: ignore\n        raise HTTPException(status_code=400, detail=\"동일한 email 유저 있음\")\n\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.get(\"/get_user/{user_id}\", response_model=user.user_read)\nasync def get_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    return user_instance\n\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user_read)\nasync def update_user(\n    data: user.user_update,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    user_instance.last_updated_date = datetime.today()\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.delete(\"/delete_user/{user_id}\")\nasync def delete_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    await session.delete(user_instance)\n    await session.commit()\n\n    return user_id\n```\n\n`reponse_model`을 `user.user_read`로 수정하고, `body`에 해당하는 `data`의 타입을 `user.user_create` 또는 `user.user_update`로 수정했습니다.\n`response_model`을 `user.user_read`로 정했기 때문에, `user.user` 인스턴스를 반환하더라도, `user.user_read`의 스키마에 따라 값이 반환됩니다.\n![](/images/9a191a49-09af-4cad-acf6-fe48c31b5fa5-docs.png)\ndocs에서 한 눈에 확인 가능합니다.\n\n## 끝으로..\n\n더 적고 싶은데, 더 적을게 뭐가 있을지 잘 모르겠어요.\n일단 여기서 중단\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성 4","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성 4","date":"2021-11-27T00:28:51.285+09:00","tags":["crud","fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"이제 기존에 작성한 crud api를 보완해보겠습니다."}}]},"__N_SSG":true},"page":"/posts/@tag/[...tag]","query":{"tag":["sqlmodel","1"]},"buildId":"MQ_lMVQgBI0RkmUA6wvVT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>