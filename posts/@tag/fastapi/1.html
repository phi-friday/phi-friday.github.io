<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="author" content="phi.friday@gmail.com, phi"/><meta name="robots" content="index,follow,noarchive"/><meta name="google-site-verification" content="lW107Dj5ageygd67UUzTm-kGls5d-THy9jJQZqLoauw"/><title>phi.log</title><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e61452b80f7f8356.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e61452b80f7f8356.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c0b66b64eb886a29.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0b66b64eb886a29.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-5dc3bdee87ff18dd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f6271bdec05edb1f.js" defer=""></script><script src="/_next/static/chunks/996-f3cf67c2e3ac5e06.js" defer=""></script><script src="/_next/static/chunks/756-1349105dbea71525.js" defer=""></script><script src="/_next/static/chunks/224-ddba219ecdd5c904.js" defer=""></script><script src="/_next/static/chunks/pages/posts/@tag/%5B...tag%5D-5364b6481a3135f4.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_buildManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_ssgManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style>
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: #29D;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow: 0 0 10px #29D, 0 0 5px #29D;
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: #29D;
        border-left-color: #29D;
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style><div class="container" style="max-width:900px;min-width:400px"><div class="container default_app"><header><div class="container"><nav class="navbar-light fixed-top navbar navbar-expand-sm bg-light" role="navigation"><div class="container" style="max-width:900px"><div class="container-fluid"><ul class="navbar-nav w-100"><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-home"></i> Home</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@tag"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-hashtag"></i> Post</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@page"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-blog"></i> Page</div></a></li><div class="container d-flex justify-content-end align-self-center"><div class="row"><div class="col"><form class="input-group w-auto" method="get" action="https://www.google.com/search" target="_blank" style="min-width:230px"><input type="hidden" name="sitesearch" value="phi-friday.github.io"/><input type="search" class="form-control" placeholder="Search in Google" aria-label="Search" name="q" maxLength="255"/><button class="ripple ripple-surface btn btn-outline-primary" role="button"><i class="fa fa-search"></i></button></form></div></div></div></ul></div></div></nav></div></header><main><div class="container"><div class="row"><div><span><span class="badge bg-light mx-1 text-dark">@all<!-- --> <span class="badge bg-danger">25</span></span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> <span class="badge bg-danger">21</span></span></span><span><span class="badge bg-primary mx-1">#fastapi<!-- --> <span class="badge bg-danger">14</span></span></span><span><span class="badge bg-light mx-1 text-dark">#sqlmodel<!-- --> <span class="badge bg-danger">8</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#crud<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#returns<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#windows<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#wsl<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#tdd<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#anyio<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#async<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vim<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#js<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#ts<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#nextjs<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#velog<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#github<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#restful<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#pytest<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#alembic<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#postgres<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#black<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#isort<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vscode<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#asyncio<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#trio<!-- --> <span class="badge bg-danger">1</span></span></span></div></div><div class="row"><div class="container"><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-primary mx-1">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#sqlmodel<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-07T23:00:58.369+09:00">ì‘ì„±ì¼: 2022ë…„ 5ì›” 7ì¼</time></h6></p></p><p class="card-text">fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-primary mx-1">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#sqlmodel<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ì… ë¬¸ì œ ì„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-07T22:08:12.781+09:00">ì‘ì„±ì¼: 2022ë…„ 5ì›” 7ì¼</time></h6></p></p><p class="card-text">fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-primary mx-1">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-06T06:26:51.932+09:00">ì‘ì„±ì¼: 2022ë…„ 5ì›” 6ì¼</time></h6></p></p><p class="card-text">fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-primary mx-1">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi íŠœí† ë¦¬ì–¼ -7- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 2</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-05T06:13:07.421+09:00">ì‘ì„±ì¼: 2022ë…„ 5ì›” 5ì¼</time></h6></p></p><p class="card-text">fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-primary mx-1">#fastapi<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi íŠœí† ë¦¬ì–¼ -6- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„±</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-03T01:35:06.494+09:00">ì‘ì„±ì¼: 2022ë…„ 5ì›” 3ì¼</time></h6></p></p><p class="card-text">fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.</p></div></div></div></div><div class="row"><ul class="pagination justify-content-center"><li class="page-item disabled"><a class="page-link" href="/posts/@tag/fastapi/1"><i class="fa fa-angle-double-left"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/fastapi/0"><i class="fa fa-angle-left"></i></a></li><li class="page-item active"><a class="page-link">1</a></li><li class="page-item" href="/posts/@tag/fastapi/2"><a class="page-link">2</a></li><li class="page-item" href="/posts/@tag/fastapi/3"><a class="page-link">3</a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/fastapi/6"><i class="fa fa-angle-right"></i></a></li><li class="page-item"><a class="page-link" href="/posts/@tag/fastapi/3"><i class="fa fa-angle-double-right"></i></a></li></ul></div></div></main><footer class="text-center text-muted"></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"fastapi","page":1,"max_page":3,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `Breaking` `changes`\n\nì´í‹€ì „ **`fastapi-users`** ì— í° ë³€í™”ê°€ ìƒê²¼ë‹¤. `v10` ë¦´ë¦¬ì¦ˆê°€ ê³µê°œëëŠ”ë°, `db` ëª¨ë¸ê³¼ ì—¬ëŸ¬ ì œë„¤ë¦­ íƒ€ì…ì— ëŒ€í•œ ë³€í™”ê°€ ìƒê²¨ì„œ, `v10`ì„ ì´ìš©í•˜ë ¤ë©´ ëŒ€ì‘ íŒ¨ì¹˜ê°€ í•„ìˆ˜ì ì¸ ìƒí™©..\n\nì•„ë˜ëŠ” í•´ë‹¹ ë¦´ë¦¬ì¦ˆì— ëŒ€í•œ ì „ë¬¸ì´ë‹¤.\n\n\u003e ### [Breaking changes](https://github.com/fastapi-users/fastapi-users/releases/tag/v10.0.0)\n\u003e\n\u003e Version 10 marks important changes in how we manage User models and their ID.\n\u003e\n\u003e Before, we were relying only on Pydantic models to work with users. In particular the current_user dependency would return you an instance of UserDB, a Pydantic model. This proved to be quite problematic with some ORM if you ever needed to retrieve relationship data or make specific requests.\n\u003e\n\u003e Now, FastAPI Users is designed to always return you a native object for your ORM model, whether it's an SQLAlchemy model or a Beanie document. Pydantic models are now only used for validation and serialization inside the API.\n\u003e\n\u003e Before, we were forcing the use of UUID as primary key ID; a consequence of the design above. This proved to be quite problematic on some databases, like MongoDB which uses a special ObjectID format by default. Some SQL folks also prefer to use traditional auto-increment integers.\n\u003e\n\u003e Now, FastAPI Users is designed to use generic ID type. It means that you can use any type you want for your user's ID. By default, SQLAlchemy adapter still use UUID; but you can quite easily switch to another thing, like an integer. Beanie adapter for MongoDB will use native ObjectID by default, but it also can be overriden.\n\n### ìœ ì € ëª¨ë¸ ìƒì„± ë° ìˆ˜ì •\n\nê¸°ì¡´ `fastapi_users.models` ì—ì„œ `fastapi_users.schemas`ë¡œ ë°”ë€ ê²ƒ ì™¸ì— í¬ê²Œ ë‹¬ë¼ì§„ ê²ƒì€ ì—†ë‹¤. ì‚¬ì‹¤ ì´ì „ì— ì–˜ê¸°í–ˆë˜ `user` ì™€ `user_model`ì„ í†µí•©í•˜ëŠ” ì‘ì—…ì„ ì´ë¯¸ í•œ ë‹¤ìŒ `v10` ë¦´ë¦¬ì¦ˆë¥¼ í™•ì¸í–ˆê¸°ì— ë”ìš± ê·¸ë ‡ê²Œ ëŠê»´ì¡Œë‹¤...\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar\n\nfrom fastapi_users import schemas\nfrom pydantic import EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field, select\n\nfrom ..db.session import async_session\nfrom .core import base_model, datetime_model, uuid_id_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\n_T = TypeVar(\"_T\", bound=\"user\")\nid_model = uuid_id_model\nuser_id_type = id_model.id_type\n\n\nclass user(id_model, datetime_model, base_model, table=True):\n    __tablename__: str = \"users\"\n\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: async_session, email: str\n    ) -\u003e _T | None:\n        is_user_cur = await session.exec(select(cls).where(cls.email == email))\n        return is_user_cur.first()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.validate(self)\n\n\nclass user_read(schemas.BaseUser[user_id_type], datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(schemas.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(schemas.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n```\n\n### ì¸ì¦ ëª¨ë“ˆ ì œë„¤ë¦­ íƒ€ì… ë®ì–´ì”Œìš°ê¸°\n\n**`fastapi-users`** ì—ì„œ ì›í•˜ëŠ” í˜•íƒœëŠ” `SQLAlchemyBaseUserTable`ë¥¼ ìƒì†í•œ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ì§€ë§Œ, **`sqlmodel`** ë„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³  **`fastapi-users`** ì˜ íƒ€ì… íŒíŠ¸ë„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê³  ì‹¶ê¸°ì—, ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì—®ì–´ì¤„ ìƒˆë¡œìš´ ì œë„¤ë¦­ í´ë˜ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.\n`# type: ignore`ë¥¼ ë‚¨ë°œí•˜ê¸°ì— ê·¸ë‹¤ì§€ ì¢‹ì€ ëª¨ìŠµì´ë¼ê³  ìƒê°ë˜ì§€ ì•Šì§€ë§Œ, ì´ê±° ì™¸ì— ë‹¹ì¥ ìƒê°ë‚˜ëŠ” ë°©ë²•ì´ ì—†ê¸°ì— ì¼ë‹¨ ë„˜ì–´ê°€ì.\n\n```bash\nâ¯ mkdir backend/app/services/authentication\nâ¯ mv backend/app/services/authentication.py backend/app/services/authentication/authentication.py\nâ¯ touch backend/app/services/authentication/__init__.py backend/app/services/authentication/convert.py\n```\n\n```python\n# backend/app/services/authentication/__init__.py\nfrom .authentication import *\n```\n\n```python\n# backend/app/services/authentication/convert.py\nfrom typing import Generic, TypeVar\n\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import AuthenticationBackend, JWTStrategy, Strategy\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n\nfrom ...models.core import base_model\nfrom ...models.user import user\n\nuser_id_type = user.id_type\n_T = TypeVar(\"_T\", bound=base_model)\n_D = TypeVar(\"_D\")\n\n# fmt: off\nclass user_db_class(SQLAlchemyUserDatabase[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass strategy_class(Strategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass jwt_strategy_class(JWTStrategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass auth_backend_class(AuthenticationBackend[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass user_manager_class(BaseUserManager[_T, _D], Generic[_T, _D]): ...  # type: ignore\nclass fastapi_users_class(FastAPIUsers[_T, _D], Generic[_T, _D]): ...  # type: ignore\n# fmt: on\n\n\nuser_manager_type = user_manager_class[user, user_id_type]\nstrategy_type = strategy_class[user, user_id_type]\n```\n\n### ë³€ê²½ì  ì¸ì¦ ëª¨ë“ˆì— ì ìš©\n\n```python\n# backend/app/services/authentication/authentication.py\nimport re\nfrom dataclasses import dataclass\nfrom re import Pattern\nfrom typing import AsyncGenerator, Sequence\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import IntegerIDMixin, InvalidPasswordException\nfrom fastapi_users.authentication import BearerTransport, Transport\n\nfrom ...core import config\nfrom ...db.session import async_session, get_session\nfrom ...models import user\nfrom .convert import (\n    auth_backend_class,\n    fastapi_users_class,\n    jwt_strategy_class,\n    strategy_class,\n    strategy_type,\n    user_db_class,\n    user_id_type,\n    user_manager_class,\n    user_manager_type,\n)\n\n\nasync def get_user_db(\n    session: async_session = Depends(get_session),\n) -\u003e AsyncGenerator[user_db_class[user.user, user_id_type], None]:\n    yield user_db_class(session, user.user)\n\n\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\n\ndef create_strategy() -\u003e strategy_class[user.user, user_id_type]:\n    return jwt_strategy_class(  # type: ignore\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n\ndef create_backend() -\u003e list[auth_backend_class[user.user, user_id_type]]:\n    transport = create_transport()\n    return [\n        auth_backend_class(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n\n\nclass UserManager(IntegerIDMixin, user_manager_class[user.user, user_id_type]):\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+\u003c\u003e@\\#$%\u0026\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -\u003e None:\n        if len(password) \u003c self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) \u003e self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\n        for pattern in self.re_password_deny_list:\n            if pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\n        for pattern in self.re_password_need_list:\n            if not pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -\u003e AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(\n    *backends: auth_backend_class[user.user, user_id_type],\n) -\u003e fastapi_users_class[user.user, user_id_type]:\n    return fastapi_users_class(\n        get_user_manager=get_user_manager, auth_backends=backends\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -\u003e Sequence[auth_backend_class[user.user, user_id_type]]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def user_manager_depends(self) -\u003e user_manager_type:\n        return Depends(self.users.get_user_manager)\n\n    def strategy_depends(self, num: int = 0, /) -\u003e strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\nê½¤ ë§ì´ ë°”ë€Œê¸´ í–ˆì§€ë§Œ, ì‹¤ì œë¡œ ì‚¬ìš©í• ë•ŒëŠ” ì´ë¦„ì •ë„ë§Œ ë°”ë€Œì§€ ì‚¬ìš©ë²• ìì²´ëŠ” ë³€í•œê²Œ ì—†ë‹¤. ë°”ë€ ì´ë¦„ì— ë§ì¶°ì„œ ë¼ìš°í„°ì™€ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìˆ˜ì •í•´ì£¼ë©´, ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\nì´ë²ˆ ê¸°íšŒì— í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì–¼ë§ˆë‚˜ ì¢‹ì€ê±´ì§€ ì•Œê²Œëë‹¤.. ê¸´ê°€ë¯¼ê°€í• ë•Œ `pytest --tb=short` í•œë°©ì´ë©´ ì˜ë¬¸ì´ í•´ê²°ëœë‹¤.\n\nì‚¬ì‹¤ ë³€ê²½í• ê²Œ í•˜ë‚˜ ë” ë‚¨ê¸´ í–ˆì§€ë§Œ, ì´ê±° ì•„ì§ ì‹œë„í•´ë³´ì§€ ì•Šì•˜ë‹¤.\ní˜„ì¬ í—¤ë”ë¥¼ ì‚¬ìš©í•œ ì¸ì¦ ë°©ì‹ì¸ë°, ì¿ í‚¤ë¥¼ ì‚¬ìš©í•˜ê³ , `access-token`ê³¼ `refresh-token`ì„ ì‚¬ìš©í•œ ë°©ì‹ìœ¼ë¡œ ë³€ê²½í•´ë³´ë ¤ í•œë‹¤. ë‹¤ë§Œ **`fastapi-users`** ìì²´ì ìœ¼ë¡œëŠ” ì§€ì›í•˜ì§€ ì•Šê¸°ì—, ì§ì ‘ ì‘ì„±í•  í•„ìš”ê°€ ìˆì–´ì„œ ì•½ê°„ ê³ ë¯¼ì´ í•„ìš”í• ë“¯.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8.2- FastAPI Users v10 ëŒ€ì‘","date":"2022-05-07T23:00:58.369+09:00","tags":["fastapi","fastapi-users","python","sqlmodel","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ì… ë¬¸ì œ ì„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `Session`ì˜ ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ë³µë¶™\n\nì´ì „ê¹Œì§€ ê¸€ì—ì„œ ê³„ì†í•´ì„œ `AsyncSession`ì˜ íƒ€ì… ê´€ë ¨ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ”ê²Œ ë„ˆë¬´ ì§œì¦ë‚˜ì„œ, ì„ì‹œë¡œ ë•œë¹µìš© í´ë˜ìŠ¤ë¥¼ ìƒì„±í•´ì„œ ì‚¬ìš©í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n````python\n# backend/app/db/session.py\n(...)\n\n_TSelectParam = TypeVar(\"_TSelectParam\")\n\nclass async_session(AsyncSession):\n    # sqlmodel.orm.session.Session\n    @overload\n    async def exec(\n        self,\n        statement: Select[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Result[_TSelectParam]:\n        ...\n\n    @overload\n    async def exec(\n        self,\n        statement: SelectOfScalar[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e ScalarResult[_TSelectParam]:\n        ...\n\n    async def exec(\n        self,\n        statement: Union[\n            Select[_TSelectParam],\n            SelectOfScalar[_TSelectParam],\n            Executable[_TSelectParam],\n        ],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Union[Result[_TSelectParam], ScalarResult[_TSelectParam]]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().exec(\n            statement,  # type: ignore\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def execute(\n        self,\n        statement: _Executable,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Optional[Mapping[str, Any]] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Result[Any]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        ***\n\n        ğŸš¨ You probably want to use `session.exec()` instead of `session.execute()`.\n\n        This is the original SQLAlchemy `session.execute()` method that returns objects\n        of type `Row`, and that you have to call `scalars()` to get the model objects.\n\n        For example:\n\n        ```Python\n        heroes = session.execute(select(Hero)).scalars().all()\n        ```\n\n        instead you could use `exec()`:\n\n        ```Python\n        heroes = session.exec(select(Hero)).all()\n        ```\n        \"\"\"\n        return await super().execute(  # type: ignore\n            statement,\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def get(\n        self,\n        entity: Type[_TSelectParam],\n        ident: Any,\n        options: Optional[Sequence[Any]] = None,\n        populate_existing: bool = False,\n        with_for_update: Optional[Union[Literal[True], Mapping[str, Any]]] = None,\n        identity_token: Optional[Any] = None,\n    ) -\u003e Optional[_TSelectParam]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().get(\n            entity,\n            ident,\n            options=options,\n            populate_existing=populate_existing,\n            with_for_update=with_for_update,\n            identity_token=identity_token,\n        )\n````\n\nì£¼ì„ì„ ë³´ë©´ ì•Œê² ì§€ë§Œ, ê·¸ëƒ¥ `sqlmodel.orm.session.Session` ê°ì²´ì˜ ê° ë©”ì†Œë“œì˜ íƒ€ì… íŒíŠ¸ë¥¼ ê·¸ëŒ€ë¡œ ê°€ì ¸ì™”ë‹¤. ì´ì— ë§ì¶°ì„œ ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸ì˜ `AsyncSession`ë„ ëª¨ë‘ `async_session`ì— ëŒ€í•œ ìŠ¤í¬ë¦½íŠ¸ë¡œ ë³€í™˜í•´ì¤€ë‹¤. ê·¸ë¦¬ê³  í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë©´ ë¬¸ì œì—†ì´ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\n---\n\n## `datetime_model` ê´€ë ¨ ë¬¸ì œ í•´ê²°\n\n`datetime_model`ì˜ `datetime_attrs` ì†ì„±ì´ ì˜ë„í•œëŒ€ë¡œ ì¶œë ¤ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ìˆì–´ì„œ ì¶”ê°€ë¡œ ìˆ˜ì •í–ˆë‹¤. `cls.__fields__.keys()` ë¥¼ `datetime_model.__fields__.keys()`ë¡œ ìˆ˜ì •í•œ ê²ƒì™¸ì— ëª¨ë‘ ë™ì¼í•˜ë‹¤.\n\n```python\n# backend/app/models/core.py\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -\u003e _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def datetime_attrs(cls) -\u003e set[str]:\n        return set(datetime_model.__fields__.keys())\n```\n\n## `id_model` ì„¸ë¶„í™”\n\nê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ `id_model`ì„ `int_id_model`ê³¼ `uuid_id_model`ë¡œ ì„¸ë¶„í™”í•´ì„œ ì‚¬ìš©í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n```python\n# backend/app/models/core.py\nfrom uuid import uuid4\nfrom pydantic import UUID4\n\n(...)\n\nclass id_model(fix_return_type_model):\n    @classmethod\n    @property\n    def id_type(cls) -\u003e Any:\n        return cls.__fields__[\"id\"].type_\n\n\nclass int_id_model(id_model):\n    id: int | None = Field(None, primary_key=True)\n\n\nclass uuid_id_model(id_model):\n    id: UUID4 | None = Field(default_factory=uuid4, primary_key=True)\n```\n\n## `dependencies` ëª¨ë“ˆ ìƒì„±\n\nê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ `get_session`ì´ë‚˜ `get_current_user`ê°™ì€ `Depends`ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë˜ í•¨ìˆ˜ë¥¼ ë”°ë¡œ ê´€ë¦¬í•˜ê¸°ë¡œ í–ˆë‹¤.\n\n```python\n# backend/app/dependencies/database.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\nfrom ..db.session import async_session\n\n\nasync def get_database(request: Request) -\u003e AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -\u003e AsyncIterator[async_session]:\n    async with async_session(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n```python\n# backend/app/dependencies/auth.py\nfrom ..services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\nget_user_manager = fastapi_user.get_user_manager\nget_backend = fastapi_user.get_backend\nget_transport = fastapi_user.get_transport\nget_strategy = fastapi_user.get_strategy\n```\n\n```python\n# backend/app/services/authentication/authentication.py\n(...)\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n    named_backends: dict[str, auth_backend_type] = field(default_factory=dict)\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -\u003e Sequence[auth_backend_type]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def get_user_manager(self):\n        return self.users.get_user_manager\n\n    def find_backend(self, _val: str, /) -\u003e auth_backend_type:\n        for backend in self.backends:\n            if backend.name == _val:\n                return backend\n        raise IndexError(f\"there is not auth_backend name: {_val}\")\n\n    def get_backend(self, _val: int | str = 0, /) -\u003e auth_backend_type:\n        if isinstance(_val, int):\n            return self.backends[_val]\n\n        if (backend := self.named_backends.get(_val)) is None:\n            backend = self.named_backends[_val] = self.find_backend(_val)\n        return backend\n\n    def get_transport(self, _val: int | str = 0, /) -\u003e Transport:\n        backend = self.get_backend(_val)\n        return backend.transport\n\n    def get_strategy(self, _val: int | str = 0, /):\n        backend = self.get_backend(_val)\n        return backend.get_strategy\n```\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ì… ë¬¸ì œ ì„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8.1- SQLModel AsyncSession ê´€ë ¨ íƒ€ì… ë¬¸ì œ ì„ì‹œ í•´ê²° + ì¶”ê°€ ìˆ˜ì •","date":"2022-05-07T22:08:12.781+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## í† í° ë°œí–‰ ë°©ì‹ ìˆ˜ì •\n\n### ê¸°ì¡´ ì½”ë“œ ìˆ˜ì •\n\nì´ì „ì— í† í° ë°œí–‰ apië¥¼ ì§ì ‘ ì‘ì„±í–ˆëŠ”ë°, ì¢€ ë” ì•Œì•„ë³´ë‹ˆ, **`fastapi-users`** ì—ì„œ ì œê³µí•˜ëŠ” `login` apiì™€ ë™ì¼í•˜ë‹¤. ë”°ë¼ì„œ í† í° ë°œí–‰ê³¼ ê´€ë ¨í•´ì„œ ì•½ê°„ì˜ ìˆ˜ì •ì„ ì§„í–‰í•œë‹¤.\n\n\u003e #### backend/app/core/config.py\n\u003e\n\u003e í† í° ê²½ë¡œ ìˆ˜ì •\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token/login\"\n```\n\n---\n\n`AUTH_BACKEND_NAME` ì¶”ê°€\n\n```python\nAUTH_BACKEND_NAME = config(\n    \"AUTH_BACKEND_NAME\", cast=str, default=f\"{JWT_TOKEN_PREFIX}-jwt\"\n)\n```\n\n\u003e #### backend/app/services/authentication.py\n\u003e\n\u003e í† í° ëª¨ë¸ ì œê±°\n\n```python\n# class token_model(BaseModel):\n#     access_token: str\n#     token_type: str = config.JWT_TOKEN_PREFIX\n\u003e\n#     @classmethod\n#     def from_token(cls, token: str) -\u003e \"token_model\":\n#         return cls(access_token=toke\n```\n\n---\n\n`AUTH_BACKEND_NAME` ì°¸ì¡° ì¶”ê°€\n\n```python\ndef create_backend() -\u003e list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n```\n\n\u003e #### backend/app/api/routes/token.py\n\u003e\n\u003e **`fastapi-users`** ë¼ìš°í„° ì¶”ê°€\n\u003e í¸ì˜ìƒ ë‹¹ë¶„ê°„ `requires_verification=False`ë¡œ í•œë‹¤.\n\n```python\n# name: auth:{backend.name}.login\nrouter.include_router(\n    fastapi_user.users.get_auth_router(\n        fastapi_user.backends[0], requires_verification=False\n    )\n)\n```\n\n---\n\nê¸°ì¡´ api ì œê±°\n\n```python\n# @router.post(\"\", name=\"users:create-token\")\n# async def create_token(\n#     credentials: OAuth2PasswordRequestForm = Depends(),\n#     user_manager: user_manager_type = fastapi_user.user_manager_depends,\n#     strategy: strategy_type = fastapi_user.strategy_depends(),\n# ) -\u003e token_model:\n#     get_user = await user_manager.authenticate(credentials)\n#     if get_user is None or not get_user.is_active:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n#         )\n#     if not get_user.is_verified:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n#         )\n\u003e\n#     token = await strategy.write_token(get_user)\n#     return token_model.from_token(token)\n```\n\n\u003e #### backend/tests/test_users.py\n\u003e\n\u003e `api_name` ìˆ˜ì •\n\n```python\nclass TestAuthTokens:\n    api_name = f\"auth:{config.AUTH_BACKEND_NAME}.login\"\n```\n\n### **`fastapi-users`** ê°€ ì œê³µí•˜ëŠ” `api`ì˜ ê²€ì¦ ë°©ì‹\n\n\u003e í˜„ì¬ ì‚¬ìš©ì¤‘ì¸ **`fastapi-users`** ì˜ ë²„ì „ì€ `9.3.1`ì´ë¼ëŠ” ê²ƒì— ìœ ì˜í•œë‹¤.\n\nìš°ì„  ì´ë©”ì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ìœ ì €ë¥¼ ì¡°íšŒ í•œ ë‹¤ìŒ, ë¹„ë°€ë²ˆí˜¸ë¥¼ ê²€ì¦í•œë‹¤.\nê·¸ë¦¬ê³  í•´ë‹¹ ìœ ì € ë ˆì½”ë“œì˜ `is_active`ê°€ `True`ì¸ì§€ í™•ì¸í•˜ê³ , `requires_verification` ê°’ì— ë”°ë¼ `is_verified`ê°€ `True`ì¸ì§€ í™•ì¸í•œë‹¤.\n\nìœ ì €ê°€ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜, `is_active=False`ì´ê±°ë‚˜, `requires_verification=True`ì´ë©´ì„œ `is_verified=False`ì¸ ê²½ìš° ì—ëŸ¬(400)ì„ ë°˜í™˜í•œë‹¤.\n\n## `TDD` ë°©ë²•ë¡ ì— ë”°ë¥¸ ë¡œê·¸ì¸ `api`\n\n### ì¼ë°˜ì ì¸ ë¡œê·¸ì¸ ë°©ì‹\n\n| ì‚¬ìš©ì                             | í”„ë¡ íŠ¸ì—”ë“œ                                    | ë°±ì—”ë“œ                         |\n| ---------------------------------- | --------------------------------------------- | ------------------------------ |\n| `name`, `password` ì…ë ¥            |                                               |                                |\n|                                    | `name`, `password` ë°±ì—”ë“œë¡œ ì „ì†¡              |                                |\n|                                    |                                               | `name`, `password` ìœ íš¨ì„± ê²€ì‚¬ |\n|                                    |                                               | í† í° ìƒì„±                      |\n|                                    |                                               | í† í° í”„ë¡ íŠ¸ì—”ë“œë¡œ ì „ì†¡         |\n|                                    | í† í° ì„ì‹œ ì €ì¥                                |\n| ë¡œê·¸ì¸ì´ í•„ìš”í•œ íŠ¹ì • í˜ì´ì§€ë¡œ ì´ë™ |                                               |                                |\n|                                    | ì €ì¥ëœ í† í°(Authorization í—¤ë”) ë°±ì—”ë“œë¡œ ì „ì†¡ |                                |\n|                                    |                                               | í† í° ìœ íš¨ì„± ê²€ì‚¬               |\n|                                    |                                               | ì»¨í…ì¸  ì „ì†¡                    |\n| ...                                | ...                                           | ...                            |\n\n### ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±\n\n```python\n# backend/tests/test_users.py\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n(...)\n\nclass TestUserLogin:\n    api_name = \"users:login-email-and-password\"\n\n    async def test_user_can_login_successfully_and_receives_valid_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -\u003e None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        login_data = {\"email\": test_user.email, \"password\": \"heatcavslakers@1\"}\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status.HTTP_200_OK\n        # check that token exists in response and has user encoded within it\n        token = res.json().get(\"access_token\")\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n            manager = UserManager(db)\n\n            read_user: user.user_model | None = await strategy.read_token(\n                token, manager\n            )\n        assert read_user is not None\n        assert read_user.name == test_user.name\n        assert read_user.email == test_user.email\n        # check that token is proper type\n        assert \"token_type\" in res.json()\n        assert res.json().get(\"token_type\") == \"bearer\"\n\n    @pytest.mark.parametrize(\n        \"credential, wrong_value, status_code\",\n        (\n            (\"email\", \"wrong@email.com\", 401),\n            (\"email\", None, 401),\n            (\"email\", \"notemail\", 401),\n            (\"password\", \"wrongpassword@1\", 401),\n            (\"password\", None, 401),\n        ),\n    )\n    async def test_user_with_wrong_creds_doesnt_receive_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        credential: str,\n        wrong_value: str,\n        status_code: int,\n    ) -\u003e None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        user_data = test_user.dict()\n        user_data[\"password\"] = \"heatcavslakers@1\"\n        user_data[credential] = wrong_value\n        login_data = {\n            \"username\": user_data[\"email\"],\n            \"password\": user_data[\"password\"],  # insert password from parameters\n        }\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status_code\n        assert \"access_token\" not in res.json()\n```\n\nì‚¬ìš©ìê°€ `email`ê³¼ `password`ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë³´ëƒˆì„ ë•Œ ì–»ê²Œ ë˜ëŠ” í† í°ìœ¼ë¡œ ë¶€í„°, **`fastapi_users`** ë¥¼ ì´ìš©í•´ì„œ ë¶ˆëŸ¬ì˜¨ ìœ ì € ë ˆì½”ë“œê°€ `test_user`ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.\n\nì—¬ê¸°ì„œ ë¡œê·¸ì¸ì˜ ê²½ìš° `json` íŒŒë¼ë¯¸í„°ê°€ ì•„ë‹Œ `data` íŒŒë¼ë¯¸í„°ë¡œ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ê³ , `content-type` í—¤ë”ë¡œ `application/x-www-form-urlencoded`ë¥¼ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤ëŠ” ì ì— ìœ ì˜í•œë‹¤.\n\n### ë¡œê·¸ì¸ `api` ì‘ì„±\n\ní† í° ë°œí–‰ apiê°€ ë¡œê·¸ì¸ apiì´ë¯€ë¡œ, ë”°ë¡œ ì‘ì„±í•  í•„ìš”ê°€ ì—†ë‹¤.\në§Œì•½ 400ì—ëŸ¬ê°€ ì•„ë‹Œ 401ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ê³  ì‹¶ë‹¤ë©´, ì´ì „ ì±•í„°ì²˜ëŸ¼ ì§ì ‘ ì‘ì„±í•˜ë©´ ëœë‹¤.\n\n### ì¸ì¦ `Depends` ìƒì„±\n\nì´ì œ í† í°ì„ ë°œê¸‰ë°›ì€ ê²½ìš°ì—ë§Œ ì‚¬ìš©ì´ ê°€ëŠ¥í•œ apiì— ëŒ€í•œ ì¸ì¦ ì ˆì°¨ë¥¼ ì •ì˜í•´ì•¼í•œë‹¤. **`fastapi`** ì—ì„œëŠ” ì´ëŸ¬í•œ ê¸°ëŠ¥ì€ `Depends`ë¥¼ ì‚¬ìš©í•´ì„œ ìƒì„±í•  ìˆ˜ ìˆë‹¤. ë˜í•œ, **`fastapi-users`** ì—ì„œ ê´€ë ¨ëœ í•¨ìˆ˜ë¥¼ ì´ë¯¸ ë§Œë“¤ì–´ì„œ ì œê³µí•˜ê³  ìˆë‹¤. ìš°ì„  í…ŒìŠ¤íŠ¸ ì½”ë“œë¶€í„° ì‘ì„±í•œë‹¤.\n\n```python\n# backend/tests/conftest.py\nfrom app.services.authentication import create_strategy\nfrom sqlmodel import select\n\n(...)\n\n@pytest.fixture\nasync def authorized_client(\n    client: AsyncClient, test_user: user.user_model\n) -\u003e AsyncClient:\n    from app.core import config\n\n    strategy = create_strategy()\n    access_token = await strategy.write_token(user=test_user)  # type: ignore\n\n    client.headers[\"Authorization\"] = f\"{config.JWT_TOKEN_PREFIX} {access_token}\"\n    return client\n```\n\në°©ê¸ˆ ì‘ì„±í•œ `authorized_client`ë¥¼ ì´ìš©í•´ì„œ ì¸ì¦ì´ í•„ìš”í•œ ë¼ìš°í„°ì— ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.\n\n\u003e ì“°ë‹¤ë³´ë‹ˆ `user.user`ì™€ `user.user_model`ì´ ë”°ë¡œ ìˆëŠ”ê²Œ ë„ˆë¬´ ë¶ˆí¸í•œë°, ì–¸ì œ í•œë²ˆ í•©ì¹˜ëŠ” ì‹œë„ë¥¼ í•´ë´ì•¼ í• ë“¯. `AsyncSession` ê´€ë ¨í•´ì„œë„ ì–¸ì œí•œë²ˆ í•´ê²°ì„ í•´ì•¼í•  ê²ƒ ê°™ê³ ..\n\n```python\n# backend/tests/test_users.py\n(...)\n\nclass TestUserMe:\n    api_name = \"users:get-current-user\"\n\n    async def test_authenticated_user_can_retrieve_own_data(\n        self,\n        app: FastAPI,\n        authorized_client: AsyncClient,\n        test_user: user.user_model,\n    ) -\u003e None:\n        res = await authorized_client.get(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_200_OK\n        res_dict: dict = res.json()\n        res_dict[\"hashed_password\"] = \"testpassword@1\"\n        read_user = user.user_model.validate(res_dict)\n        assert read_user.email == test_user.email\n        assert read_user.name == test_user.name\n        assert read_user.id == test_user.id\n\n    async def test_user_cannot_access_own_data_if_not_authenticated(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"users:get-current-user\"))\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n\n    @pytest.mark.parametrize(\n        \"jwt_prefix\",\n        (\n            (\"\",),\n            (\"value\",),\n            (\"Token\",),\n            (\"JWT\",),\n            (\"Swearer\",),\n        ),\n    )\n    async def test_user_cannot_access_own_data_with_incorrect_jwt_prefix(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        jwt_prefix: str,\n    ) -\u003e None:\n        token = await strategy.write_token(test_user)\n        res = await client.get(\n            app.url_path_for(\"users:get-current-user\"),\n            headers={\"Authorization\": f\"{jwt_prefix} {token}\"},\n        )\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n```\n\nìœ„ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•  ìˆ˜ ìˆëŠ” apië¥¼ ì‘ì„±í•œë‹¤.\n\n```python\nfrom fastapi import Depends\n\n(...)\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\n\n(...)\n\n@router.get(\"/me\", response_model=user.user_read, name=\"users:get-current-user\")\nasync def get_currently_authenticated_user(\n    current_user: user.user = Depends(get_current_user),\n) -\u003e user.user_model:\n    return current_user.to_model()\n```\n\n`optional=False, active=True, verified=False, superuser=False`ìœ¼ë¡œ ê°’ì„ ì§€ì •í–ˆê¸°ì—, í•´ë‹¹ í•¨ìˆ˜ëŠ” ì¼ì¹˜í•˜ëŠ” ìœ ì €ê°€ ì—†ê±°ë‚˜ `is_active` ê°’ì´ `False`ì´ë©´ ì—ëŸ¬(401)ì„ ë°˜í™˜í•œë‹¤.\n\ní…ŒìŠ¤íŠ¸ í†µê³¼ë„ ì˜ë˜ê³ , **`swagger`** ì—ì„œë„ í™•ì¸ì´ ê°„ë‹¨í•œ apiê°€ ìƒì„±ëë‹¤. ìœ ì € ì¸ì¦ ê´€ë ¨í•´ì„œëŠ” ì‚¬ì‹¤ìƒ ì´ê²Œ ëì´ë‹¤. ì½”ë“œë¥¼ ì¡°ê¸ˆ ë” ì •ë¦¬í•  ìˆ˜ëŠ” ìˆì§€ë§Œ í•µì‹¬ì€ ë¹„ìŠ·í•  ê²ƒì´ë‹¤.\n\në‹¤ìŒ ì±•í„°ì—ì„œëŠ” ìœ ì € í”„ë¡œí•„ì„ ì„¤ì •í•œë‹¤.\nê·¸ ì „ì— ì•ì—ì„œ ì–¸ê¸‰í•œ ìœ ì € ëª¨ë¸ê³¼ ê´€ë ¨ëœ ìˆ˜ì •ì„ ì§„í–‰í•  ìˆ˜ë„ ìˆë‹¤.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -8- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 3","date":"2022-05-06T06:26:51.932+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -7- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 2","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## ì‹œì‘í•˜ê¸° ì „ ë³€ê²½ì‚¬í•­\n\nì´ì „ ì±•í„°ì—ì„œ ë°íŒ ê²ƒ ì²˜ëŸ¼, ë‹¤ì†Œ ë‚œì¡í•˜ë‹¤ê³  ìƒê°ë˜ëŠ” ë¶€ë¶„ ëª‡ê°€ì§€ë¥¼ ìˆ˜ì •í•˜ì. ì§€ê¸ˆ ìˆ˜ì •í•œ ë¶€ë¶„ì´ ë‚˜ì¤‘ì— ì› ì˜ˆì œì—ì„œ ë‹¤ë¥¸ ë°©í–¥ìœ¼ë¡œ ìˆ˜ì •ë  ìˆ˜ë„ ìˆì§€ë§Œ, ê·¸ë•Œ ê°€ì„œ ìƒê°í•˜ì.\n\n\u003e ### backend/app/core/config.py\n\u003e\n\u003e $\\rightarrow$ 1ê°œ ì„¤ì • ë³€ìˆ˜ ìƒì„±\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token\"\n```\n\n\u003e ### backend/app/db/engine.py\n\n```python\nfrom ..core.config import DATABASE_URL\n```\n\n$\\rightarrow$ `core.config` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ..core import config\n```\n\n\u003e ### backend/app/models/user.py\n\n```python\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\u003e\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n$\\rightarrow$ `unique=True`ëŒ€ì‹  `index=True`ë¡œ ë³€ê²½\n\n```pythonê²½\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\u003e\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n\u003e ### backend/app/services/authentication.py\n\n```python\nfrom ..core.config import SECRET_KEY\n```\n\n$\\rightarrow$ `core.config` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ..core import config\n```\n\n---\n\n```python\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n```\n\n$\\rightarrow$ `models.user` ì—ì„œ ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ..models import user\n```\n\n---\n\n```python\nfrom pydantic import BaseModel\n\u003e\n(...)\n\u003e\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n\u003e\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n\u003e\n    @classmethod\n    def from_token(cls, token: str) -\u003e \"token_model\":\n        return cls(access_token=token)\n```\n\n$\\rightarrow$ ìƒˆë¡œ ì •ì˜\n\n---\n\n```python\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n```\n\n$\\rightarrow$ `config.TOKEN_PREFIX` ì„¤ì • ë³€ìˆ˜ ì°¸ì¡°\n\n```python\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n```\n\n---\n\n```python\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\u003e\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+\u003c\u003e@\\#$%\u0026\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\u003e\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -\u003e None:\n        if len(password) \u003c self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) \u003e self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\u003e\n        for pattern in self.re_password_deny_list:\n            if pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\u003e\n        for pattern in self.re_password_need_list:\n            if not pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n```\n\n$\\rightarrow$ ë¹„ë°€ë²ˆí˜¸ ìœ íš¨ì„± ê²€ì‚¬ ë¡œì§ ì¶”ê°€\n\n---\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n\u003e\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n```\n\n$\\rightarrow$ ì›ë˜ëŠ” ì‚­ì œí•˜ë ¤ í–ˆìœ¼ë‚˜, íŠ¹ì • ê¸°ëŠ¥ ì¶”ê°€ í›„ ì‚¬ìš©. ì˜ì¡´ì„±ì´ ë§ˆìŒì— ë“¤ì§€ ì•Šì§€ë§Œ, ì‚¬ì‹¤ìƒ ì„¤ì •ìš© ê°ì²´ë¼ ì¼ë‹¨ ë¬´ì‹œ.\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n\u003e\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\u003e\n    @property\n    def backends(self) -\u003e Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n\u003e\n    @property\n    def user_manager_depends(self) -\u003e user_manager_type:\n        return Depends(self.users.get_user_manager)\n\u003e\n    def strategy_depends(self, num: int = 0, /) -\u003e strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n---\n\nëìœ¼ë¡œ, **`fastapi-users`** ì˜ ê° í´ë˜ìŠ¤ê°€ ì œë„¤ë¦­ì¸ ê²ƒì„ í™•ì¸í•´ì„œ, ì´ì „ì— ì •ì˜í•œ ìœ ì € ëª¨ë¸ì„ ì´ìš©í•´ì„œ íƒ€ì… íŒíŠ¸ë¥¼ ì¶”ê°€í–ˆë‹¤. ì´í•˜ ìŠ¤í¬ë¦½íŠ¸ ì „ë¬¸\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\nfrom typing import AsyncGenerator, Sequence\n\u003e\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom pydantic import BaseModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\u003e\nfrom ..core import config\nfrom ..db.session import get_session\nfrom ..models import user\n\u003e\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n\u003e\n\u003e\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n\u003e\n    @classmethod\n    def from_token(cls, token: str) -\u003e \"token_model\":\n        return cls(access_token=token)\n\u003e\n\u003e\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n\u003e\n\u003e\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\u003e\n\u003e\ndef create_strategy() -\u003e Strategy[user.user_create, user.user]:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n\u003e\n\u003e\ndef create_backend() -\u003e list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n\u003e\n\u003e\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\u003e\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\u003e\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\u003e\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\u003e\n\u003e\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -\u003e AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\u003e\n\u003e\ndef create_fastapi_users(\n    *backends: AuthenticationBackend[user.user_create, user.user],\n) -\u003e FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user.user_base,\n        user_create_model=user.user_create,\n        user_update_model=user.user_update,\n        user_db_model=user.user,\n    )\n\u003e\n\u003e\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n\u003e\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\u003e\n    @property\n    def backends(self) -\u003e Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n\u003e\n    @property\n    def user_manager_depends(self) -\u003e user_manager_type:\n        return Depends(self.users.get_user_manager)\n\u003e\n    def strategy_depends(self, num: int = 0, /) -\u003e strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n\u003e ### backend/app/services/token.py\n\n#### ìœ„ì¹˜ ë³€ê²½\n\n`backend/app/services/token.py`\n$\\rightarrow$ `backend/app/api/routes/token.py`\n\n---\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½ì— ë”°ë¥¸ ìˆ˜ì •\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import HTTP_400_BAD_REQUEST\n```\n\n$\\rightarrow$ `fastapi.status` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```pyhon\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom fastapi_users import models\n\u003e\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -\u003e dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\u003e\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n$\\rightarrow$ ìµœìƒìœ„ ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš© + `user_manager_type`, `strategy_type`, `token_model` ì‚¬ìš©\n\n```python\nfrom ...services.authentication import strategy_type, token_model, user_manager_type\n\u003e\n(...)\n\u003e\n@router.post(\"\", name=\"users:create-token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n    strategy: strategy_type = fastapi_user.strategy_depends(),\n) -\u003e token_model:\n    get_user = await user_manager.authenticate(credentials)\n    if get_user is None or not get_user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not get_user.is_verified:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\u003e\n    token = await strategy.write_token(get_user)\n    return token_model.from_token(token)\n```\n\n\u003e ### backend/app/api/routes/cleanings.py\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½ì— ë”°ë¥¸ ìˆ˜ì •\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom ...models.cleaning import (\n    cleaning_create,\n    cleaning_public,\n    cleaning_update,\n    cleanings,\n)\n```\n\n$\\rightarrow$ `models.cleaning` ì—ì„œ ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom ...models import cleaning\n```\n\n\u003e ### backend/app/api/routes/\\_\\_init\\_\\_.py\n\n```python\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n$\\rightarrow$ `auth` ëŒ€ì‹  `token`ìœ¼ë¡œ ë‹¨ì¼í™”\n\n```python\nrouter.include_router(token_router, prefix=\"/token\", tags=[\"token\"])\n```\n\n\u003e ### backend/tests/conftest.py\n\n```python\n@pytest.fixture(\n    params=[pytest.param((\"asyncio\", {\"use_uvloop\": True}), id=\"asyncio+uvloop\")]\n)\ndef anyio_backend(request):\n    return request.param\n```\n\n$\\rightarrow$ **`pytest`** ë°±ì—”ë“œë¡œ **`anyio+uvloop`** ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì„¤ì • ì¶”ê°€\n\n\u003e ### backend/tests/test_cleanings.py\n\n```python\npytestmark = pytest.mark.asyncio\n```\n\n$\\rightarrow$ **`pytest`** ë°±ì—”ë“œë¡œ **`anyio+uvloop`** ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì„¤ì • ì¶”ê°€\n\n```python\npytestmark = pytest.mark.anyio\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` ì—ì„œ ê°’ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ\n\n```python\nfrom fastapi import status\n```\n\n\u003e ### ì‹ ê·œ ìƒì„±) backend/pytest.ini\n\n```bash\nâ¯ touch backend/pytest.ini\n```\n\n```yaml\n[pytest]\nfilterwarnings =\n    ignore::sqlalchemy.exc.SAWarning\n```\n\n$\\rightarrow$ **`sqlalchemy`** ì—ì„œ ë³´ë‚´ëŠ” ê²½ê³ ë¥¼ **`pytest`** ì—ì„œ ì¶œë ¥í•˜ì§€ ì•Šë„ë¡ ì„¤ì •\n\nìœ„ ìˆ˜ì •ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë“¯ì´, **`pytest`** ë°±ì—”ë“œë¡œ **`anyio`** ë¥¼ ì“°ê¸° ë•Œë¬¸ì—, **`pytest-asyncio`** ëŠ” ì´ì œ í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ ì œê±°í•œë‹¤.\n\n```bash\nâ¯ poetry remove --dev pytest-asyncio\nâ¯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\nâ¯ docker-compose build\n```\n\nê¹œë°•í•˜ê³  ë„˜ì–´ê°„ ê²½ìš°ê°€ ìˆì„í…ë°, í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë©´ ê¸ˆë°© ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.\n\n## `TDD` ë°©ë²•ë¡ ì— ë”°ë¥¸ ìœ ì € ìƒì„± `api` ë§Œë“¤ê¸°\n\n### ë¼ìš°í„° ì¡´ì¬ í™•ì¸\n\nì› ì˜ˆì œì˜ **jeffastor**ëŠ” íšŒì›ê°€ì… apiì— ìš”ì²­ì„ ë³´ë‚´ê³  ì—ëŸ¬ ì½”ë“œë¥¼ í™•ì¸í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë§Œë“¤ì—ˆì§€ë§Œ, ìµœê·¼ì— **RESTful** api ìƒì„±ê³¼ ê´€ë ¨í•´ì„œ [ì¢‹ì€ ê¸€](https://sanghaklee.tistory.com/57)ì„ í™•ì¸í–ˆê¸°ì—, **OPTIONS** apië¡œ ëŒ€ì‹ í•˜ê³ ì í•œë‹¤.\n\n```bash\nâ¯ touch backend/tests/test_users.py\n```\n\n```python\n# backend/tests/test_users.py\nimport pytest\nfrom fastapi import FastAPI, status\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.anyio\n\n\nclass TestUserRoutes:\n    api_name = \"users:get-allowed-methods\"\n\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -\u003e None:\n        res = await client.options(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_204_NO_CONTENT\n        assert not res.content\n        headers = res.headers\n        assert \"Allow\" in headers\n        allowed_methods_str = headers[\"Allow\"]\n        allowed_methods = {\n            method_str.strip().lower() for method_str in allowed_methods_str.split(\",\")\n        }\n        assert len(allowed_methods) \u003e 0\n        for method_str in (\"post\",):\n            assert method_str in allowed_methods\n```\n\ní…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ë³´ë©´ ë‹¹ì—°íˆ ì—ëŸ¬ê°€ ë‚˜ì˜¨ë‹¤.\n\n```bash\nroot@90b2a10bcb6d:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py F                                                                                 [100%]\n\n================================================= FAILURES ==================================================\n_____________________________ TestUserRoutes.test_routes_exist[asyncio+uvloop] ______________________________\ntests/test_users.py:10: in test_routes_exist\n    res = await client.options(app.url_path_for(\"users:get-allowed-methods\"))\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: in url_path_for\n    raise NoMatchFound()\nE   starlette.routing.NoMatchFound\n----------------------------------------- Captured stderr teardown ------------------------------------------\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\n========================================== short test summary info ==========================================\nFAILED tests/test_users.py::TestUserRoutes::test_routes_exist[asyncio+uvloop] - starlette.routing.NoMatchF...\n======================================= 1 failed, 39 passed in 4.52s ========================================\n```\n\nì´ì œ ì—ëŸ¬ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë¼ìš°í„°ë¥¼ ìƒì„±í•œë‹¤.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter, Response, status\n\nfrom ...services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.options(\"\", name=\"users:get-allowed-methods\")\nasync def get_allowed_user_methods() -\u003e Response:\n    from functools import reduce\n\n    method_sets = [getattr(route, \"methods\") for route in router.routes]\n    all_methods = reduce(lambda left, right: left | right, method_sets, set())\n    all_methods_str = \", \".join(all_methods)\n\n    return Response(\n        status_code=status.HTTP_204_NO_CONTENT, headers={\"Allow\": all_methods_str}\n    )\n\n\n@router.post(\"\")\nasync def post_temp():\n    ...\n```\n\nì„ì‹œë¡œ ê°€ì§œ **POST** apië¥¼ ì •ì˜í–ˆê¸°ì—, í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ë„ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.\n\n```bash\nroot@96deef95611e:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py .                                                                                 [100%]\n\n============================================ 40 passed in 4.03s =============================================\n```\n\n### íšŒì›ê°€ì…\n\nìš°ì„ , ê¸°ì¡´ì— ì‘ì„±í–ˆë˜ ìœ ì € ëª¨ë¸ì— ëŒ€í•´ ì´ë©”ì¼ë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆëŠ” ë©”ì†Œë“œë¥¼ í•˜ë‚˜ ìƒì„±í•œë‹¤. ê´€ë ¨í•´ì„œ ì¢…ì¢… ì“°ì´ê¸° ë•Œë¬¸.\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar, cast\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlmodel.sql.expression import Select\n\n(...)\n\n_T = TypeVar(\"_T\", bound=\"user_model\")\n\n(...)\n\nclass user(user_base, models.BaseUserDB):\n    def to_model(self) -\u003e \"user_model\":\n        return user_model.validate(self)\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: AsyncSession, email: str\n    ) -\u003e _T | None:\n        is_user_cur = await session.exec(\n            cast(Select[_T], select(cls).where(cls.email == email))\n        )\n        return is_user_cur.first()\n```\n\n\u003e ì•„ì§ **`sqlmodel`** ì˜ `async` ì§€ì›ì´ ë¶€ì¡±í•´ì„œ, `typing.cast`ë¥¼ ì´ìš©í•´ì„œ `Select` íƒ€ì…ìœ¼ë¡œ ê°•ì œí•´ì„œ ì‚¬ìš©í–ˆë‹¤.\n\n\u003e `user`ì™€ `user_model`ì„ í•˜ë‚˜ë¡œ í•©ì¹  ìˆ˜ ìˆì„ ê²ƒ ê°™ì€ë°, ì´ê±´ ë‚˜ì¤‘ì— ì‹œê°„ë‚´ì„œ í™•ì¸í•´ë³¼ ìƒê°.\n\nì´ì œ **`fastapi-users`** ë¥¼ ì‚¬ìš©í•  ë•Œê°€ ì™”ë‹¤. ìš°ì„  í…ŒìŠ¤íŠ¸ ì½”ë“œë¶€í„° ì‘ì„±í•œë‹¤.\n\n```python\n# backend/tests/test_users.py\nfrom app.models import user\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\nclass TestUserRegistration:\n    api_name = \"users:register-new-user\"\n\n    async def test_users_can_register_successfully(\n        self, app: FastAPI, client: AsyncClient, engine: AsyncEngine\n    ) -\u003e None:\n        new_user = {\n            \"email\": \"shakira@shakira.io\",\n            \"name\": \"shakirashakira\",\n            \"password\": \"chantaje@1\",\n        }\n        # make sure user doesn't exist yet\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is None\n        # send post request to create user and ensure it is successful\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status.HTTP_201_CREATED\n        # ensure that the user now exists in the db\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is not None\n        assert is_user.email == new_user[\"email\"]\n        assert is_user.name == new_user[\"name\"]\n        # check that the user returned in the response is equal to the user in the database\n        created_user = user.user_model.validate(\n            res.json() | {\"hashed_password\": \"whatever\"}\n        )\n        exclude_attr_set = user.user_model.datetime_attrs | {\"id\", \"hashed_password\"}\n        assert created_user.dict(exclude=exclude_attr_set) == is_user.dict(\n            exclude=exclude_attr_set\n        )\n\n    @pytest.mark.parametrize(\n        \"attr, value, status_code\",\n        (\n            (\"email\", \"shakira@shakira.io\", 400),\n            (\"name\", \"sha\", 422),\n            (\"name\", \"shafasdfsdwerewfsdfxcvxcvxcv\", 422),\n            (\"email\", \"invalid_email@one@two.io\", 422),\n            (\"password\", \"short\", 422),\n            (\n                \"password\",\n                (\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                ),\n                422,\n            ),\n            (\"password\", \"pattern@\", 422),\n            (\"name\", \"shakira@#$%^\u003c\u003e\", 422),\n            (\"name\", \"ab\", 422),\n        ),\n    )\n    async def test_user_registration_fails_when_credentials_are_taken(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        attr: str,\n        value: str,\n        status_code: int,\n    ) -\u003e None:\n        new_user = {\n            \"email\": \"nottaken@email.io\",\n            \"name\": \"not_taken_username\",\n            \"password\": \"freepassword@1\",\n        }\n        new_user[attr] = value\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status_code\n```\n\nì´ì œ ìœ„ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í†µê³¼í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ì€ apië¥¼ ìƒì„±í•œë‹¤.\n\n```python\nimport re\n\nimport orjson\nfrom fastapi import Body, HTTPException, Request\nfrom fastapi_users.manager import InvalidPasswordException, UserAlreadyExists\nfrom pydantic import ValidationError\n\nfrom ...models import user\nfrom ...services.authentication import user_manager_type\n\n(...)\n\nre_deny_name = re.compile(r\"[^a-zA-Z0-9_-]\")\n\n(...)\n\n@router.post(\n    \"\",\n    name=\"users:register-new-user\",\n    response_model=user.user_read,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def register_new_user(\n    request: Request,\n    new_user: user.user_create = Body(..., embed=True),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n):\n    if re_deny_name.search(new_user.name):\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=(\n                \"The name can only contain the following characters: \"\n                f\"{re_deny_name.pattern.replace('^','')}\"\n            ),\n        )\n\n    try:\n        return await user_manager.create(new_user, safe=True, request=request)\n    except UserAlreadyExists as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=(\n                \"That email is already taken. \"\n                \"Login with that email or register with another one.\"\n            ),\n        )\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=orjson.loads(exc.json()),\n        )\n    except InvalidPasswordException as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=exc.reason,\n        )\n\n```\n\n\u003e ë”°ë¡œ ì ì§€ëŠ” ì•Šì•˜ì§€ë§Œ, **TDD** ë°©ë²•ë¡ ì„ ì¶©ì‹¤íˆ ì´í–‰í•˜ë©´ì„œ ë§Œë“¤ì–´ì§„ í…ŒìŠ¤íŠ¸ ì½”ë“œì™€ apië‹¤.\n\nìœ„ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•´ë³´ë©´, ëª¨ë‘ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\n### í† í°\n\n**`fastapi-users`** ë•ë¶„ì— í† í° ë“±ì— ëŒ€í•œ ë³„ë‹¤ë¥¸ ì‘ì—… ì—†ì´ ê¹”ë”í•˜ê²Œ ëë‚¬ì§€ë§Œ, ì› ì˜ˆì œì—ì„œëŠ” í† í°ê³¼ ê´€ë ¨ëœ ëª‡ê°€ì§€ ì‘ì—…ì´ ì§„í–‰ëœë‹¤. í•´ë‹¹ ê³¼ì • ì¤‘ í•´ë³´ë©´ ì¢‹ì„ ê²ƒ ê°™ì€ ë¶€ë¶„ë§Œ ë”°ë¼ì„œ ì§„í–‰í•œë‹¤.\n\n#### í† í° ê´€ë ¨ ì„¤ì • ìˆ˜ì • ë° ì¶”ê°€\n\nì´ˆê¸°ì— ëŒ€ì¶© ì‘ì„±í•´ë†¨ë˜ `SECRET_KEY` ë“±ì˜ ê°’ì„ ì§€ì •í•´ì¤€ë‹¤. ì´ ê°’ì„ ì§ì ‘ ì‘ì„±í•˜ê¸° ë³´ë‹¤ëŠ” ê·¸ëƒ¥ í„°ë¯¸ë„ ëª…ë ¹ì–´ë¡œ ìƒì„±ëœ ì„ì˜ì˜ ê°’ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.\n\n```bash\nâ¯ openssl rand -hex 32\n```\n\nì´ì œ ì´ ê°’ì„ `.env` íŒŒì¼ì— ì¶”ê°€í•˜ë©´ ëœë‹¤. ì´ ì™¸ì—ë„ ëª‡ëª‡ ê°’ì„ ì¶”ê°€ë¡œ ë” ì„¤ì •í•˜ëŠ”ë° ê° ê°’ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\n\n\u003e `ACCESS_TOKEN_EXPIRE_SECONDS`: í† í°ì˜ ë§Œë£Œì‹œê°„(ì´ˆ)\n\u003e `JWT_ALGORITHM`: í† í° ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜\n\u003e `JWT_AUDIENCE`: í† í° ë°œê¸‰/ìˆ˜ì‹  ëŒ€ìƒ\n\u003e `JWT_TOKEN_PREFIX`: í† í° íƒ€ì…?(ì–˜ëŠ” í™•ì‹¤í•˜ì§€ ì•ŠìŒ)\n\nì´ì œ `config.py`ê°€ ìœ„ ê°’ì„ ì˜ ì½ì„ ìˆ˜ ìˆê²Œ ìˆ˜ì •í•œë‹¤.\n\n```python\n# backend/app/core/config.py\n(...)\n\nACCESS_TOKEN_EXPIRE_MINUTES = config(\n    \"ACCESS_TOKEN_EXPIRE_MINUTES\", cast=int, default=60 * 60\n)\nJWT_ALGORITHM = config(\"JWT_ALGORITHM\", cast=str, default=\"HS256\")\nJWT_AUDIENCE = config(\"JWT_AUDIENCE\", cast=str, default=\"phresh:auth\")\nJWT_TOKEN_PREFIX = config(\"JWT_TOKEN_PREFIX\", cast=str, default=\"Bearer\")\n\n(...)\n```\n\nê·¸ë¦¬ê³  ì´ ê°’ì„ ì˜ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ ìˆ˜ì •í•œë‹¤.\n\n```python\n# backend/app/services/authentication.py\n(...)\n\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = config.JWT_TOKEN_PREFIX\n\n    @classmethod\n    def from_token(cls, token: str) -\u003e \"token_model\":\n        return cls(access_token=token)\n\n(...)\n\ndef create_strategy() -\u003e Strategy[user.user_create, user.user]:\n    return JWTStrategy(\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n(...)\n```\n\ní…ŒìŠ¤íŠ¸ ì½”ë“œì—ì„œ ì‚¬ìš©í•  `fixture`ë¥¼ ì •ì˜í•œë‹¤. ì¤‘ë³µ ì´ë©”ì¼ì„ í—ˆìš©í•˜ì§€ ì•Šê¸°ì— ì£¼ì˜í•´ì„œ ì‘ì„±í•œë‹¤.\n\n```python\n# backend/tests/conftest.py\nfrom app.models import user\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_user(engine: AsyncEngine) -\u003e user.user_model:\n    new_user = user.user_create.parse_obj(\n        dict(\n            email=\"lebron@james.io\",\n            name=\"lebronjames\",\n            password=\"heatcavslakers@1\",\n        )\n    )\n\n    async with AsyncSession(engine, autocommit=False) as session:\n        db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n        manager = UserManager(db)\n\n        try:\n            new_user_db = await manager.get_by_email(new_user.email)\n        except UserNotExists:\n            new_user_db = await manager.create(new_user, safe=True)\n\n    return new_user_db.to_model()\n```\n\nì´ì œ ì´ `fixture`ë¥¼ ì´ìš©í•´ì„œ í† í°ì„ ë°œê¸‰ë°›ê³ , ê²€ì¦í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤.\n\n\u003e 2022.05.06. ì•„ë˜ í…ŒìŠ¤íŠ¸ ì½”ë“œëŠ” ì‚¬ì‹¤ìƒ ë¬´ì˜ë¯¸í•˜ê¸°ì—, ì—†ì–´ë„ ì¢‹ë‹¤. **TDD**ì— ìµìˆ™í•˜ì§€ ì•Šì€ ê²ƒë„ ìˆê³ , ì› ì˜ˆì œì˜ ë‚´ìš©ê³¼ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ apië¥¼ ìƒì„±í•˜ë‹¤ë³´ë‹ˆ í—·ê°ˆë ¤ì„œ ì˜ëª» ì‘ì„±í•œ ê²ƒ ê°™ë‹¤. ë‹¤ìŒ ì±•í„°ì˜ ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í™•ì¸í•˜ì.\n\n```python\nclass TestAuthTokens:\n    api_name = \"users:create-token\"\n\n    async def test_can_create_access_token_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -\u003e None:\n        access_token = await strategy.write_token(user=test_user)\n        creds = decode_jwt(\n            access_token,\n            str(config.SECRET_KEY),\n            [config.JWT_AUDIENCE],\n            [config.JWT_ALGORITHM],\n        )\n\n        assert creds.get(\"user_id\") is not None\n        user_id = creds[\"user_id\"]\n        assert config.JWT_AUDIENCE in creds[\"aud\"]\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            user_model = await session.get(user.user_model, user_id)\n        assert user_model is not None\n\n        assert user_model.name == test_user.name\n\n    async def test_token_missing_user_is_invalid(\n        self, app: FastAPI, client: AsyncClient\n    ) -\u003e None:\n        res = await client.post(\n            url=app.url_path_for(self.api_name),\n            data={\"username\": \"unknown\", \"password\": \"testpassword@1\"},\n        )\n        assert res.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n```\n\nì› ì˜ˆì œëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì¡°ê¸ˆ ë” í’ë¶€í•˜ì§€ë§Œ, **`fastapi-users`** ë¥¼ ì‚¬ìš©ì¤‘ì´ê¸°ì—, ë¶ˆí•„ìš”í•œ ê³¼ì •ì´ë¼ ìƒê°ëë‹¤. ìœ„ í…ŒìŠ¤íŠ¸ ì½”ë“œì—ì„œ `strategy`ë¥¼ ì´ìš©í•˜ì—¬ ì§ì ‘ `access_token`ì„ ìƒì„±í•´ë³´ê¸°ë„ í•˜ê³  ë³µí˜¸í™”í•´ë³´ê¸°ë„ í•˜ë©°, `access_token`ë¡œ ë¶€í„° ìœ ì €ë¥¼ ë¶ˆëŸ¬ì˜¤ê¸°ë„ í•œë‹¤. ëìœ¼ë¡œ ì´ëŸ¬í•œ ê³¼ì •ì´ ì§„í–‰ë˜ëŠ” apië¥¼ í˜¸ì¶œí•´ë³´ê¸°ë„ í•œë‹¤.\n\ní…ŒìŠ¤íŠ¸ëŠ” ë¬¸ì œì—†ì´ ì˜ ì§„í–‰ëë‹¤.\n\në‹¤ìŒ ì±•í„°ì—ì„œëŠ” ì§€ê¸ˆê¹Œì§€ ë§Œë“  ìœ ì € apië¡œ ë¡œê·¸ì¸ ë“±ì„ ì‹œë„í•œë‹¤. ì°¸ê³ ë¡œ, í˜„ì¬ ì„ íƒí•œ ì „ëµìœ¼ë¡œëŠ”, ì„œë²„ê°€ ì´ë¯¸ ë°œê¸‰í•œ í† í°ì— ëŒ€í•´ ì²˜ë¦¬ê°€ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ, ë¡œê·¸ì•„ì›ƒ ê¸°ëŠ¥ì„ ìƒì„±í•  ìˆ˜ ì—†ë‹¤.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -7- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 2","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -7- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„± 2","date":"2022-05-05T06:13:07.421+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}},{"name":"fastapi íŠœí† ë¦¬ì–¼ -6- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„±","content":"\n**`fastapi`** ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ [ì˜ˆì œ](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)ê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤.\nì§€ë‚œë²ˆì²˜ëŸ¼ ì–´ì©Œë‹¤ ê·¸ë§Œë‘˜ ìˆ˜ë„ ìˆê¸´ í•˜ì§€ë§Œ...\n\n---\n\n## `cleanings`, `users` ëª¨ë¸ ìƒì„± ë° ìˆ˜ì •\n\nì‹œì‘ë¶€í„° ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì§„í–‰í•˜ê¸¸ë˜ ì–´ë–¤ê±´ê°€ í–ˆë”ë‹ˆ, ì´ì „ì— ì‘ì„±í–ˆë˜ `cleanings` í…Œì´ë¸”ì— ì‹œê°„ ì†ì„±(ìƒì„±, ìˆ˜ì •)ì„ sql ì„œë²„ì—ì„œ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•˜ë„ë¡ í•˜ëŠ” íŠ¸ë¦¬ê±°ë¥¼ ìƒì„±í•˜ëŠ” ê³¼ì •ì´ ìˆì—ˆë‹¤. sql ì„œë²„ì—ì„œ ì§ì ‘ ì²˜ë¦¬í•˜ëŠ”ê²Œ ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²•ì´ë¼ê³  í•œë‹¤. ì¼ë‹¨ ë¬´ì‹œ.\n\nì´ê²ƒê³¼ëŠ” ë³„ê°œë¡œ, ì´ì „ì— ë§ˆì´ê·¸ë ˆì´ì…˜ ê´€ë ¨ ì½”ë“œ ì‘ì„±ì‹œ ë¬¸ì œê°€ ìˆëŠ” í˜•íƒœë¡œ ì‘ì„±í•œ ê²ƒ ê°™ì•„ì„œ, ê´€ë ¨í•´ì„œ ì¡°ê¸ˆ ìˆ˜ì •í•œë‹¤.\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -\u003e None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\nì´ì œ ì› ì˜ˆì œì™€ ê°™ì´, ë‹¤ìš´ê·¸ë ˆì´ë“œ í›„, ì‹œê°„ ì†ì„±ë¶€í„° ì¶”ê°€í•œ ë‹¤ìŒ, ìœ ì € ê´€ë ¨ í…Œì´ë¸”ì„ ì„¤ì •í•˜ê³  ì—…ê·¸ë ˆì´ë“œë¥¼ ì‹¤ì‹œí•œë‹¤. ì› ì˜ˆì œì™€ ìˆœì„œë¥¼ ë§ì¶°ê°€ê¸° ìœ„í•´ ì•½ê°„ ê¼¬ì¸ ëŠë‚Œì´ ìˆëŠ”ë°, ì§€ê¸ˆ ì‘ì„±í•˜ëŠ” ìœ ì € í…Œì´ë¸”ì€ **`fastapi-users`** ì—ì„œ ì‘ì„±í•˜ëŠ” ëª¨ë¸ í˜•íƒœë¥¼ ë”°ë¼ê°„ë‹¤.\n\n```bash\nroot@c62cf3d05043:/backend# alembic downgrade base\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running downgrade f721febf752b -\u003e , create account table\n```\n\n### ì‹œê°„ ì†ì„± ê´€ë ¨ ì½”ì–´ ëª¨ë¸ ì¶”ê°€\n\n```python\n# backend/app/models/core.py\nfrom datetime import datetime\n\n(...)\n\n_D = TypeVar(\"_D\", bound=\"datetime_model\")\n\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -\u003e _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def attrs(cls) -\u003e set[str]:\n        return set(cls.__fields__.keys())\n```\n\n### ì‹œê°„ ì†ì„± ì¶”ê°€ë¡œ ì¸í•œ ê¸°ì¡´ ëª¨ë¸ ë³€ê²½ì  ëŒ€ì‘ ìˆ˜ì •\n\n\u003e ì•„ë˜ ë‚´ìš©ì€ ë‹¨ìˆœíˆ ì‹œê°„ ì†ì„± ì¶”ê°€ë¡œ ì¸í•´ ì½”ë“œê°€ ë„ˆë¬´ ë‚˜ì—´ë¼ìˆì–´ì„œ ì ‘ì–´ë†“ê³  ì‹¶ì§€ë§Œ velogê°€ í•´ë‹¹ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.. velogì—ì„œ ìë™ ìƒì„±ëœ ëª©ì°¨ë¥¼ ì„ íƒí•´ì„œ ë‹¤ìŒ í•­ëª©ìœ¼ë¡œ ë„˜ì–´ê°ˆ ìˆ˜ ìˆë‹¤.\n\n```python\n# backend/app/models/cleaning.py\n(...)\n\nfrom .core import base_model, datetime_model, id_model\n\n(...)\n\nclass cleanings(id_model, datetime_model, cleaning_base, table=True):\n    name: str = Field(index=True)\n    cleaning_type: cleaning_type_enum = Field(\n        cleaning_type_enum.spot_clean,\n        sa_column_kwargs={\"server_default\": cleaning_type_enum.spot_clean},\n    )\n    price: price_decimal_type\n\n(...)\n```\n\n```python\n# backend/tests/test_cleaning.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\nimport orjson\nimport pytest\nfrom app.models.cleaning import cleaning_create, cleanings\nfrom app.models.core import datetime_model\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n# decorate all tests with @pytest.mark.asyncio\npytestmark = pytest.mark.asyncio\n\n\n@pytest.fixture\ndef new_cleaning():\n    return cleaning_create.parse_obj(\n        dict(\n            name=\"test cleaning\",\n            description=\"test description\",\n            price=0.00,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n\n\nclass TestCleaningsRoutes:\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCreateCleaning:\n    async def test_valid_input_creates_cleaning(\n        self, app: FastAPI, client: AsyncClient, new_cleaning: cleaning_create\n    ) -\u003e None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": orjson.loads(new_cleaning.json())},\n        )\n        assert res.status_code == HTTP_201_CREATED\n\n        created_cleaning = cleaning_create(**res.json())\n        assert created_cleaning == new_cleaning\n\n    @pytest.mark.parametrize(\n        \"invalid_payload, status_code\",\n        (\n            (None, 422),\n            ({}, 422),\n            ({\"name\": \"test_name\"}, 422),\n            ({\"price\": 10.00}, 422),\n            ({\"name\": \"test_name\", \"description\": \"test\"}, 422),\n        ),\n    )\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient, invalid_payload: dict, status_code: int\n    ) -\u003e None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": invalid_payload},\n        )\n        assert res.status_code == status_code\n\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -\u003e cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning.dict(exclude=datetime_model.attrs) == test_cleaning.dict(\n            exclude=datetime_model.attrs\n        )\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [\n            cleanings.validate(l).dict(exclude=datetime_model.attrs) for l in json\n        ]\n        assert test_cleaning.dict(exclude=datetime_model.attrs) in all_cleanings\n\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(test_cleaning.id),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -\u003e None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -\u003e None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate ê´€ë ¨ ë¬¸ì œ í•´ê²° ì „ê¹Œì§€ëŠ” ì´ë ‡ê²Œ..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -\u003e None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n    from app.models.core import datetime_model\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\nì´ë ‡ê²Œ ìˆ˜ì •í•˜ë©´ ì¶”ê°€, ìˆ˜ì • ì‹œê°„ ì†ì„±ì„ ë¬¸ì œì—†ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤..\ní° ë¬¸ì œê°€ ì—†ë‹¤ë©´ ê·¸ëƒ¥ íŠ¸ë¦¬ê±°ë¥¼ ì´ìš©í•˜ì.\n\n### `users` ëª¨ë¸ ìƒì„±\n\n```bash\nâ¯ poetry add 'fastapi-users[sqlalchemy2]'\nâ¯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\nâ¯ touch backend/app/models/user.py\nâ¯ docker-compose up --build\n```\n\nì› ì˜ˆì œì—ì„œ **`JWT`** ë¥¼ ì‚¬ìš©í•˜ê¸°ì— ë”°ë¼ê°„ë‹¤.\n\n```python\n# backend/app/models/user.py\nfrom uuid import uuid4\n\nfrom fastapi_users import models\nfrom pydantic import UUID4, EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field\n\nfrom .core import base_model, datetime_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\nclass user_base(models.BaseUser, datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(models.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(models.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_read(user_base):\n    ...\n\n\nclass user(user_base, models.BaseUserDB):\n    ...\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\nìœ„ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì •ì˜í•œ ëª¨ë¸ì€, **`pydantic`** ì˜ `BaseModel`ì„ ìƒì†ë°›ëŠ”, **`fastapi-users`** ì—ì„œ ì •ì˜ëœ ëª¨ë¸ì„ ìƒì†ë°›ì•„ì„œ ì •ì˜í•œë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ê°€ì§€ê³  ìˆëŠ” ì†ì„±ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\n\n\u003e `id` : `UUID`ë¡œ ì„ì˜ ìƒì„±\n\u003e `email`: `xxx@yyy.zz`ì˜ í˜•íƒœë¡œ êµ¬ì„±ëœ ë¬¸ìì—´\n\u003e `is_active`: í•´ë‹¹ ìœ ì € ë ˆì½”ë“œê°€ í™œì„±í™”ëœ ìƒíƒœì¸ì§€ í™•ì¸\n\u003e `is_superuser`: í•´ë‹¹ ìœ ì €ê°€ ê´€ë¦¬ìì¸ì§€ í™•ì¸\n\u003e `is_verified`: ì„ íƒì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ, í•´ë‹¹ ìœ ì €ì— ëŒ€í•œ ì¶”ê°€ì ì¸ ê²€ì¦ í†µê³¼ ì—¬ë¶€ë¥¼ í™•ì¸. í”íˆ ì´ë©”ì¼ë¡œ ê²€ì¦ì„ ì§„í–‰í•¨.\n\u003e `password`: í•´ë‹¹ ìœ ì €ê°€ ë¡œê·¸ì¸ì‹œ ì‚¬ìš©í•˜ëŠ” ë¹„ë°€ë²ˆí˜¸ë¡œ, ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ì—ëŠ” `hashed_password` ì†ì„±ìœ¼ë¡œ ì•”í˜¸í™” í›„ ì €ì¥ëœë‹¤.\n\nì¶”ê°€ì ìœ¼ë¡œ í•„ìš”í•œ ì†ì„±ì´ ìˆë‹¤ë˜ê°€, ì œì•½ì‚¬í•­ì´ ìˆë‹¤ë©´ ìœ„ ìŠ¤í¬ë¦½íŠ¸ì™€ ê°™ì´ ëª¨ë¸ì— ìƒˆë¡œ ì •ì˜ë¥¼ í•´ë„ ì¢‹ê³ , ì´í›„ ì •ì˜í•  `UserManager` í´ë˜ìŠ¤ì˜ `on_after_register` ë“±ì˜ ë©”ì†Œë“œì— ì œì•½ì‚¬í•­ì„ ì ìš©í•´ë„ ëœë‹¤.\n\nê·¸ë¦¬ê³  ì¶”ê°€ëœ ëª¨ë¸ì„ ë§ˆì´ê·¸ë ˆì´ì…˜ ì„¤ì •ì— ì¶”ê°€í•œë‹¤.\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n\"\"\"create account table\n\nRevision ID: f721febf752b\nRevises:\nCreate Date: 2022-04-27 17:21:25.945460\n\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nimport sqlalchemy as sa\nfrom alembic import op\n\nsys.path.append(Path(__file__).resolve().parents[4].as_posix())\nfrom app.models.cleaning import cleanings\nfrom app.models.core import datetime_model\nfrom app.models.user import user_model\n\n# revision identifiers, used by Alembic.\nrevision = \"f721febf752b\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ncleanings_table = cleanings.get_table()\nusers_table = user_model.get_table()\n\n\ndef create_cleanings_table() -\u003e None:\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        cleanings_table.name,\n        *[col for col in cleanings_table.columns if col.name in col_names]\n    )\n\n\ndef create_user_table() -\u003e None:\n    col_names = {\n        \"id\",\n        \"name\",\n        \"hashed_password\",\n        \"email\",\n        \"is_active\",\n        \"is_superuser\",\n        \"is_verified\",\n    }.union(datetime_model.attrs)\n\n    op.create_table(\n        users_table.name, *[col for col in users_table.columns if col.name in col_names]\n    )\n\n\ndef upgrade():\n    create_cleanings_table()\n    create_user_table()\n\n\ndef downgrade():\n    op.drop_table(cleanings_table.name)\n    op.drop_table(users_table.name)\n```\n\nì´ì œ ë“œë””ì–´ ë§ˆì´ê·¸ë ˆì´ì…˜ì„ í•  ì¤€ë¹„ê°€ ëë‚¬ë‹¤.\n\n```bash\nroot@77f86a971288:/backend# alembic upgrade head\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -\u003e f721febf752b, create account table\n```\n\n## `FastAPI-Users`\n\nì› ì˜ˆì œì—ì„œëŠ” ì´ì œ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤. í•˜ì§€ë§Œ `fastapi-users`ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ, ì‚¬ì „ ì‘ì—…ì´ ëª‡ê°€ì§€ í•„ìš”í•œë°, ì§€ê¸ˆ ì§„í–‰í•˜ëŠ” ì‘ì—…ì´ ë‹¤ìŒ ì±•í„°ë‚˜ ê·¸ ë‹¤ìŒ ì±•í„°ì— ë‚˜ì˜¤ëŠ” ë‚´ìš©ê³¼ ë¹„ìŠ·í•  ìˆ˜ ìˆë‹¤..\n\n### ê°„ë‹¨í•œ ì„¤ëª…\n\n**`fastapi-users`** ì˜ ì„¤ëª…ì— ë”°ë¥´ë©´, **`fastapi-users`** ëŠ” `Transport`ì™€ `Strategy` ì´ ë‘ê°€ì§€ë¥¼ ì¡°í•©í•´ì„œ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì´ë‹¤. ì§€ê¸ˆ ì´ ì˜ˆì œëŠ” **`Bearer`** ì™€ **`JWT`** ë¥¼ ì¡°í•©í•´ì„œ ì“°ëŠ” ë°©ì‹ì´ë¼ê³  ìƒê°í•  ìˆ˜ ìˆë‹¤.\n\n\u003e - **`Bearer`** : `header`ì— í† í°ì„ ì €ì¥\n\u003e - **`JWT`** : `JSON`í˜•íƒœì˜ í† í°ì„ ì•”í˜¸í™” í•˜ì—¬ ì €ì¥(í† í° ë°œí–‰ ì´í›„ ì„œë²„ì—ì„œ ë¬´íš¨í™” ë¶ˆê°€ëŠ¥). ìì„¸í•œ ì„¤ëª…ì€ [ì—¬ê¸°](https://jwt.io/introduction)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\n### ì¸ì¦ ë°±ì—”ë“œ ì„¤ì •\n\nì¸ì¦ê³¼ ê´€ë ¨í•œ ëª¨ë“ˆì„ ì €ì¥í•  ê²½ë¡œë¥¼ ìƒì„±í•˜ê³  ë°±ì—”ë“œë¶€í„° ì•ì—ì„œ ê°„ëµí•˜ê²Œ ì„¤ëª…í•œ ì¸ì¦ ë°±ì—”ë“œë¶€í„° ìƒì„±í•œë‹¤.\n\n```bash\nâ¯ mkdir backend/app/services\nâ¯ touch backend/app/services/__init__.py backend/app/services/authentication.py\n```\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ..core.config import SECRET_KEY\nfrom ..db.session import get_session\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n\n\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user, session, user_model)  # type: ignore\n\n\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n\n\ndef create_strategy() -\u003e Strategy:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n\n\ndef create_backend() -\u003e list[AuthenticationBackend]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n\n\nclass UserManager(BaseUserManager[user_create, user]):\n    user_db_model = user\n    reset_password_token_secret = str(SECRET_KEY)\n    verification_token_secret = str(SECRET_KEY)\n\n    async def on_after_register(self, user: user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(user_db=Depends(get_user_db)):\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(*backends: AuthenticationBackend) -\u003e FastAPIUsers:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user_base,\n        user_create_model=user_create,\n        user_update_model=user_update,\n        user_db_model=user,\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n\n```\n\në­”ê°€ ë§ì´ ì ì—ˆì§€ë§Œ ì‹¤ì œë¡œ ì§ì ‘ ì‘ì„±í–ˆë‹¤ê³  í• ë§Œí•œê±´ ë°ì´í„°í´ë˜ìŠ¤ **`fastapi_user`** ì •ë„ ë°–ì— ì—†ë‹¤. ì „ë¶€ **`fastapi-users`** ë ˆí¼ëŸ°ìŠ¤ì— ìˆëŠ” ë‚´ìš©ì´ë‹¤.\n\n`UserManager` ì™€ `AuthenticationBackend` ì¸ìŠ¤í„´ìŠ¤ëŠ” ì´í›„ ê³„ì •ê³¼ ê´€ë ¨ëœ ì‘ì—…ì„ í• ë•Œ ìì£¼ ì‚¬ìš©ëœë‹¤.\n\n### í† í° `api` ìƒì„±\n\nì´ì œ í† í°ì„ ìƒì„±í•˜ëŠ” apië¥¼ ìƒì„±í•œë‹¤. ì´ apiì˜ ì—”ë“œí¬ì¸íŠ¸ëŠ” `Transport`ë¥¼ ìƒì„±í•  ë•Œ ì‚¬ìš©í•œ `tokenUrl`ì˜ ê°’ê³¼ ì¼ì¹˜í•´ì•¼í•œë‹¤.\n\n```python\n# backend/app/api/routes/token.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi_users import models\nfrom fastapi_users.authentication import Strategy\nfrom fastapi_users.manager import BaseUserManager\nfrom fastapi_users.router import ErrorCode\nfrom starlette.status import HTTP_400_BAD_REQUEST\n\nfrom .authentication import fastapi_user as fastapi_user_class\nfrom .authentication import get_user_manager\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -\u003e dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n### ì¸ì¦ ë°±ì—”ë“œ í™•ì¸ìš© ì„ì‹œ `api` ìƒì„±\n\nì´ì–´ì„œ ì¸ì¦ ë°±ì—”ë“œ ì„¤ì •ì´ ì˜ ëëŠ”ì§€ í™•ì¸í•´ë³¼ ì„ì‹œ ë¼ìš°í„°ë¥¼ ìƒì„±í•œë‹¤. ì‹¤ì œë¡œ ì‚¬ìš©í•  ìƒê°ì€ ì•„ë‹ˆê³ , ë§ ê·¸ëŒ€ë¡œ ì„ì‹œ í™•ì¸ìš©ì´ë‹¤.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter\n\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\nrouter.include_router(\n    fastapi_user.users.get_auth_router(fastapi_user.backends[0]), prefix=\"/auth\"\n)\nrouter.include_router(fastapi_user.users.get_register_router(), prefix=\"/auth\")\nrouter.include_router(fastapi_user.users.get_verify_router(), prefix=\"/auth\")\n```\n\n```python\n# backend/api/routes/__init__.py\nfrom fastapi import APIRouter\n\nfrom .cleanings import router as cleanings_router\nfrom .token import router as token_router\nfrom .users import router as users_router\n\nrouter = APIRouter()\n\nrouter.include_router(cleanings_router, prefix=\"/cleanings\", tags=[\"cleanings\"])\nrouter.include_router(users_router, prefix=\"/users\", tags=[\"users\"])\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\nì´ì œ [http://localhost:8000/docs](http://localhost:8000/docs)ì—ì„œ í™•ì¸í•´ë³´ë©´ **`fastapi-users`** ì—ì„œ ì„¤ì •í•œ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ìƒì„±í•´ë†“ì€ ìœ ì € ê´€ë ¨ apië¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ë˜í•œ, ë¡œê·¸ì¸ì‹œ ìƒì„±ë˜ëŠ” í† í°ì„ í—¤ë”ì— ì¶”ê°€í•˜ë©´ **`swagger`** ì—ì„œ ë¡œê·¸ì¸ì„ ì‹œë„í•´ë³¼ ìˆ˜ ìˆë‹¤.\n\në‹¤ìŒì€ ì´ë²ˆì— ì‘ì„±í•œ ë‚´ìš©ì„ ì¢€ ë” ë‹¤ë“¬ê³ , ì´ì „ê¹Œì§€ í–ˆë˜ ë°©ì‹ìœ¼ë¡œ **TDD** ë°©ë²•ë¡ ì— ë”°ë¼ apië¥¼ ìƒì„±í•  ìƒê°ì´ë‹¤.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi íŠœí† ë¦¬ì–¼ -6- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„±","data":{"title":"fastapi íŠœí† ë¦¬ì–¼ -6- FastAPI Usersë¥¼ ì‚¬ìš©í•œ ìœ ì € api ìƒì„±","date":"2022-05-03T01:35:06.494+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi íŠœí† ë¦¬ì–¼","summary":"fastapi ì‚¬ìš©ë²•ì„ ë‹¤ì‹œ ê³µë¶€í• ê²¸, ì°¸ê³ í• ë§Œí•œ ì¢‹ì€ ì˜ˆì œê°€ ìˆì–´ì„œ ì´ ì‹œë¦¬ì¦ˆë¥¼ ì•½ê°„ì˜ ë³€ê²½ì„ ì£¼ê³  ë”°ë¼ê°€ë³´ë ¤ í•œë‹¤."}}]},"__N_SSG":true},"page":"/posts/@tag/[...tag]","query":{"tag":["fastapi","1"]},"buildId":"MQ_lMVQgBI0RkmUA6wvVT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>