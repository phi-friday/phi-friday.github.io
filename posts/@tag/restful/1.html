<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="author" content="phi.friday@gmail.com, phi"/><meta name="robots" content="index,follow,noarchive"/><meta name="google-site-verification" content="lW107Dj5ageygd67UUzTm-kGls5d-THy9jJQZqLoauw"/><title>phi.log</title><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e61452b80f7f8356.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e61452b80f7f8356.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c0b66b64eb886a29.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0b66b64eb886a29.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-5dc3bdee87ff18dd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f6271bdec05edb1f.js" defer=""></script><script src="/_next/static/chunks/996-f3cf67c2e3ac5e06.js" defer=""></script><script src="/_next/static/chunks/756-1349105dbea71525.js" defer=""></script><script src="/_next/static/chunks/224-ddba219ecdd5c904.js" defer=""></script><script src="/_next/static/chunks/pages/posts/@tag/%5B...tag%5D-5364b6481a3135f4.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_buildManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_ssgManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style>
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: #29D;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow: 0 0 10px #29D, 0 0 5px #29D;
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: #29D;
        border-left-color: #29D;
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style><div class="container" style="max-width:900px;min-width:400px"><div class="container default_app"><header><div class="container"><nav class="navbar-light fixed-top navbar navbar-expand-sm bg-light" role="navigation"><div class="container" style="max-width:900px"><div class="container-fluid"><ul class="navbar-nav w-100"><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-home"></i> Home</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@tag"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-hashtag"></i> Post</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@page"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-blog"></i> Page</div></a></li><div class="container d-flex justify-content-end align-self-center"><div class="row"><div class="col"><form class="input-group w-auto" method="get" action="https://www.google.com/search" target="_blank" style="min-width:230px"><input type="hidden" name="sitesearch" value="phi-friday.github.io"/><input type="search" class="form-control" placeholder="Search in Google" aria-label="Search" name="q" maxLength="255"/><button class="ripple ripple-surface btn btn-outline-primary" role="button"><i class="fa fa-search"></i></button></form></div></div></div></ul></div></div></nav></div></header><main><div class="container"><div class="row"><div><span><span class="badge bg-light mx-1 text-dark">@all<!-- --> <span class="badge bg-danger">25</span></span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> <span class="badge bg-danger">21</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> <span class="badge bg-danger">14</span></span></span><span><span class="badge bg-light mx-1 text-dark">#sqlmodel<!-- --> <span class="badge bg-danger">8</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#crud<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#returns<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#함수형 프로그래밍<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#windows<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#wsl<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#tdd<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#anyio<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#async<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vim<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#js<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#ts<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#nextjs<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#velog<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#github<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-primary mx-1">#restful<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#pytest<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#alembic<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#postgres<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#black<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#isort<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vscode<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#asyncio<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#trio<!-- --> <span class="badge bg-danger">1</span></span></span></div></div><div class="row"><div class="container"><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#crud<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> </span></span><span><span class="badge bg-primary mx-1">#restful<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#tdd<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-05-02T20:47:43.741+09:00">작성일: 2022년 5월 2일</time></h6></p></p><p class="card-text">fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.</p></div></div></div></div><div class="row"><ul class="pagination justify-content-center"><li class="page-item disabled"><a class="page-link" href="/posts/@tag/restful/1"><i class="fa fa-angle-double-left"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/restful/0"><i class="fa fa-angle-left"></i></a></li><li class="page-item active"><a class="page-link">1</a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/restful/6"><i class="fa fa-angle-right"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/restful/1"><i class="fa fa-angle-double-right"></i></a></li></ul></div></div></main><footer class="text-center text-muted"></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"restful","page":1,"max_page":1,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n아래 문제로 인해 해당 챕터를 진행하면서 이전 챕터의 글을 포함해서 수정하다 보니 제대로 수정이 된건지 아닌지 확인하기가 어렵다..\n어쩌면 [이곳](https://github.com/phi-friday/jeffastor_tutor)에서 코드를 확인하는게 도움이 될 수 있다.\n\n특히 이 챕터의 테스트 코드에 적용된 `Decimal`이나 `f-string`도 원래는 **TDD** 과정 중에서 적용한 것이지만, 이미 글 쓰는 흐름이 다 꼬여서 생략했다.\n\n---\n\n## `SQLModel`의 **validataion** 관련 해결\n\n[링크](https://velog.io/@phi0friday/sqlmodel-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-validation)와 같은 이유로 인해, **`sqlmodel`** 로 생성한 모델에 대한 전반적인 수정이 필요하므로, 아래와 같이 수정을 진행했다.\n\n```python\n# backend/app/models/core.py\nfrom typing import Any, TypeVar, cast\n\nfrom sqlmodel import Field, SQLModel, Table\n\n_T = TypeVar(\"_T\", bound=SQLModel)\n\n\nclass fix_return_type_model(SQLModel):\n    \"\"\"\n    sqlmodel에서 parse_obj 리턴값 정상적으로 수정하기 전까지 사용\n    +\n    validate 또한 같은 문제 있음\n    \"\"\"\n\n    @classmethod\n    def parse_obj(cls: type[_T], obj: Any, update: dict[str, Any] | None = None) -\u003e _T:\n        return cast(_T, super().parse_obj(obj, update))\n\n    @classmethod\n    def validate(cls: type[_T], value: Any) -\u003e _T:\n        return cast(_T, super().validate(value))\n\n\nclass base_model(fix_return_type_model):\n    @classmethod\n    def get_table(cls) -\u003e Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n\n\nclass id_model(fix_return_type_model):\n    id: int | None = Field(None, primary_key=True)\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\nasync def create_new_cleaning(\n    new_cleaning: cleaning_create = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    # data = cleanings.from_orm(new_cleaning) 으로 해도 가능\n    # exclude_none=True, exclude_unset=True 옵션을 위해 parse_obj 사용\n    # sqlmodel table=True 관련 validation 문제로 인해 validate사용\n    data = cleanings.validate(\n        new_cleaning.dict(\n            exclude_none=True,\n            exclude_unset=True,\n        )\n    )\n    session.add(data)\n    await session.flush()\n    await session.commit()\n    await session.refresh(data)\n\n    return data\n```\n\n```python\n# backend/tests.py\n(...)\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -\u003e cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning == test_cleaning\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [cleanings.validate(l) for l in json]\n        assert test_cleaning in all_cleanings\n```\n\n---\n\n## `RESTful` `CRUD` `api` 생성\n\n**RESTful** 표준에 따라, 다음과 같이 엔드포인트를 생성하고자 한다.\n\n| 엔드포인트     | 메소드 | 설명                               |\n| :------------- | :----- | :--------------------------------- |\n| /cleaning      | POST   | 새로운 cleaning 레코드 생성        |\n| /cleaning/{id} | GET    | id에 해당하는 cleaning 레코드 호출 |\n| /cleaning      | GET    | 전체 cleaning 레코드 호출          |\n| /cleaning/{id} | PATCH  | id에 해당하는 cleaning 레코드 수정 |\n| /cleaning/{id} | PUT    | id에 해당하는 cleaning 레코드 교체 |\n| /cleaning/{id} | DELET  | id에 해당하는 cleaning 레코드 제거 |\n\n이전 챕터에서, 새로운 레코드를 생성하는 것과, 기존의 레코드를 `id`를 이용하여 호출하는, 두개의 엔드포인트를 생성했다. 다른 4가지 또한, **TDD** 방법론에 맞게 작성한다.\n\n\u003e 원 예제에서 **jeffastor**는 **PATCH** api를 작성하지 않고 **PUT** api만 작성했다. 그런데 작동 방식을 보면 **jeffastor**가 작성한 **PUT** api는 **PATCH** api처럼 작동한다. 이와 관련해 약간의 수정이 함께 진행된다.\n\n### `GET` `api`\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]\n        assert test_cleaning in all_cleanings\n        assert test_cleaning in all_cleanings\n```\n\n이제 **`pytest`** 를 **`docker`** 컨테이너 내부에서 실행하면, 다음과 같은 에러를 확인할 수 있다.\n\n```bash\n(...)\n\n================================================= FAILURES ==================================================\n_______________________ TestGetCleaning.test_get_all_cleanings_returns_valid_response _______________________\n\nself = \u003ctests.test_cleanings.TestGetCleaning object at 0x7feb2db9b370\u003e\napp = \u003cfastapi.applications.FastAPI object at 0x7feb2b01fd90\u003e\nclient = \u003chttpx.AsyncClient object at 0x7feb2b01e6e0\u003e\ntest_cleaning = cleanings(name='fake cleaning name', price=Decimal('9.99'), id=3, description='fake cleaning description', cleaning_type='spot_clean')\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n\u003e       res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n\ntests/test_cleanings.py:125:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = \u003cfastapi.routing.APIRouter object at 0x7feb2b01d180\u003e, name = 'cleanings:get-all-cleanings'\npath_params = {}, route = \u003cfastapi.routing.APIRoute object at 0x7feb2b045480\u003e\n\n    def url_path_for(self, name: str, **path_params: str) -\u003e URLPath:\n        for route in self.routes:\n            try:\n                return route.url_path_for(name, **path_params)\n            except NoMatchFound:\n                pass\n\u003e       raise NoMatchFound()\nE       starlette.routing.NoMatchFound\n\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: NoMatchFound\n\n(...)\n```\n\n\u003e 현재 설정으로는, `test_cleaning`을 사용할 때 마다 새로운 레코드를 생성하고 있다. 만약 `unique` 설정이 있다면 에러를 발생시킬 것이다. 이 문제는 이후 다룰 것이므로, 지금은 신경쓰지 않아도 된다고 **jeffastor**는 밝힌다.\n\n이제 테스트를 통과할 수 있도록, 라우터를 수정합니다. 정말 연습해보기 위해, 이후 내용은 제대로 읽지 않고 직접 코드를 작성해봤습니다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom typing import cast\nfrom sqlmodel import select\n\n(...)\n\n@router.get(\n    \"\", response_model=list[cleaning_public], name=\"cleanings:get-all-cleanings\"\n)\nasync def get_all_cleanings(\n    session: AsyncSession = Depends(get_session),\n) -\u003e list[cleanings]:\n    # 아직 sqlmodel의 async session은 type hint와 관련해서 제대로 지원하지 않습니다.\n    # 제대로 작성된게 맞는지 확인해보고 싶다면,\n    # session.sync_session에서 type hint 관련해서만 확인해보면 됩니다.\n    #\n    # sync_session = session.sync_session\n    # table = sync_session.exec(select(cleanings))\n    # rows = table.all()\n    table = await session.exec(select(cleanings))  # type: ignore\n    rows = cast(list[cleanings], table.all())\n    return rows\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\n\n(...)\n```\n\n테스트 결과 통과했습니다.\n\n\u003e 원 작성자 **jeffator**의 경우, **TDD**에 대해 익숙해지지 위해 처음에는 `None`을 반환하고, 그 다음에는 빈 리스트 `[]`를 반환하고, 그 다음에는 가짜 레코드 `[{ \"id\": 1, \"name\": \"fake cleaning\", \"price\": 0}]`를 반환하고, 끝으로 세션에 연결해서 레코드를 반환합니다.\n\n### `PUT` `api`...? `PATCH` `api`\n\n다음과 같이 테스트 코드를 추가합니다.\n\n```python\n# backend/tests/test_cleanings.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.put(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n첫번째는 **PUT** api가 의도한대로 작동하는지 확인하고, 두번째는 의도한대로 에러를 반환하는지 확인하는 메소드입니다.\n이제 위 테스트 코드를 통과할 수 있도록 **PUT** 메소드를 작성합니다.\n\n\u003e 다만 위 테스트 코드에서 이해가 되지 않는 부분이 있는데,\n\n```python\n# make sure that no other attributes' values have changed\nfor attr, value in updated_cleaning.dict().items():\n    if attr not in attrs_to_change:\n        assert getattr(test_cleaning, attr) == value\n```\n\n\u003e 이다. 이건 **PATCH** 아닌가? 일단 따라가본다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom pydantic import ValidationError\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    try:\n        cleanings.from_orm(update_cleaning)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n`update_cleaning`이 정상적인 `cleanings` 레코드를 생성할 수 있는지 확인하고, `id`에 해당하는 `cleanings` 레코드를 호출 한 다음, 해당 레코드의 값을 수정하고 커밋했다.\n\n테스트 실행결과 이상하다고 생각했던 부분이 맞았다.\n**`pytest`** 에 익숙하지 않아 처음에 알아보지 못한 문제인데,\n\n```python\nattrs_to_change = ['cleaning_type']\nvalues = ['full_clean']\n```\n\n다음과 같이 변수가 정의된다..\n따라서, 위 예제를 모두 **PUT**에서 **PATCH**로 변경 후 다시 진행한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.parse_obj(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n기존에 작성한 **PUT** api는 제거하지 않고 놔둔다. 마지막에 다시 사용할 것이다.\n\n테스트 결과 모두 정상적으로 통과했다.\n\n### `DELETE` `api`\n\n이어서 **DELETE** 테스트 코드와 api를 생성한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -\u003e None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -\u003e None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.delete(\"/{id}/\", response_model=int, name=\"cleanings:delete-cleaning-by-id\")\nasync def delete_cleaning_by_id(\n    id: int = Path(..., ge=1, title=\"The ID of the cleaning to delete.\"),\n    session: AsyncSession = Depends(get_session),\n) -\u003e int:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    await session.delete(cleaning)\n    await session.flush()\n    await session.commit()\n\n    return id\n```\n\n테스트도 정상적으로 통과한다.\n\n```bash\ntests/test_cleanings.py::TestDeleteCleaning::test_can_delete_cleaning_successfully PASSED             [ 86%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[500-404] PASSED [ 90%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[0-422] PASSED [ 93%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[-1-422] PASSED [ 96%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[None-422] PASSED [100%]\n```\n\n\u003e **DELETE**와 같은 api는 `status_code=204`와 함께 `contents`가 없는 `response`를 반환하는게 맞다고 한다. 현재는 적용하지 않는다.\n\n### `PUT` api\n\n원 예제는 여기서 끝이지만, 추가로 **PUT** api에 대해 직접 작성해본다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n나름 여러 과정을 거쳤는데, **`sqlmodel`** 관련 문제를 알아보다 보니 너무 꼬였다. 과정은 생략..\n\n다음은 마이그레이션 진행 후 유저 관련 설정을 추가하는 것 같다. 유저 관련해서는 **`fastapi-users`** 라는 좋은 라이브러리가 있으니, 원 예제와 같은 흐름이지만 **`fastapi-user`** 를 쓰는 쪽으로 진행할 예정.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","data":{"title":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","date":"2022-05-02T20:47:43.741+09:00","tags":["crud","fastapi","restful","tdd","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}}]},"__N_SSG":true},"page":"/posts/@tag/[...tag]","query":{"tag":["restful","1"]},"buildId":"MQ_lMVQgBI0RkmUA6wvVT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>