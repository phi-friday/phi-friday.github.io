<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="author" content="phi.friday@gmail.com, phi"/><meta name="robots" content="index,follow,noarchive"/><meta name="google-site-verification" content="lW107Dj5ageygd67UUzTm-kGls5d-THy9jJQZqLoauw"/><title>phi.log</title><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e61452b80f7f8356.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e61452b80f7f8356.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c0b66b64eb886a29.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0b66b64eb886a29.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-5dc3bdee87ff18dd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f6271bdec05edb1f.js" defer=""></script><script src="/_next/static/chunks/996-f3cf67c2e3ac5e06.js" defer=""></script><script src="/_next/static/chunks/756-1349105dbea71525.js" defer=""></script><script src="/_next/static/chunks/224-ddba219ecdd5c904.js" defer=""></script><script src="/_next/static/chunks/pages/posts/@tag/%5B...tag%5D-5364b6481a3135f4.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_buildManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_ssgManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style>
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: #29D;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow: 0 0 10px #29D, 0 0 5px #29D;
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: #29D;
        border-left-color: #29D;
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style><div class="container" style="max-width:900px;min-width:400px"><div class="container default_app"><header><div class="container"><nav class="navbar-light fixed-top navbar navbar-expand-sm bg-light" role="navigation"><div class="container" style="max-width:900px"><div class="container-fluid"><ul class="navbar-nav w-100"><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-home"></i> Home</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@tag"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-hashtag"></i> Post</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@page"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-blog"></i> Page</div></a></li><div class="container d-flex justify-content-end align-self-center"><div class="row"><div class="col"><form class="input-group w-auto" method="get" action="https://www.google.com/search" target="_blank" style="min-width:230px"><input type="hidden" name="sitesearch" value="phi-friday.github.io"/><input type="search" class="form-control" placeholder="Search in Google" aria-label="Search" name="q" maxLength="255"/><button class="ripple ripple-surface btn btn-outline-primary" role="button"><i class="fa fa-search"></i></button></form></div></div></div></ul></div></div></nav></div></header><main><div class="container"><div class="row"><div><span><span class="badge bg-light mx-1 text-dark">@all<!-- --> <span class="badge bg-danger">25</span></span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> <span class="badge bg-danger">21</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> <span class="badge bg-danger">14</span></span></span><span><span class="badge bg-light mx-1 text-dark">#sqlmodel<!-- --> <span class="badge bg-danger">8</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#crud<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#returns<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#함수형 프로그래밍<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#windows<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#wsl<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#tdd<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#anyio<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-primary mx-1">#async<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vim<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#js<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#ts<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#nextjs<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#velog<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#github<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#restful<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#pytest<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#alembic<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#postgres<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#black<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#isort<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vscode<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#asyncio<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#trio<!-- --> <span class="badge bg-danger">1</span></span></span></div></div><div class="row"><div class="container"><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#anyio<!-- --> </span></span><span><span class="badge bg-primary mx-1">#async<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2021-11-29T18:42:54.419+09:00">작성일: 2021년 11월 29일</time></h6></p></p><p class="card-text">anyio로 작업 생성 + 작업간 정보 주고받기</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#anyio<!-- --> </span></span><span><span class="badge bg-primary mx-1">#async<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#asyncio<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#trio<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">파이썬으로 동시성 프로그래밍을 쉽게 하는법</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2021-11-27T17:20:16.241+09:00">작성일: 2021년 11월 27일</time></h6></p></p><p class="card-text">asyncio? trio? anyio!</p></div></div></div></div><div class="row"><ul class="pagination justify-content-center"><li class="page-item disabled"><a class="page-link" href="/posts/@tag/async/1"><i class="fa fa-angle-double-left"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/async/0"><i class="fa fa-angle-left"></i></a></li><li class="page-item active"><a class="page-link">1</a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/async/6"><i class="fa fa-angle-right"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/async/1"><i class="fa fa-angle-double-right"></i></a></li></ul></div></div></main><footer class="text-center text-muted"></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"async","page":1,"max_page":1,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2","content":"\n비동기 프로그래밍의 핵심은 무엇일까? 저는 **작업을 생성**하고, 각 작업의 **전환점을 명시**하고, 각 작업간 **정보를 주고받는 것**이라고 생각합니다.\n\n**전환점을 명시**하는 것은 `python`에 특별한 키워드로 추가됐기에, 명확합니다. 각 작업간 전환이 가능하다(`awaitable`이라고 하는 것 같습니다)는 것을 알리는 `async`와, 전환점을 명확하게 알리는 `await`입니다.\n\n그렇다면 **작업을 생성**하고, **정보를 주고받는 것**은 어떻게 해야할까요?\n\n## `anyio`의 작업 생성\n\n`anyio`는 `trio`의 작업 생성 방식을 따라합니다. 그리고 `trio`는 **암시적 동시성**이 없습니다. 따라서 모든 기능은 위에서 아래로 실행합니다.\n\n`trio`는 사용자가 작업을 생성할 때, 그 작업에 대한 책임을 지도록 설계되었습니다. 이 설계는 `async with` 블록으로 나타내며, 이 블록에서 `start_soon`메소드로 호출된 모든 `awaitable` 함수는 동시에 실행되는 하나의 작업으로 생성됩니다. `trio`는 이것을 `nursery`라고 명명했습니다.\n\n`anyio`에서는 이러한 과정을 `task_group`이라 명명해서 보다 직관적으로 알 수 있게 했습니다. 실제 코드로 확인해보겠습니다.\n\n```python\nfrom datetime import datetime\n\nimport anyio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await anyio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with anyio.create_task_group() as task_group:\n        for num in range(5):\n            task_group.start_soon(just_sleep, num, 5)\n        return\n\n\nif __name__ == \"__main__\":\n    print(f\"{datetime.today()}:: main start\")\n    result = anyio.run(main)\n    print(f\"{datetime.today()}:: main end??? {result=}\")\n```\n\n이 코드에서 실제로 실행되는 함수는 `main` 함수입니다. 이 함수의 코드를 확인해보면, 우선 `async with anyio.create_task_group`으로 `task_group`을 생성합니다. 그리고 이 `task_group` 블록 안에서 `task_group.start_soon`메소드를 이용하여 5개의 `just_sleep`을 호출했습니다.\n\n따라서 이 `task_group` 블록에는, 총 5개의 `just_sleep` 작업이 예정되어있습니다. 하지만 `task_group` 블록을 나가기 전에, `return` 키워드를 작성해서, `task_group` 블록에 5개의 작업을 호출한 직후 해당 함수를 종료하도록 했습니다.\n\n만약 의도한대로 실행된다면, 5개의 `just_sleep` 작업이 생성되지만, 그 직후 main 함수는 `None`을 반환하고, main end??? 는 main start 출력 이후 1초 내에 출력될 것입니다.\n\n```log\n2021-11-29 17:56:17.798277:: main start\n2021-11-29 17:56:17.800793:: num=0, second=5 sleep start\n2021-11-29 17:56:17.800829:: num=1, second=5 sleep start\n2021-11-29 17:56:17.800853:: num=2, second=5 sleep start\n2021-11-29 17:56:17.800869:: num=3, second=5 sleep start\n2021-11-29 17:56:17.800884:: num=4, second=5 sleep start\n2021-11-29 17:56:22.806281:: num=0, second=5 sleep end\n2021-11-29 17:56:22.806401:: num=1, second=5 sleep end\n2021-11-29 17:56:22.806443:: num=2, second=5 sleep end\n2021-11-29 17:56:22.806479:: num=3, second=5 sleep end\n2021-11-29 17:56:22.806513:: num=4, second=5 sleep end\n2021-11-29 17:56:22.807098:: main end??? result=None\n```\n\n하지만 실제 결과는, `return`과 무관하게 생성한 작업이 모두 끝난 이후 `return`이 실행됩니다. 즉, 사용자는 작업을 생성할 때, 각 작업을 어떤식으로든 완료되는 것을 확인 할 의무가 있습니다. 만약 작업 도중 `return`을 실행할 일이 있다면, 그에 맞는 조건을 설정하여 해당 `task_group`을 종료시킨 다음 `return`하는 것이 맞습니다.\n\n말이 길어졌기에, 요약하자면\n\n\u003e 1. `awaitable` 함수는 `async with anyio.create_task_group` 블록 내부에서 `task_group.start_soon` 메소드로 호출한다.\n\u003e 2. 생성된 작업은, 어떤식으로든 완료시켜야 한다.\n\n이 2가지만 기억해도 큰 문제가 없습니다.\n\n## `anyio`의 정보 주고받기\n\nanyio에서 정보를 주고받을때 사용하는 것을 `stream`이라고 합니다. 이 `stream`은 크게 두가지로 분류되는데, 바이트 스트림과 객체 스트림입니다.\n\n객체 스트림은 기존에 사용하던 큐와 거의 같은 형태로 사용이 가능합니다. `stream`의 버퍼 사이즈를 지정하고, 버퍼 사이즈 만큼 객체를 입력하고, 버퍼에 객체가 있으면 그 객체를 가져오는 간단한 방식입니다. `trio`에서는 `channel`이라고 명명합니다.\n\n바이트 스트림은 약간 다릅니다. 만약 사용자가 `b'qwe'`, `b'rty'`라는 두개의 바이트 객체를 입력했다면, 이 스트림에서 객체를 받을 때, `b'qwe'`, `b'rty'`라고 받을 수도 있지만, `b'q'`, `b'wer'`, `b'ty'`라고 받을 수도 있고, `b'qwert'`, `b'y'`라고 받을 수도 있습니다. `trio`에서는 `stream`이라고 명명합니다.\n\n실제로 `stream`을 사용하는 코드로 확인하겠습니다.\n\n```python\nfrom datetime import datetime\nfrom random import uniform\n\nimport anyio\nfrom anyio.abc import ObjectReceiveStream, ObjectSendStream\n\n\nasync def ping(num: int, send: ObjectSendStream):\n    print(f\"{datetime.today()}:: {num=}, ping start\")\n    async with send:\n        sleep_time = uniform(0, 3)\n        await anyio.sleep(sleep_time)\n        await send.send((f\"ping from {num=}, {sleep_time=}\", sleep_time))\n    print(f\"{datetime.today()}:: {num=}, ping end\")\n\n\nasync def pong(receive: ObjectReceiveStream):\n    sleep_time_sum = 0\n    print(f\"{datetime.today()}:: pong start\")\n    async for text, sleep_time in receive:\n        print(f\"{datetime.today()}:: pong:: {text}\")\n        sleep_time_sum += sleep_time\n    print(f\"{datetime.today()}:: pong end:: {sleep_time_sum=}\")\n\n\nasync def main():\n    async with anyio.create_task_group() as task_group:\n        send, receive = anyio.create_memory_object_stream(0)\n        async with send:\n            for num in range(5):\n                task_group.start_soon(ping, num, send.clone())\n        async with receive:\n            task_group.start_soon(pong, receive.clone())\n\n\nif __name__ == \"__main__\":\n    result = anyio.run(main)\n```\n\n우선 `main`함수부터 확인하겠습니다.\n\n`create_task_group`으로 `task_group` 블록을 생성합니다. 그리고 `create_memory_object_stream`으로 각 작업간 정보를 주고받기 위한 `stream`을 생성합니다.\n\n\u003e 이때 생성된 `stream`은 send와 receive 두개로 나뉘어 반환됩니다.\n\n이어서 5개의 `ping`과 1개의 `pong` 작업을 호출해서, 실제로 `main`을 실행할 때 실행될 작업을 지정합니다.\n\n여기서 사용되는 `async with send`와 `async with receive`는 안전한 프로그래밍을 위해 필요한 문법으로, 해당 블록이 끝나면 따로 `close` 메소드를 호출 할 필요 없이, 자동으로 해당 객체를 닫습니다.\n\n그리고 `start_soon`으로 호출되는 각 작업에 send와 receive를 보낼 때 사용되는 `clone`메소드는, 해당 `stream`의 새로운 send와 receive를 생성해서 보내기 위해서 사용됩니다. 만약 send나 receive를 사용하는 작업이 하나가 아닐 때 `clone` 메소드를 사용하지 않는다면, 의도치 않은 `ClosedResourceError`를 만나게 될 수 있습니다.\n\n`main`에서 호출된 작업은 간단합니다.\n`ping`은 0~3초 사이의 랜덤한 시간동안 대기한 다음, 해당 시간에 대한 정보를 send를 이용해서 보냅니다.\n`pong`은 receive를 통해 받은 정보를 출력하고, 합산합니다.\n또한, 각 `ping` 작업은 `main`에서 사용된 방식과 같은 방식으로 `async with` 블록으로 구성되어 있으므로, 따로 `close` 메소드를 호출 할 필요가 없습니다.\n\n이 방식은 상당히 유용한데, 모든 send가 닫히고, 더이상 버퍼에 정보가 없다면 `async for` 블록 또한 자동으로 닫히게 됩니다.\n\n위 코드를 실행해보면 다음과 같은 출력을 확인할 수 있습니다.\n\n```log\n2021-11-29 18:34:55.095995:: num=0, ping start\n2021-11-29 18:34:55.096041:: num=1, ping start\n2021-11-29 18:34:55.096056:: num=2, ping start\n2021-11-29 18:34:55.096068:: num=3, ping start\n2021-11-29 18:34:55.096080:: num=4, ping start\n2021-11-29 18:34:55.096091:: pong start\n2021-11-29 18:34:55.348744:: num=4, ping end\n2021-11-29 18:34:55.348931:: pong:: ping from num=4, sleep_time=0.25142686937439906\n2021-11-29 18:34:56.042114:: num=3, ping end\n2021-11-29 18:34:56.042310:: pong:: ping from num=3, sleep_time=0.9448073290170278\n2021-11-29 18:34:56.779485:: num=1, ping end\n2021-11-29 18:34:56.779686:: pong:: ping from num=1, sleep_time=1.6822150526554853\n2021-11-29 18:34:56.925375:: num=2, ping end\n2021-11-29 18:34:56.925595:: pong:: ping from num=2, sleep_time=1.8275787340996095\n2021-11-29 18:34:57.535689:: num=0, ping end\n2021-11-29 18:34:57.535911:: pong:: ping from num=0, sleep_time=2.4386441219878816\n2021-11-29 18:34:57.536030:: pong end:: sleep_time_sum=7.144672107134403\n```\n\n바이트 스트림 또한 대동소이합니다.\n\n요약하자면\n\n\u003e 1. 바이트 스트림과 객체 스트림으로 정보를 주고받을 수 있다.\n\u003e 2. send와 receive 두개로 나누어 사용한다.\n\u003e 3. send 또는 receive를 사용하는 작업이 여러개라면 `clone` 메소드를 사용한다.\n\u003e 4. `async with`, `async for`를 사용하면 좀 더 깔끔하고 명확하게 작성할 수 있다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2","data":{"title":"파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2","date":"2021-11-29T18:42:54.419+09:00","tags":["anyio","async","python","@all"],"page":"파이썬 동시성 프로그래밍","summary":"anyio로 작업 생성 + 작업간 정보 주고받기"}},{"name":"파이썬으로 동시성 프로그래밍을 쉽게 하는법","content":"\n## 동시성 프로그래밍이란\n\n동시성 프로그래밍은, **한 사람이 두가지 이상의 일을 같이 작업하는 것**을 말합니다.\n\n예를 들자면, 한 사람이 세탁기를 돌리고, 세탁기가 돌아가던 중 설거지를 하고, 설거지를 하던 중 전화를 받고, 세탁기가 끝나서 빨래를 널고, 설거지를 마저 끝내는 것입니다.\n\n이것을 만약 순차적으로 한다면, 세탁기를 돌리고 끝날 때 까지 기다린 다음 빨래를 널고, 이후 설거지를 합니다. 설거지가 끝나지 않았으니 전화는 받을 수 없고, 설거지가 끝난 다음 전화를 받습니다.\n\n어떤 방식이 더 효율적인지는 따로 설명하지 않아도 알 수 있습니다.\n\n### `asyncio`, 동시성 프로그래밍의 아주 간단한 예\n\n```python\nimport asyncio\nfrom datetime import datetime\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await asyncio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    tasks = [just_sleep(num, 1) for num in range(5)]\n    await asyncio.gather(*tasks)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n`asyncio`는 파이썬의 동시성 프로그래밍을 위한 기본 라이브러리입니다. 동시성 프로그래밍을 위해서는 `async`와 `await` 키워드를 알아야 합니다.\n\n\u003e `async`는 이 함수가 다른 작업을 위해 기다릴 수 있다는 것을 의미합니다.\n\u003e `await`은 `async`로 정의된 함수가 기다리는 지점을 특정합니다.\n\n따라서 위 코드는 1초간 기다리는 5개의 작업을 실시하는 간단한 코드입니다.\n\n\u003e 1초간 기다리 행위는, 데이터를 쓰거나 읽는 등의 작업이 걸리는 시간을 흉내내는 것입니다.\n\n실제로 실행해보면, 다음과 같은 출력을 얻습니다.\n\n```log\n2021-11-27 16:17:25.901585:: num=0, second=1 sleep start\n2021-11-27 16:17:25.901626:: num=1, second=1 sleep start\n2021-11-27 16:17:25.901642:: num=2, second=1 sleep start\n2021-11-27 16:17:25.901653:: num=3, second=1 sleep start\n2021-11-27 16:17:25.901662:: num=4, second=1 sleep start\n2021-11-27 16:17:26.902915:: num=0, second=1 sleep end\n2021-11-27 16:17:26.902996:: num=1, second=1 sleep end\n2021-11-27 16:17:26.903025:: num=2, second=1 sleep end\n2021-11-27 16:17:26.903053:: num=3, second=1 sleep end\n2021-11-27 16:17:26.903080:: num=4, second=1 sleep end\n```\n\n`num=0`인 작업이 `await asyncio.sleep(sencond=1)`에서 1초간 대기하기 때문에, 그동안 `num=1`작업을 실행할 수 있습니다.\n\n\u003e #### 왜 `time.sleep`이 아닌 `asyncio.sleep`인가?\n\u003e\n\u003e `time.sleep`은 블로킹 함수입니다. 블로킹 함수는 `async`로 정의되지 않아 기다릴 수 없는 함수입니다. 만약 `asyncio.sleep`대신 `time.sleep`을 사용한다면, io작업을 흉내낸다기 보다, cpu작업을 흉내내게 됩니다.\n\n### 하지만 뭔가 어색하다\n\n구글에서 검색해서 얻을 수 있는 자료나, 시중에서 판매하는 책을 보면 `yield` 키워드를 쓴다던가, `ensure_future`를 쓴다던가, `get_running_loop`를 쓴다던가.. 최신의 `asyncio`의 사용법에 맞지 않은 방법을 소개하는 글이 많습니다.\n\n\u003e 물론 `ensure_future`나 `get_running_loop`와 같은 함수를 쓸 수도 있습니다. 하지만 **저수준 api를 다뤄야 할 때 필요하지, 대부분의 경우 그렇지 않습니다.**\n\n아직 파이썬에서 동시성 프로그래밍을 제대로 지원한지 얼마 되지 않아, 버전이 올라갈수록 변경사항이 많아서 이런 일이 생긴겁니다.\n\n## `trio`, 조금 더 현대적인 방식으로\n\n그렇다면 차라리 더 최근에 만들어진 라이브러리를 사용하는게 어떨까요? 적어도 검색했을때 헷갈리는 일은 없을테니까요.\n\n기본 라이브러리인 `asyncio` 대신 `trio`라는 라이브러리가 있습니다. 개인적으로 좋아하는 `open_nursery`라는 함수가 있습니다. ~~끔찍한 gather는 이제 그만두고~~ 앞에서 `asyncio`로 작성한 코드를 `trio`로는 어떻게 작성할 수 있을까요.\n\n```python\nfrom datetime import datetime\n\nimport trio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await trio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with trio.open_nursery() as nursery:\n        for num in range(5):\n            nursery.start_soon(just_sleep, num, 1)\n\n\nif __name__ == \"__main__\":\n    trio.run(main)\n```\n\n사실 여기서 달라진건 많이 없습니다. 특징적인 부분은 `gather`로 작업을 모으는 대신, `nursery` 블록에서 `nursery.start_soon` 메소드로 `just_sleep` 작업 5개를 지시한 것입니다.\n\n출력 결과를 보면 이전과 대동소이합니다.\n\n```log\n2021-11-27 16:38:19.661314:: num=4, second=1 sleep start\n2021-11-27 16:38:19.661370:: num=3, second=1 sleep start\n2021-11-27 16:38:19.661393:: num=2, second=1 sleep start\n2021-11-27 16:38:19.661415:: num=1, second=1 sleep start\n2021-11-27 16:38:19.661434:: num=0, second=1 sleep start\n2021-11-27 16:38:20.662955:: num=4, second=1 sleep end\n2021-11-27 16:38:20.663113:: num=3, second=1 sleep end\n2021-11-27 16:38:20.663196:: num=2, second=1 sleep end\n2021-11-27 16:38:20.663272:: num=1, second=1 sleep end\n2021-11-27 16:38:20.663347:: num=0, second=1 sleep end\n```\n\n### 다른게 별로 없는데 왜 `trio`를 써야하지\n\n위 코드만 봤을때, `trio`를 써서 얻는 이득은 그다지 없어 보입니다. 하지만 그건 지금 코드가 아주 간단한 형태로 작성되어 있기 때문에 그렇습니다. 이후 사용하게 될 `channel` (`anyio`에서는 `stream`) 과 `CancelScope`, `Semaphore` 에서 그 이점이 드러나게 됩니다.\n\n### 잘 작성된 document\n\n`trio`의 [document](https://trio.readthedocs.io/en/stable/index.html)는 꽤 잘만들었다 생각합니다. 사용하다 막히는 부분이 있을때 따로 검색하기 보다는 공식 문서를 다시 한번 읽어보는게 도움이 되는 경우가 더 많았습니다.\n\n### 아쉽게도 기존 asyncio와 호환 안됨\n\n`trio`는 다 좋은데 기존 `asyncio`와 호환이 되지 않습니다. 즉, 이미 `asyncio`로 작성된 코드가 있다면 `trio`를 사용하기 위해서는 전부 수정을 해야합니다.\n\n무엇보다도 `uvloop`를 지원하지 않습니다. `uvloop`는 간단한 사용법으로 파이썬 동시성 프로그래밍의 성능을 끌어올릴 수 있는데, `trio`에서는 사용할 수가 없습니다.\n\n그렇다면 `trio`의 기능적 특징을 가지고, `asyncio`와 호환되고, `uvloop`도 지원하는 그런 라이브러리는 없을까요? **있습니다.** `anyio`라는 라이브러리를 사용하면 됩니다.\n\n## `anyio`, 현대적 방식과 호환성을 한번에\n\n`anyio`는 `asyncio`와 `trio`를 둘 다 사용할 수 있습니다. `asyncio`를 사용하고 싶다면 백엔드로 `asyncio`를 지정하고, `trio`를 사용하고 싶다면 `trio`를 지정하기만 하면 됩니다. `uvloop`를 사용하고 싶다면? `use_uvloop=True` 파라미터를 입력하기만 하면 됩니다.\n\n\u003e 그렇다면 `trio`의 기능을 사용하기 위해 무조건 백엔드를 `trio`로 지정해야 할까요? **아닙니다.** `anyio`는 `trio`의 기능을 `asyncio`로 구현한 라이브러리이기 때문에, `asyncio`를 백엔드로 사용해도 아무 문제가 없습니다.\n\n앞에서 `asyncio`와 `trio`로 작성했던 코드를 `anyio`로 다시 작성하겠습니다.\n\n```python\nfrom datetime import datetime\n\nimport anyio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await anyio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with anyio.create_task_group() as task_group:\n        for num in range(5):\n            task_group.start_soon(just_sleep, num, 1)\n\n\nif __name__ == \"__main__\":\n    anyio.run(main, backend_options=dict(use_uvloop=True))\n```\n\n\u003e `uvloop` 사용이 가능하다는 것을 보이기 위해 `backend_options=dict(use_uvloop=True)` 파라미터를 추가했습니다. 추가하지 않아도 문제 없습니다.\n\n`trio`로 작성된 코드와 차이점이 있다면 `trio.open_nursery`가 `anyio.create_task_group`로 바뀐 것 정도입니다. 실제로 대부분 용어의 문제지, `trio`에서 작성된 [document](https://trio.readthedocs.io/en/stable/index.html)는 `anyio`에 대부분 적용이 가능합니다.\n\n### 상대적으로 빈약한 document\n\n`anyio`의 [document](https://anyio.readthedocs.io/en/stable/index.html)는 상대적으로 좀 부족하다는 느낌을 받았습니다. 그래서 쓰다가 부족한 부분이 있으면 `trio`의 [document](https://trio.readthedocs.io/en/stable/index.html)를 읽어보고, `trio`와 대응하는 `anyio`의 모듈을 찾아서 해결하곤 했습니다.\n\n## 내 선택은 `anyio`\n\n저는 동시성 프로그래밍을 해야 할 일이 있으면 우선 `anyio`를 사용하는 편입니다. 특히 제가 좋아하는 프레임워크인 `fastapi`에서 `anyio`를 사용하기 때문에 거리낌 없이 사용할 수 있습니다. (`fastapi`에서 사용하는 `starlette`의 특정 버전부터 `anyio`를 지원하기 때문에 가능한 것으로, `anyio`를 사용하려면 버전 확인이 필요합니다.)\n\n이후 글에서는 `anyio`의 메소드와 클래스를 활용하는 것에 대해 작성할 예정입니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/파이썬으로 동시성 프로그래밍을 쉽게 하는법","data":{"title":"파이썬으로 동시성 프로그래밍을 쉽게 하는법","date":"2021-11-27T17:20:16.241+09:00","tags":["anyio","async","asyncio","python","trio","@all"],"page":"파이썬 동시성 프로그래밍","summary":"asyncio? trio? anyio!"}}]},"__N_SSG":true},"page":"/posts/@tag/[...tag]","query":{"tag":["async"]},"buildId":"MQ_lMVQgBI0RkmUA6wvVT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>