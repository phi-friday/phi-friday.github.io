<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="author" content="phi.friday@gmail.com, phi"/><meta name="robots" content="index,follow,noarchive"/><meta name="google-site-verification" content="lW107Dj5ageygd67UUzTm-kGls5d-THy9jJQZqLoauw"/><title>phi.log</title><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e61452b80f7f8356.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e61452b80f7f8356.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c0b66b64eb886a29.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0b66b64eb886a29.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-5dc3bdee87ff18dd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f6271bdec05edb1f.js" defer=""></script><script src="/_next/static/chunks/996-f3cf67c2e3ac5e06.js" defer=""></script><script src="/_next/static/chunks/756-1349105dbea71525.js" defer=""></script><script src="/_next/static/chunks/224-ddba219ecdd5c904.js" defer=""></script><script src="/_next/static/chunks/pages/posts/@tag/%5B...tag%5D-5364b6481a3135f4.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_buildManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_ssgManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style>
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: #29D;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow: 0 0 10px #29D, 0 0 5px #29D;
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: #29D;
        border-left-color: #29D;
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style><div class="container" style="max-width:900px;min-width:400px"><div class="container default_app"><header><div class="container"><nav class="navbar-light fixed-top navbar navbar-expand-sm bg-light" role="navigation"><div class="container" style="max-width:900px"><div class="container-fluid"><ul class="navbar-nav w-100"><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-home"></i> Home</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@tag"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-hashtag"></i> Post</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@page"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-blog"></i> Page</div></a></li><div class="container d-flex justify-content-end align-self-center"><div class="row"><div class="col"><form class="input-group w-auto" method="get" action="https://www.google.com/search" target="_blank" style="min-width:230px"><input type="hidden" name="sitesearch" value="phi-friday.github.io"/><input type="search" class="form-control" placeholder="Search in Google" aria-label="Search" name="q" maxLength="255"/><button class="ripple ripple-surface btn btn-outline-primary" role="button"><i class="fa fa-search"></i></button></form></div></div></div></ul></div></div></nav></div></header><main><div class="container"><div class="row"><div><span><span class="badge bg-light mx-1 text-dark">@all<!-- --> <span class="badge bg-danger">25</span></span></span><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> <span class="badge bg-danger">21</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi<!-- --> <span class="badge bg-danger">14</span></span></span><span><span class="badge bg-light mx-1 text-dark">#sqlmodel<!-- --> <span class="badge bg-danger">8</span></span></span><span><span class="badge bg-light mx-1 text-dark">#fastapi-users<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-light mx-1 text-dark">#crud<!-- --> <span class="badge bg-danger">4</span></span></span><span><span class="badge bg-primary mx-1">#returns<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#함수형 프로그래밍<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#windows<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#wsl<!-- --> <span class="badge bg-danger">3</span></span></span><span><span class="badge bg-light mx-1 text-dark">#tdd<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#anyio<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#async<!-- --> <span class="badge bg-danger">2</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vim<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#js<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#ts<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#nextjs<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#velog<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#github<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#restful<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#pytest<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#alembic<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#postgres<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#black<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#isort<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#vscode<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#asyncio<!-- --> <span class="badge bg-danger">1</span></span></span><span><span class="badge bg-light mx-1 text-dark">#trio<!-- --> <span class="badge bg-danger">1</span></span></span></div></div><div class="row"><div class="container"><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#returns<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#함수형 프로그래밍<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">returns로 파이썬 타입을 명확하게 만들자 2 - ROP</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-09-13T22:22:07.993+09:00">작성일: 2022년 9월 13일</time></h6></p></p><p class="card-text">파이썬 타입을 명확하게 만들면 vscode가 착해진다</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#returns<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#함수형 프로그래밍<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">returns로 파이썬 타입을 명확하게 만들자 1 - 주요 기능들</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-09-09T23:18:43.310+09:00">작성일: 2022년 9월 9일</time></h6></p></p><p class="card-text">파이썬 타입을 명확하게 만들면 vscode가 착해진다</p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><div><span><span class="badge bg-light mx-1 text-dark">#python<!-- --> </span></span><span><span class="badge bg-primary mx-1">#returns<!-- --> </span></span><span><span class="badge bg-light mx-1 text-dark">#함수형 프로그래밍<!-- --> </span></span></div></div><div class="card-body"><h5 class="card-title">returns로 파이썬 타입을 명확하게 만들자 0</h5><p class="card-subtitle"><p class="card-text text-muted"><h6><time dateTime="2022-09-09T02:10:44.645+09:00">작성일: 2022년 9월 9일</time></h6></p></p><p class="card-text">파이썬 타입을 명확하게 만들면 vscode가 착해진다</p></div></div></div></div><div class="row"><ul class="pagination justify-content-center"><li class="page-item disabled"><a class="page-link" href="/posts/@tag/returns/1"><i class="fa fa-angle-double-left"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/returns/0"><i class="fa fa-angle-left"></i></a></li><li class="page-item active"><a class="page-link">1</a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/returns/6"><i class="fa fa-angle-right"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@tag/returns/1"><i class="fa fa-angle-double-right"></i></a></li></ul></div></div></main><footer class="text-center text-muted"></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"returns","page":1,"max_page":1,"tag_counter":[["@all",25],["python",21],["fastapi",14],["sqlmodel",8],["fastapi-users",4],["crud",4],["returns",3],["함수형 프로그래밍",3],["windows",3],["wsl",3],["tdd",2],["anyio",2],["async",2],["vim",1],["js",1],["ts",1],["nextjs",1],["velog",1],["github",1],["restful",1],["pytest",1],["alembic",1],["postgres",1],["black",1],["isort",1],["vscode",1],["asyncio",1],["trio",1]],"posts":[{"name":"returns2","content":"\n# `ROP`\n## `ROP`에 대한 간략한 설명\n\u003e 오개념이 있을 가능성이 높으니, 따로 더 검색해서 알아보기를 권장합니다.\n\n`ROP`는 __Railway oriented programming__ 의 약어로, 직역하면 __철도 지향 프로그래밍__ 이다. 이름 그대로 `input`과 `output`를 적절한 철도(함수)로 이어준다.\n\n전통적인 방식에서는, 각 철도(함수)마다 예외처리를 실시하여 에러에 대응하지만, 프로그램의 규모가 커질수록 유지보수에 어려움이 발생한다.\n\n이를 해결하기 위해, 각 철도(함수)에서 발생하는 에러는 프로그램의 오작동을 유발하는 것이 아닌 적합한 `output`으로 간주하며, 다음 철도(함수)에서 `input`으로 활용한다.\n\n즉, 각 철도(함수)의 `input`과 `output`은 개발자가 의도한 정상적인 값과 의도하지 않은 비정상적인 값(에러)으로 구분된다.\n\n이렇게 작성된 프로그램은 각 철도(함수)별 예외처리가 없더라도, 각 철도(함수)별 `output`의 상태를 구분지을 수 있고, `output`은 단 두가지로 구분되므로, 다음 철도(함수)의 `input`으로 활용하는데 있어서 깔끔한 조작을 가능하게 한다. \n\n\u003e 위 글을 포함한 이전 포스트까지 __정상__ 상태와 __비정상__ 상태로 구분지어 표현하였으나, `returns`의 `container`와 용어를 일치하기 위해, 이후 글 부터는 __성공__ 과 __실패__ 로 대신합니다.\n\n## `returns`가 제시하는 `ROP`\n`returns`에서 미리 정의된 `container`는 `alt`, `map`, `lash`, `bind` 메소드를 사용하여 함수(철도)를 잇게 한다.\n\n* `alt`: __실패__ 를 사용하여, __실패__ 로 잇는다.\n* `map`: __성공__ 을 사용하여, __성공__ 으로 잇는다. \n* `lash`: __실패__ 를 사용하여, __성공__ 또는 __실패__ 로 잇는다.\n* `bind`: __성공__ 을 사용하여, __성공__ 또는 __실패__ 로 잇는다.\n\n다만 모든 `container`가 위와 같은 메소드를 가지고 있는 것은 아니다. `returns.interfaces` 모듈에는 이러한 메소드에 대한 인터페이스가 정의되어 있고, 해당하는 인터페이스를 만족하는 `container`가 위와 같은 메소드를 사용할 수 있다.\n\n\u003e `map`과 `bind`에 대한 간략한 설명과 예제는 이전 포스트에 포함되어 있고, `alt`와 `lash`는 `input`의 상태에만 차이가 있으므로 생략한다.\n\n# `container`에서 실제 값을 추출하는 방법\n```python\nfrom returns.maybe import Maybe\nfrom returns.primitives.exceptions import UnwrapFailedError\nfrom returns.result import ResultE\n\nassert ResultE.from_value(1).unwrap() == 1\ntry:\n    result = ResultE.from_failure(1).unwrap()\nexcept Exception as exc:\n    result = exc\nassert isinstance(result, UnwrapFailedError)\nassert ResultE.from_value(1).value_or(2) == 1\nassert ResultE.from_failure(1).value_or(2) == 2\n\nassert Maybe.from_optional(1).unwrap() == 1\ntry:\n    result = Maybe.from_optional(None).unwrap()\nexcept Exception as exc:\n    result = exc\nassert isinstance(result, UnwrapFailedError)\nassert Maybe.from_optional(1).value_or(2) == 1\nassert Maybe.from_optional(None).value_or(2) == 2\nassert Maybe.from_optional(1).or_else_call(lambda: 2) == 1\nassert Maybe.from_optional(None).or_else_call(lambda: 2) == 2\n```\n`Container`로 감싸진 내부의 값을 추출하기 위해서는 `unwrap` 또는 `value_or` 또는 'or_else_call` 메소드를 사용하면 된다.\n\n* `unwrap` 메소드는 __성공__ 일 때만 정상적으로 추출이 가능하다.\n\n* `value_or`는 __실패__ 일 때 처리가 가능하게 만든다.\n\n* `or_else_call`는 __실패__ 일 때 반환할 값을 지연시킬 수 있다.\n\u003e `or_else_call` 메소드는 `Maybe`에는 있고 `Result`에는 없다. `Result`에서는 `alt`가 있기 때문이다.\n\u003e\n\u003e 또한 `unwrap`이 불가능한 경우도 있다. `IO`가 대표적이다.\n\n# 원문\n[Railway oriented programming](https://returns.readthedocs.io/en/latest/pages/railway.html)","mtime":"2022-09-13T22:23:54.967+09:00","href":"python/returns2","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 2 - ROP","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-13T22:22:07.993+09:00"}},{"name":"returns1","content":"\n# `returns`의 주요 기능들\n\n`returns`는 파이썬 스크립트가 실행되면서 생성하는 값을 `Container`로 감싸고, 이 값을 개발자가 주도적으로 관리할 수 있도록 유도한다.\n\n기본적으로 완성된 형태로 제공되는 `Container`는 `Maybe`, `Result`, `IO`, `Future`, `RequiresContext`가 있고, 다음과 같은 경우 사용된다.\n\n* `Maybe`: `None` 일 수 있는 값\n* `Result`: 에러가 발생 할 수 있는 값\n* `IO`: `IO` 작업과 관련된 값\n* `Future`: 비동기 작업과 관련된 값\n* `RequiresContext`: 함수의 의존성과 관련된 값\n\n\u003e `IOResult`, `RequiresContextFutureResult` 등 결합된 형태로 제공하기도 한다. 물론 개발자가 직접 새로운 `Container`를 정의할 수도 있다.\n\n이러한 `Container`들은 `map`, `alt`, `bind`, `lash` 메소드를 이용하여 최종 결과물로 안전하게 도달하고, 개발자는 그 `Container`의 상태를 확인하고, 그 값을 사용하면 된다.\n\n## `Container`의 내부 값에 영향을 미치는 `map`\n설명보다는 코드를 직접 확인하는게 더 빠르다.\n```python\nfrom returns.maybe import Maybe, Nothing, Some\nfrom returns.result import Failure, ResultE, Success\n\n\ndef div_3(value: float) -\u003e float:\n    return value / 3\n\n\ndummy_exc = Exception(\"error\")\nsuccess_value: ResultE[int] = ResultE.from_value(1)\nmaybe_value: Maybe[int] = Maybe.from_optional(1)\nfailure_value: ResultE[int] = ResultE.from_failure(dummy_exc)\nmaybe_non_value: Maybe[int] = Maybe.from_optional(None)\n\nassert success_value == Success(1)\nassert failure_value == Failure(dummy_exc)\nassert maybe_value == Some(1)\nassert maybe_non_value == Nothing\n\nsuccess_result = success_value.map(div_3)\nfailure_result = failure_value.map(div_3)\nmaybe_result = maybe_value.map(div_3)\nmaybe_non_result = maybe_non_value.map(div_3)\n\nassert success_result == Success(div_3(1))\nassert failure_result is failure_value\nassert maybe_result == Some(div_3(1))\nassert maybe_non_result is Nothing\n\nassert success_result.unwrap() == div_3(1)\nassert failure_result.failure() is dummy_exc\nassert maybe_result.value_or(None) == div_3(1)\nassert maybe_non_result.value_or(\"test\") == \"test\"\n```\n`Container`의 내부 값을 사용하는 함수를 `map`메소드의 인수로 전달하면, 그 `Container`의 상태가 정상일 때만 작동하고, 그렇지 않다면 아무 일도 하지 않는다.\n\n즉, `map`은 정상적인 상태인 `Container`의 값만 변화시키는 메소드다.\n\n`map`에 사용되는 함수는 에러가 발생하지 않는 순수함수를 가정하고 사용되기에, 함수 실행중 에러가 발생하더라도 `Result` 객체로 감싸지지 않고 작동을 멈출 것이다.\n\n그렇다면 비정상 상태의 `Container` 내부의 값을 변화시키려면 어떻게 해야할까? 그때는 `alt` 메소드를 사용하면 된다.\n\n## `Container`의 상태를 변화시키는 `bind`\n```python\nfrom returns.maybe import Maybe, Nothing, Some, maybe\nfrom returns.result import Failure, ResultE, Success, safe\n\n\ndef div_3_v1(value: int) -\u003e ResultE[float]:\n    try:\n        return Success(3 / value)\n    except Exception as exc:\n        return Failure(exc)\n\n\n@safe\ndef div_3_v2(value: int) -\u003e float:\n    return 3 / value\n\n\ndef div_3_v3(value: int) -\u003e Maybe[float]:\n    try:\n        return Some(3 / value)\n    except:\n        return Nothing\n\n\n@maybe\ndef div_3_v4(value: int) -\u003e float | None:\n    return 3 / value\n\n\ndummy_exc = Exception(\"error\")\nsuccess_value: ResultE[int] = ResultE.from_value(0)\nmaybe_value: Maybe[int] = Maybe.from_optional(1)\nfailure_value: ResultE[int] = ResultE.from_failure(dummy_exc)\nmaybe_non_value: Maybe[int] = Maybe.from_optional(None)\n\nassert success_value == Success(0)\nassert failure_value == Failure(dummy_exc)\nassert maybe_value == Some(1)\nassert maybe_non_value == Nothing\n\nsuccess_result = success_value.bind(div_3_v1)\nfailure_result = failure_value.bind(div_3_v2)\nmaybe_result = maybe_value.bind(div_3_v3)\nmaybe_non_result = maybe_non_value.bind(div_3_v4)\n\nassert str(success_result) == \"\u003cFailure: division by zero\u003e\"\nassert failure_result is failure_value\nassert maybe_result == div_3_v4(1)\nassert maybe_non_result is Nothing\n\nassert repr(success_result.failure()) == \"ZeroDivisionError('division by zero')\"\nassert failure_result.failure() is dummy_exc\nassert maybe_result.value_or(None) == 3\nassert maybe_non_result.value_or(\"test\") == \"test\"\n```\n`bind`는 `Container`의 값을 사용하여 새로운 `Container`를 반환하는 함수를 받는다. 그 함수가 어떻게 정의됐는가에 따라 정상 상태의 `Container`를 반환할 수도 있고, 비정상 상태의 `Container`를 반환할 수도 있다.\n\n즉, `bind`는 정상적인 상태인 Container의 값과 상태를 변화시키는 메소드다.\n\n이러한 함수를 `div_3_v1`이나 `div_3_v3`처럼 일일이 정의하는 것은 손이 많이 가는 작업이므로, 가능하다면 `div_3_v2`이나 `div_3_v4`처럼 `safe`나 `maybe`와 같은 데코레이터를 사용할 것을 권장한다.\n\n`map`과 `alt`처럼 `bind`에도 대응하는 메소드가 있는데, 바로 `lash`다. `lash`는 비정상 상태의 컨테이너를 정상 상태의 컨테이너로 바꿀 수 있다. 물론 비정상 상태를 유지할 수도 있다.\n\n## 여러개의 `Container`를 함께 사용하는 방법\n\n`Container` 각각에 대해 `map`, `bind` 등을 사용하여 값과 상태를 관리하는 것은 알겠지만, 두개 이상의 `Container`를 복합적으로 사용하려면 어떻게 해야할까?\n\n여러 방법이 있겠지만, 그 중 세가지만 알아보자.\n\u003e `returns`는 `mypy`를 사용한다고 가정하기에, `pylance`에서는 정상적으로 타입추론이 되지 않는 경우가 있다.\n\u003e\n\u003e 대부분의 경우 문제가 없었는데, 후술할 `curry`가 그러했다.\n### 개별적으로 사용하는 방법\n```python\nfrom returns.curry import curry, partial\nfrom returns.io import IO\n\n\ndef sum_v1(left: float, right: float) -\u003e float:\n    return left + right\n\n\nsum_v2 = curry(sum_v1)\n\nleft: IO[float] = IO(1.0)\nright: IO[float] = IO(2.0)\n\nassert right.apply(left.apply(IO(sum_v2))) == IO(3.0) # pylance에서 문제 발생\nassert right.apply(left.apply(IO(lambda x: partial(sum_v1, x)))) == IO(3.0)\nassert right.apply(left.apply(IO(lambda x: lambda y: sum_v1(x, y)))) == IO(3.0)\nassert sum_v2(1.0)(2.0) == 3 # pylance에서 문제 발생\n```\n\n`returns`에서 제공하는 `curry`를 사용하면, 여러개의 인자를 필요로 하는 함수에 인자를 전달할 때, 한번에 모두 전달하지 않아도 된다. 물론 `lambda`와 `partial`을 사용해서 직접 구현해도 문제 없다.\n\n여기서 사용되는 `partial`은 `functools`와 같은 방식으로 사용된다. 차이가 있다면 `returns`의 `partial`은 좀 더 타입추론을 똑똑하게 해준다.\n\n\u003e 성능은 `lambda`로 직접 구현하는게 더 낫다고 한다..\n### `Iterable`로 묶어서 사용하는 방법\n```python\nfrom typing import Callable\n\nfrom returns.curry import partial\nfrom returns.io import IO\nfrom returns.iterables import Fold\n\n\ndef sum_v1(left: float, right: float) -\u003e float:\n    return left + right\n\n\ndef sum_v2(value: float) -\u003e Callable[[float], float]:\n    return partial(sum_v1, value)\n\n\ndef get_one() -\u003e IO[float]:\n    return IO(1)\n\n\nassert Fold.loop([get_one() for _ in range(10)], IO(5), sum_v2) == IO(10 + 5)\nassert Fold.loop([get_one() for _ in range(5)], IO(7), sum_v2) == IO(5 + 7)\n```\n`Fold.loop`는 `Iterable`로 묶여진 `Container`를 사용하는데 유용한 클래스메소드다. 내부 알고리즘은 단순하며, 다음과 같다.\n\u003e 1. `Iterable[Container[T]]`에서 `Container[T]` 하나를 선택한다.\n\u003e \n\u003e 2. 선택한 `Container[T]`로 `Callable[[R], R]` 객체를 생성한다. (`T`가 아니다!)\n\u003e\n\u003e 3. 초기값으로 지정된 `Container[R]`를 사용하여 새로운 초기값 `Container[R]`을 생성한다.\n\u003e\n\u003e 4. 반복\n\n### 여러개로 나눠진 `Container`를 하나로 합치는 방법\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.iterables import Fold\nfrom returns.maybe import Maybe, Nothing, Some, maybe\nfrom returns.result import Failure, Result, Success\n\ninit_data = dict(zip(list(\"abc\"), range(3)))\n\n\n@maybe\ndef get(key: str) -\u003e int | None:\n    return init_data.get(key)\n\n\nvalues_abc: list[Maybe[int]] = [get(key) for key in \"abc\"]\nvalues_abcd: list[Maybe[int]] = [get(key) for key in \"abcd\"]\nresult_abc: list[Result[int, None]] = [maybe_to_result(x) for x in values_abc]\nresult_abcd: list[Result[int, None]] = [maybe_to_result(x) for x in values_abcd]\n\nassert Fold.collect(values_abc, Some(())) == Some((0, 1, 2))\nassert Fold.collect(result_abc, Success(())) == Success((0, 1, 2))\nassert Fold.collect(values_abc, Some((100,))) == Some((100, 0, 1, 2))\nassert Fold.collect(result_abc, Success((200,))) == Success((200, 0, 1, 2))\n\nassert Fold.collect(values_abcd, Some(())) is Nothing\nassert Fold.collect(result_abcd, Success(())) == Failure(None)\n\nassert Fold.collect_all(values_abcd, Some(())) == Some((0, 1, 2))\nassert Fold.collect_all(result_abcd, Success(())) == Success((0, 1, 2))\nassert Fold.collect_all(values_abcd, Some((10, 20))) == Some((10, 20, 0, 1, 2))\nassert Fold.collect_all(result_abcd, Success((10, 20))) == Success((10, 20, 0, 1, 2))\n```\n\n`Fold.collect`를 사용하면, 모든 `Container`가 정상인 경우에 대해서만 수집을 진행하고,\n\n`Fold.collect_all`를 사용하면, 비정상 상태의 `Container`를 제외하고 수집을 진행한다.\n\n# 원문\n[Container: the concept](https://returns.readthedocs.io/en/latest/pages/container.html)\n","mtime":"2022-09-13T20:54:28.507+09:00","href":"python/returns1","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 1 - 주요 기능들","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-09T23:18:43.310+09:00"}},{"name":"returns0","content":"\n# 2% 부족한 `python`의 `type-hint`\n`python`에서 `type-hint` 지원이 점점 강력해지고, 이를 반영한 라이브러리들이 늘어나다 보니, 나도 `type-hint`를 적용해가며 개발을 하고 있다.\n\n하지만 아직 몇몇 아쉬운 부분이 보이는데,\n\n특정 클래스 메소드의 리턴값을 그 클래스의 인스턴스로 나타내려 할 때, `TypeVar`를 사용해서 `bound`를 일일이 지정해줘서 나타내야 한다던가..\n\u003e 이전에는 `TypeVar`를 사용해야 했지만, 이제는 PEP 673이 반영된 `typing_extensions`의 `Self`를 사용하면 된다.\n\u003e\n\u003e 하지만 아직 많은 라이브러리가 `Self`를 사용하고 있지는 않다.(이미 `TypeVar`로 많은 부분이 작성되어 있으므로)\n\n나중에 정의될 클래스를 `type-hint`로 사용하려면 문자열로 표현해야 한다던가..\n\u003e 3.11에서 수정될 예정이고, `__future__` 에서 `annotation` 모듈을 가져오면 미리 사용할 수 있다.\n\n`TypeVar`로 정의된 값을 이용해서 상위 제네릭을 표현할 수 없다던가..\n```python\nfrom typing import TypeVar, Generic\n\n_T = TypeVar(\"_T\")\n_Test = TypeVar(\"_Test\", bound=\"Test\")\n\nclass Test(Generic[_T]):\n    def __init__(self, data: _T):\n        self.data = data\n\ndef test(value: _T[int]) -\u003e _T[int]:\n    ...\n# TypeError: 'TypeVar' object is not subscriptable\n```\n\n쓰다보니 뭔가 대부분 `TypeVar` 관련인데, 이 중에서 `TypeVar`를 사용한 상위 제네릭과 관련해서 좀 더 알아봤더니, 제한적으로나마 이를 해결한 라이브러리가 있었는데, 그게 바로 [returns](https://github.com/dry-python/returns)다.\n\n\u003e 앞서 상위 제네릭이라 표현한 것은, 일반적으로 __Higher Kinded Type__ 이라고 하는 것 같다.\n\n# 함수형 프로그래밍에 적합한 `returns`\n라이브러리 이름이 범용적으로 쓰이는 `return`과 너무 유사해서, 제대로 검색이 되지 않는다. 마치 구글의 `go`를 보는 듯 하다..\n\n다행히 `returns` 자체 [문서](https://returns.readthedocs.io/en/latest/index.html)가 아주 잘 만들어져 있어서, 이해하는데 큰 문제는 없었다.\n\n또한 라이브러리 기능이 간단하면서도 강력해서, `type-hint` 외에도 쓸데가 많아보인다. 특히, 함수형 프로그래밍을 하고자 한다면 꽤 유용하지 않을까, 싶었는데 `readme`에서 함수형 프로그래밍을 위해 만들어진 라이브러리라고 직접 소개하고 있다.\n\u003e _Brings functional programming to Python land_\n\n처음에는 단순히 __Higher Kinded Type__ 를 위해 알아봤는데, 이제는 이 라이브러리를 어떻게 사용하면 잘 사용할 수 있을까 고민하게 됐다.\n\n`returns`의 대표적인 기능 두가지만 미리 소개하자면,\n\n## `Optional`을 대신 할 `Maybe`\n\n```python\nfrom returns.maybe import Maybe, maybe\n\n\n@maybe\ndef one_or_none(value: int) -\u003e int | None:\n    if value == 1:\n        return value\n    return None\n\n\nmaybe_one0: Maybe[int] = one_or_none(1)\nmaybe_one1: Maybe[int] = one_or_none(2)\n# or\n# maybe_one0: Maybe[int] = Maybe.from_optional(1)\n# maybe_one1: Maybe[int] = Maybe.from_optional(None)\n\nmaybe_str0 = maybe_one0.bind_optional(str)\nmaybe_str1 = maybe_one1.bind_optional(str)\n\nassert maybe_str0.value_or(\"error\") == \"1\"\nassert maybe_str1.value_or(\"error\") == \"error\"\n```\n원래라면 `if`문을 사용해서 `None` 타입 확인을 하고 진행했겠지만,\n\n`Maybe`는 마치 `js`의 `some_object?.some_attr`과 같은 방식으로 전개할 수 있게 만들어준다.\n\n\n## `try`, `except`를 대신할 `Result`\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Result, safe\n\n\n@safe\ndef div(left: float, right: float) -\u003e float:\n    # if right == 0:\n    # raise ZeroDivisionError\n    return left / right\n\n\nresult0: Result[float, Exception] = div(2, 3)\n# or\n# result0: Result[float, ZeroDivisionError]\n# or\n# from returns.result import ResultE\n# result0: ResultE[float] = div(2, 3)\nresult1: Result[float, Exception] = div(4, 0)\n\nassert (\n    result_to_maybe(result0.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == 4 / 9\n\nassert (\n    result_to_maybe(result1.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == \"error\"\n```\n\n에러에 대해 미리 고민 할 필요 없이, 기본적으로 제공되는 `map`, `bind`, `alt`, `lash` 등의 메소드를 사용하면 된다.\n\n올바른 타입이 아니라면 작동하지 않고, 추가적인 에러도 발생하지 않는다.\n\n위 예시에서는 문자열 `error`를 표시했지만, 원한다면 그 에러를 발생시킬 수도 있다.\n\n# 앞으로\n시간이 될 때, `returns`의 공식 문서를 나름대로 정리해서 포스팅을 하고자 한다. 하지만 이것도 다른 것과 마찬가지로 하다가 중단될 수 있다..\n","mtime":"2022-09-13T20:54:24.447+09:00","href":"python/returns0","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 0","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-09T02:10:44.645+09:00"}}]},"__N_SSG":true},"page":"/posts/@tag/[...tag]","query":{"tag":["returns"]},"buildId":"MQ_lMVQgBI0RkmUA6wvVT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>