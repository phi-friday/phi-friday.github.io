<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="author" content="phi.friday@gmail.com, phi"/><meta name="robots" content="index,follow,noarchive"/><meta name="google-site-verification" content="lW107Dj5ageygd67UUzTm-kGls5d-THy9jJQZqLoauw"/><title>phi.log</title><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e61452b80f7f8356.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e61452b80f7f8356.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c0b66b64eb886a29.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0b66b64eb886a29.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-5dc3bdee87ff18dd.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f6271bdec05edb1f.js" defer=""></script><script src="/_next/static/chunks/996-f3cf67c2e3ac5e06.js" defer=""></script><script src="/_next/static/chunks/pages/posts/@page/%5Bidx%5D-7f11aaad505dfa4c.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_buildManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_ssgManifest.js" defer=""></script><script src="/_next/static/MQ_lMVQgBI0RkmUA6wvVT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style>
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: #29D;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow: 0 0 10px #29D, 0 0 5px #29D;
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: #29D;
        border-left-color: #29D;
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style><div class="container" style="max-width:900px;min-width:400px"><div class="container default_app"><header><div class="container"><nav class="navbar-light fixed-top navbar navbar-expand-sm bg-light" role="navigation"><div class="container" style="max-width:900px"><div class="container-fluid"><ul class="navbar-nav w-100"><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-home"></i> Home</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@tag"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-hashtag"></i> Post</div></a></li><li class="nav-item"><a data-test="nav-link" class="nav-link" href="/posts/@page"><div class="text-nowrap nav_text__4OEN1"><i class="fa fa-blog"></i> Page</div></a></li><div class="container d-flex justify-content-end align-self-center"><div class="row"><div class="col"><form class="input-group w-auto" method="get" action="https://www.google.com/search" target="_blank" style="min-width:230px"><input type="hidden" name="sitesearch" value="phi-friday.github.io"/><input type="search" class="form-control" placeholder="Search in Google" aria-label="Search" name="q" maxLength="255"/><button class="ripple ripple-surface btn btn-outline-primary" role="button"><i class="fa fa-search"></i></button></form></div></div></div></ul></div></div></nav></div></header><main><div class="container"><div class="row"><div class="container"><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><h5 class="card-title">dry-python/returns</h5></div><div class="card-body"><p class="card-text" href="/posts/python/returns0"><a class="mb-2"><small class="text-muted">1<!-- -->. </small>returns로 파이썬 타입을 명확하게 만들자 0</a></p><p class="card-text" href="/posts/python/returns1"><a class="mb-2"><small class="text-muted">2<!-- -->. </small>returns로 파이썬 타입을 명확하게 만들자 1 - 주요 기능들</a></p><p class="card-text" href="/posts/python/returns2"><a class="mb-2"><small class="text-muted">3<!-- -->. </small>returns로 파이썬 타입을 명확하게 만들자 2 - ROP</a></p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><h5 class="card-title">fastapi 튜토리얼</h5></div><div class="card-body"><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-1-%20%EC%B4%88%EA%B8%B0%20%EC%84%A4%EC%A0%95"><a class="mb-2"><small class="text-muted">1<!-- -->. </small>fastapi 튜토리얼 -1- 초기 설정</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-2-%20sql%20%EC%84%9C%EB%B2%84%20%EC%97%B0%EA%B2%B0"><a class="mb-2"><small class="text-muted">2<!-- -->. </small>fastapi 튜토리얼 -2- sql 서버 연결</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-3-%20sql%20%EB%AA%A8%EB%8D%B8%20%EC%A0%95%EC%9D%98"><a class="mb-2"><small class="text-muted">3<!-- -->. </small>fastapi 튜토리얼 -3- sql 모델 정의</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-4-%20pytest%20%EC%A0%81%EC%9A%A9%20%EB%B0%8F%20%EC%8B%A4%ED%96%89"><a class="mb-2"><small class="text-muted">4<!-- -->. </small>fastapi 튜토리얼 -4- pytest 적용 및 실행</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-5-%20TDD%20%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%9C%BC%EB%A1%9C%20RESTful%20API%20%EC%83%9D%EC%84%B1"><a class="mb-2"><small class="text-muted">5<!-- -->. </small>fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-6-%20FastAPI%20Users%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%9C%20%EC%9C%A0%EC%A0%80%20api%20%EC%83%9D%EC%84%B1"><a class="mb-2"><small class="text-muted">6<!-- -->. </small>fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-7-%20FastAPI%20Users%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%9C%20%EC%9C%A0%EC%A0%80%20api%20%EC%83%9D%EC%84%B1%202"><a class="mb-2"><small class="text-muted">7<!-- -->. </small>fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-8-%20FastAPI%20Users%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%9C%20%EC%9C%A0%EC%A0%80%20api%20%EC%83%9D%EC%84%B1%203"><a class="mb-2"><small class="text-muted">8<!-- -->. </small>fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-8.1-%20SQLModel%20AsyncSession%20%EA%B4%80%EB%A0%A8%20%ED%83%80%EC%9E%85%20%EB%AC%B8%EC%A0%9C%20%EC%9E%84%EC%8B%9C%20%ED%95%B4%EA%B2%B0%20+%20%EC%B6%94%EA%B0%80%20%EC%88%98%EC%A0%95"><a class="mb-2"><small class="text-muted">9<!-- -->. </small>fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정</a></p><p class="card-text" href="/posts/velog/fastapi%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20-8.2-%20FastAPI%20Users%20v10%20%EB%8C%80%EC%9D%91"><a class="mb-2"><small class="text-muted">10<!-- -->. </small>fastapi 튜토리얼 -8.2- FastAPI Users v10 대응</a></p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><h5 class="card-title">파이썬 동시성 프로그래밍</h5></div><div class="card-body"><p class="card-text" href="/posts/velog/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84%20%EC%89%BD%EA%B2%8C%20%ED%95%98%EB%8A%94%EB%B2%95"><a class="mb-2"><small class="text-muted">1<!-- -->. </small>파이썬으로 동시성 프로그래밍을 쉽게 하는법</a></p><p class="card-text" href="/posts/velog/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84%20%EC%89%BD%EA%B2%8C%20%ED%95%98%EB%8A%94%EB%B2%95%20-%202"><a class="mb-2"><small class="text-muted">2<!-- -->. </small>파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2</a></p></div></div><div class="card border border-1 shadow-3 my-3 hover-shadow"><div class="card-header"><h5 class="card-title">FastAPI, sqlmodel로 간단한 crud api 생성</h5></div><div class="card-body"><p class="card-text" href="/posts/velog/FastAPI,%20sqlmodel%EB%A1%9C%20%EA%B0%84%EB%8B%A8%ED%95%9C%20crud%20api%20%EC%83%9D%EC%84%B1"><a class="mb-2"><small class="text-muted">1<!-- -->. </small>FastAPI, sqlmodel로 간단한 crud api 생성</a></p><p class="card-text" href="/posts/velog/FastAPI,%20sqlmodel%EB%A1%9C%20%EA%B0%84%EB%8B%A8%ED%95%9C%20crud%20api%20%EC%83%9D%EC%84%B1%202"><a class="mb-2"><small class="text-muted">2<!-- -->. </small>FastAPI, sqlmodel로 간단한 crud api 생성 2</a></p><p class="card-text" href="/posts/velog/FastAPI,%20sqlmodel%EB%A1%9C%20%EA%B0%84%EB%8B%A8%ED%95%9C%20crud%20api%20%EC%83%9D%EC%84%B1%203"><a class="mb-2"><small class="text-muted">3<!-- -->. </small>FastAPI, sqlmodel로 간단한 crud api 생성 3</a></p><p class="card-text" href="/posts/velog/FastAPI,%20sqlmodel%EB%A1%9C%20%EA%B0%84%EB%8B%A8%ED%95%9C%20crud%20api%20%EC%83%9D%EC%84%B1%204"><a class="mb-2"><small class="text-muted">4<!-- -->. </small>FastAPI, sqlmodel로 간단한 crud api 생성 4</a></p></div></div></div></div><div class="row"><ul class="pagination justify-content-center"><li class="page-item disabled"><a class="page-link" href="/posts/@page/1"><i class="fa fa-angle-double-left"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@page/0"><i class="fa fa-angle-left"></i></a></li><li class="page-item active"><a class="page-link">1</a></li><li class="page-item disabled"><a class="page-link" href="/posts/@page/6"><i class="fa fa-angle-right"></i></a></li><li class="page-item disabled"><a class="page-link" href="/posts/@page/1"><i class="fa fa-angle-double-right"></i></a></li></ul></div></div></main><footer class="text-center text-muted"></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"page":"1","max_page":1,"page_datas":[["dry-python/returns",[{"name":"returns0","content":"\n# 2% 부족한 `python`의 `type-hint`\n`python`에서 `type-hint` 지원이 점점 강력해지고, 이를 반영한 라이브러리들이 늘어나다 보니, 나도 `type-hint`를 적용해가며 개발을 하고 있다.\n\n하지만 아직 몇몇 아쉬운 부분이 보이는데,\n\n특정 클래스 메소드의 리턴값을 그 클래스의 인스턴스로 나타내려 할 때, `TypeVar`를 사용해서 `bound`를 일일이 지정해줘서 나타내야 한다던가..\n\u003e 이전에는 `TypeVar`를 사용해야 했지만, 이제는 PEP 673이 반영된 `typing_extensions`의 `Self`를 사용하면 된다.\n\u003e\n\u003e 하지만 아직 많은 라이브러리가 `Self`를 사용하고 있지는 않다.(이미 `TypeVar`로 많은 부분이 작성되어 있으므로)\n\n나중에 정의될 클래스를 `type-hint`로 사용하려면 문자열로 표현해야 한다던가..\n\u003e 3.11에서 수정될 예정이고, `__future__` 에서 `annotation` 모듈을 가져오면 미리 사용할 수 있다.\n\n`TypeVar`로 정의된 값을 이용해서 상위 제네릭을 표현할 수 없다던가..\n```python\nfrom typing import TypeVar, Generic\n\n_T = TypeVar(\"_T\")\n_Test = TypeVar(\"_Test\", bound=\"Test\")\n\nclass Test(Generic[_T]):\n    def __init__(self, data: _T):\n        self.data = data\n\ndef test(value: _T[int]) -\u003e _T[int]:\n    ...\n# TypeError: 'TypeVar' object is not subscriptable\n```\n\n쓰다보니 뭔가 대부분 `TypeVar` 관련인데, 이 중에서 `TypeVar`를 사용한 상위 제네릭과 관련해서 좀 더 알아봤더니, 제한적으로나마 이를 해결한 라이브러리가 있었는데, 그게 바로 [returns](https://github.com/dry-python/returns)다.\n\n\u003e 앞서 상위 제네릭이라 표현한 것은, 일반적으로 __Higher Kinded Type__ 이라고 하는 것 같다.\n\n# 함수형 프로그래밍에 적합한 `returns`\n라이브러리 이름이 범용적으로 쓰이는 `return`과 너무 유사해서, 제대로 검색이 되지 않는다. 마치 구글의 `go`를 보는 듯 하다..\n\n다행히 `returns` 자체 [문서](https://returns.readthedocs.io/en/latest/index.html)가 아주 잘 만들어져 있어서, 이해하는데 큰 문제는 없었다.\n\n또한 라이브러리 기능이 간단하면서도 강력해서, `type-hint` 외에도 쓸데가 많아보인다. 특히, 함수형 프로그래밍을 하고자 한다면 꽤 유용하지 않을까, 싶었는데 `readme`에서 함수형 프로그래밍을 위해 만들어진 라이브러리라고 직접 소개하고 있다.\n\u003e _Brings functional programming to Python land_\n\n처음에는 단순히 __Higher Kinded Type__ 를 위해 알아봤는데, 이제는 이 라이브러리를 어떻게 사용하면 잘 사용할 수 있을까 고민하게 됐다.\n\n`returns`의 대표적인 기능 두가지만 미리 소개하자면,\n\n## `Optional`을 대신 할 `Maybe`\n\n```python\nfrom returns.maybe import Maybe, maybe\n\n\n@maybe\ndef one_or_none(value: int) -\u003e int | None:\n    if value == 1:\n        return value\n    return None\n\n\nmaybe_one0: Maybe[int] = one_or_none(1)\nmaybe_one1: Maybe[int] = one_or_none(2)\n# or\n# maybe_one0: Maybe[int] = Maybe.from_optional(1)\n# maybe_one1: Maybe[int] = Maybe.from_optional(None)\n\nmaybe_str0 = maybe_one0.bind_optional(str)\nmaybe_str1 = maybe_one1.bind_optional(str)\n\nassert maybe_str0.value_or(\"error\") == \"1\"\nassert maybe_str1.value_or(\"error\") == \"error\"\n```\n원래라면 `if`문을 사용해서 `None` 타입 확인을 하고 진행했겠지만,\n\n`Maybe`는 마치 `js`의 `some_object?.some_attr`과 같은 방식으로 전개할 수 있게 만들어준다.\n\n\n## `try`, `except`를 대신할 `Result`\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Result, safe\n\n\n@safe\ndef div(left: float, right: float) -\u003e float:\n    # if right == 0:\n    # raise ZeroDivisionError\n    return left / right\n\n\nresult0: Result[float, Exception] = div(2, 3)\n# or\n# result0: Result[float, ZeroDivisionError]\n# or\n# from returns.result import ResultE\n# result0: ResultE[float] = div(2, 3)\nresult1: Result[float, Exception] = div(4, 0)\n\nassert (\n    result_to_maybe(result0.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == 4 / 9\n\nassert (\n    result_to_maybe(result1.map(lambda x: x**2).alt(str)).value_or(\"error\")\n) == \"error\"\n```\n\n에러에 대해 미리 고민 할 필요 없이, 기본적으로 제공되는 `map`, `bind`, `alt`, `lash` 등의 메소드를 사용하면 된다.\n\n올바른 타입이 아니라면 작동하지 않고, 추가적인 에러도 발생하지 않는다.\n\n위 예시에서는 문자열 `error`를 표시했지만, 원한다면 그 에러를 발생시킬 수도 있다.\n\n# 앞으로\n시간이 될 때, `returns`의 공식 문서를 나름대로 정리해서 포스팅을 하고자 한다. 하지만 이것도 다른 것과 마찬가지로 하다가 중단될 수 있다..\n","mtime":"2022-09-13T20:54:24.447+09:00","href":"python/returns0","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 0","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-09T02:10:44.645+09:00"}},{"name":"returns1","content":"\n# `returns`의 주요 기능들\n\n`returns`는 파이썬 스크립트가 실행되면서 생성하는 값을 `Container`로 감싸고, 이 값을 개발자가 주도적으로 관리할 수 있도록 유도한다.\n\n기본적으로 완성된 형태로 제공되는 `Container`는 `Maybe`, `Result`, `IO`, `Future`, `RequiresContext`가 있고, 다음과 같은 경우 사용된다.\n\n* `Maybe`: `None` 일 수 있는 값\n* `Result`: 에러가 발생 할 수 있는 값\n* `IO`: `IO` 작업과 관련된 값\n* `Future`: 비동기 작업과 관련된 값\n* `RequiresContext`: 함수의 의존성과 관련된 값\n\n\u003e `IOResult`, `RequiresContextFutureResult` 등 결합된 형태로 제공하기도 한다. 물론 개발자가 직접 새로운 `Container`를 정의할 수도 있다.\n\n이러한 `Container`들은 `map`, `alt`, `bind`, `lash` 메소드를 이용하여 최종 결과물로 안전하게 도달하고, 개발자는 그 `Container`의 상태를 확인하고, 그 값을 사용하면 된다.\n\n## `Container`의 내부 값에 영향을 미치는 `map`\n설명보다는 코드를 직접 확인하는게 더 빠르다.\n```python\nfrom returns.maybe import Maybe, Nothing, Some\nfrom returns.result import Failure, ResultE, Success\n\n\ndef div_3(value: float) -\u003e float:\n    return value / 3\n\n\ndummy_exc = Exception(\"error\")\nsuccess_value: ResultE[int] = ResultE.from_value(1)\nmaybe_value: Maybe[int] = Maybe.from_optional(1)\nfailure_value: ResultE[int] = ResultE.from_failure(dummy_exc)\nmaybe_non_value: Maybe[int] = Maybe.from_optional(None)\n\nassert success_value == Success(1)\nassert failure_value == Failure(dummy_exc)\nassert maybe_value == Some(1)\nassert maybe_non_value == Nothing\n\nsuccess_result = success_value.map(div_3)\nfailure_result = failure_value.map(div_3)\nmaybe_result = maybe_value.map(div_3)\nmaybe_non_result = maybe_non_value.map(div_3)\n\nassert success_result == Success(div_3(1))\nassert failure_result is failure_value\nassert maybe_result == Some(div_3(1))\nassert maybe_non_result is Nothing\n\nassert success_result.unwrap() == div_3(1)\nassert failure_result.failure() is dummy_exc\nassert maybe_result.value_or(None) == div_3(1)\nassert maybe_non_result.value_or(\"test\") == \"test\"\n```\n`Container`의 내부 값을 사용하는 함수를 `map`메소드의 인수로 전달하면, 그 `Container`의 상태가 정상일 때만 작동하고, 그렇지 않다면 아무 일도 하지 않는다.\n\n즉, `map`은 정상적인 상태인 `Container`의 값만 변화시키는 메소드다.\n\n`map`에 사용되는 함수는 에러가 발생하지 않는 순수함수를 가정하고 사용되기에, 함수 실행중 에러가 발생하더라도 `Result` 객체로 감싸지지 않고 작동을 멈출 것이다.\n\n그렇다면 비정상 상태의 `Container` 내부의 값을 변화시키려면 어떻게 해야할까? 그때는 `alt` 메소드를 사용하면 된다.\n\n## `Container`의 상태를 변화시키는 `bind`\n```python\nfrom returns.maybe import Maybe, Nothing, Some, maybe\nfrom returns.result import Failure, ResultE, Success, safe\n\n\ndef div_3_v1(value: int) -\u003e ResultE[float]:\n    try:\n        return Success(3 / value)\n    except Exception as exc:\n        return Failure(exc)\n\n\n@safe\ndef div_3_v2(value: int) -\u003e float:\n    return 3 / value\n\n\ndef div_3_v3(value: int) -\u003e Maybe[float]:\n    try:\n        return Some(3 / value)\n    except:\n        return Nothing\n\n\n@maybe\ndef div_3_v4(value: int) -\u003e float | None:\n    return 3 / value\n\n\ndummy_exc = Exception(\"error\")\nsuccess_value: ResultE[int] = ResultE.from_value(0)\nmaybe_value: Maybe[int] = Maybe.from_optional(1)\nfailure_value: ResultE[int] = ResultE.from_failure(dummy_exc)\nmaybe_non_value: Maybe[int] = Maybe.from_optional(None)\n\nassert success_value == Success(0)\nassert failure_value == Failure(dummy_exc)\nassert maybe_value == Some(1)\nassert maybe_non_value == Nothing\n\nsuccess_result = success_value.bind(div_3_v1)\nfailure_result = failure_value.bind(div_3_v2)\nmaybe_result = maybe_value.bind(div_3_v3)\nmaybe_non_result = maybe_non_value.bind(div_3_v4)\n\nassert str(success_result) == \"\u003cFailure: division by zero\u003e\"\nassert failure_result is failure_value\nassert maybe_result == div_3_v4(1)\nassert maybe_non_result is Nothing\n\nassert repr(success_result.failure()) == \"ZeroDivisionError('division by zero')\"\nassert failure_result.failure() is dummy_exc\nassert maybe_result.value_or(None) == 3\nassert maybe_non_result.value_or(\"test\") == \"test\"\n```\n`bind`는 `Container`의 값을 사용하여 새로운 `Container`를 반환하는 함수를 받는다. 그 함수가 어떻게 정의됐는가에 따라 정상 상태의 `Container`를 반환할 수도 있고, 비정상 상태의 `Container`를 반환할 수도 있다.\n\n즉, `bind`는 정상적인 상태인 Container의 값과 상태를 변화시키는 메소드다.\n\n이러한 함수를 `div_3_v1`이나 `div_3_v3`처럼 일일이 정의하는 것은 손이 많이 가는 작업이므로, 가능하다면 `div_3_v2`이나 `div_3_v4`처럼 `safe`나 `maybe`와 같은 데코레이터를 사용할 것을 권장한다.\n\n`map`과 `alt`처럼 `bind`에도 대응하는 메소드가 있는데, 바로 `lash`다. `lash`는 비정상 상태의 컨테이너를 정상 상태의 컨테이너로 바꿀 수 있다. 물론 비정상 상태를 유지할 수도 있다.\n\n## 여러개의 `Container`를 함께 사용하는 방법\n\n`Container` 각각에 대해 `map`, `bind` 등을 사용하여 값과 상태를 관리하는 것은 알겠지만, 두개 이상의 `Container`를 복합적으로 사용하려면 어떻게 해야할까?\n\n여러 방법이 있겠지만, 그 중 세가지만 알아보자.\n\u003e `returns`는 `mypy`를 사용한다고 가정하기에, `pylance`에서는 정상적으로 타입추론이 되지 않는 경우가 있다.\n\u003e\n\u003e 대부분의 경우 문제가 없었는데, 후술할 `curry`가 그러했다.\n### 개별적으로 사용하는 방법\n```python\nfrom returns.curry import curry, partial\nfrom returns.io import IO\n\n\ndef sum_v1(left: float, right: float) -\u003e float:\n    return left + right\n\n\nsum_v2 = curry(sum_v1)\n\nleft: IO[float] = IO(1.0)\nright: IO[float] = IO(2.0)\n\nassert right.apply(left.apply(IO(sum_v2))) == IO(3.0) # pylance에서 문제 발생\nassert right.apply(left.apply(IO(lambda x: partial(sum_v1, x)))) == IO(3.0)\nassert right.apply(left.apply(IO(lambda x: lambda y: sum_v1(x, y)))) == IO(3.0)\nassert sum_v2(1.0)(2.0) == 3 # pylance에서 문제 발생\n```\n\n`returns`에서 제공하는 `curry`를 사용하면, 여러개의 인자를 필요로 하는 함수에 인자를 전달할 때, 한번에 모두 전달하지 않아도 된다. 물론 `lambda`와 `partial`을 사용해서 직접 구현해도 문제 없다.\n\n여기서 사용되는 `partial`은 `functools`와 같은 방식으로 사용된다. 차이가 있다면 `returns`의 `partial`은 좀 더 타입추론을 똑똑하게 해준다.\n\n\u003e 성능은 `lambda`로 직접 구현하는게 더 낫다고 한다..\n### `Iterable`로 묶어서 사용하는 방법\n```python\nfrom typing import Callable\n\nfrom returns.curry import partial\nfrom returns.io import IO\nfrom returns.iterables import Fold\n\n\ndef sum_v1(left: float, right: float) -\u003e float:\n    return left + right\n\n\ndef sum_v2(value: float) -\u003e Callable[[float], float]:\n    return partial(sum_v1, value)\n\n\ndef get_one() -\u003e IO[float]:\n    return IO(1)\n\n\nassert Fold.loop([get_one() for _ in range(10)], IO(5), sum_v2) == IO(10 + 5)\nassert Fold.loop([get_one() for _ in range(5)], IO(7), sum_v2) == IO(5 + 7)\n```\n`Fold.loop`는 `Iterable`로 묶여진 `Container`를 사용하는데 유용한 클래스메소드다. 내부 알고리즘은 단순하며, 다음과 같다.\n\u003e 1. `Iterable[Container[T]]`에서 `Container[T]` 하나를 선택한다.\n\u003e \n\u003e 2. 선택한 `Container[T]`로 `Callable[[R], R]` 객체를 생성한다. (`T`가 아니다!)\n\u003e\n\u003e 3. 초기값으로 지정된 `Container[R]`를 사용하여 새로운 초기값 `Container[R]`을 생성한다.\n\u003e\n\u003e 4. 반복\n\n### 여러개로 나눠진 `Container`를 하나로 합치는 방법\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.iterables import Fold\nfrom returns.maybe import Maybe, Nothing, Some, maybe\nfrom returns.result import Failure, Result, Success\n\ninit_data = dict(zip(list(\"abc\"), range(3)))\n\n\n@maybe\ndef get(key: str) -\u003e int | None:\n    return init_data.get(key)\n\n\nvalues_abc: list[Maybe[int]] = [get(key) for key in \"abc\"]\nvalues_abcd: list[Maybe[int]] = [get(key) for key in \"abcd\"]\nresult_abc: list[Result[int, None]] = [maybe_to_result(x) for x in values_abc]\nresult_abcd: list[Result[int, None]] = [maybe_to_result(x) for x in values_abcd]\n\nassert Fold.collect(values_abc, Some(())) == Some((0, 1, 2))\nassert Fold.collect(result_abc, Success(())) == Success((0, 1, 2))\nassert Fold.collect(values_abc, Some((100,))) == Some((100, 0, 1, 2))\nassert Fold.collect(result_abc, Success((200,))) == Success((200, 0, 1, 2))\n\nassert Fold.collect(values_abcd, Some(())) is Nothing\nassert Fold.collect(result_abcd, Success(())) == Failure(None)\n\nassert Fold.collect_all(values_abcd, Some(())) == Some((0, 1, 2))\nassert Fold.collect_all(result_abcd, Success(())) == Success((0, 1, 2))\nassert Fold.collect_all(values_abcd, Some((10, 20))) == Some((10, 20, 0, 1, 2))\nassert Fold.collect_all(result_abcd, Success((10, 20))) == Success((10, 20, 0, 1, 2))\n```\n\n`Fold.collect`를 사용하면, 모든 `Container`가 정상인 경우에 대해서만 수집을 진행하고,\n\n`Fold.collect_all`를 사용하면, 비정상 상태의 `Container`를 제외하고 수집을 진행한다.\n\n# 원문\n[Container: the concept](https://returns.readthedocs.io/en/latest/pages/container.html)\n","mtime":"2022-09-13T20:54:28.507+09:00","href":"python/returns1","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 1 - 주요 기능들","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-09T23:18:43.310+09:00"}},{"name":"returns2","content":"\n# `ROP`\n## `ROP`에 대한 간략한 설명\n\u003e 오개념이 있을 가능성이 높으니, 따로 더 검색해서 알아보기를 권장합니다.\n\n`ROP`는 __Railway oriented programming__ 의 약어로, 직역하면 __철도 지향 프로그래밍__ 이다. 이름 그대로 `input`과 `output`를 적절한 철도(함수)로 이어준다.\n\n전통적인 방식에서는, 각 철도(함수)마다 예외처리를 실시하여 에러에 대응하지만, 프로그램의 규모가 커질수록 유지보수에 어려움이 발생한다.\n\n이를 해결하기 위해, 각 철도(함수)에서 발생하는 에러는 프로그램의 오작동을 유발하는 것이 아닌 적합한 `output`으로 간주하며, 다음 철도(함수)에서 `input`으로 활용한다.\n\n즉, 각 철도(함수)의 `input`과 `output`은 개발자가 의도한 정상적인 값과 의도하지 않은 비정상적인 값(에러)으로 구분된다.\n\n이렇게 작성된 프로그램은 각 철도(함수)별 예외처리가 없더라도, 각 철도(함수)별 `output`의 상태를 구분지을 수 있고, `output`은 단 두가지로 구분되므로, 다음 철도(함수)의 `input`으로 활용하는데 있어서 깔끔한 조작을 가능하게 한다. \n\n\u003e 위 글을 포함한 이전 포스트까지 __정상__ 상태와 __비정상__ 상태로 구분지어 표현하였으나, `returns`의 `container`와 용어를 일치하기 위해, 이후 글 부터는 __성공__ 과 __실패__ 로 대신합니다.\n\n## `returns`가 제시하는 `ROP`\n`returns`에서 미리 정의된 `container`는 `alt`, `map`, `lash`, `bind` 메소드를 사용하여 함수(철도)를 잇게 한다.\n\n* `alt`: __실패__ 를 사용하여, __실패__ 로 잇는다.\n* `map`: __성공__ 을 사용하여, __성공__ 으로 잇는다. \n* `lash`: __실패__ 를 사용하여, __성공__ 또는 __실패__ 로 잇는다.\n* `bind`: __성공__ 을 사용하여, __성공__ 또는 __실패__ 로 잇는다.\n\n다만 모든 `container`가 위와 같은 메소드를 가지고 있는 것은 아니다. `returns.interfaces` 모듈에는 이러한 메소드에 대한 인터페이스가 정의되어 있고, 해당하는 인터페이스를 만족하는 `container`가 위와 같은 메소드를 사용할 수 있다.\n\n\u003e `map`과 `bind`에 대한 간략한 설명과 예제는 이전 포스트에 포함되어 있고, `alt`와 `lash`는 `input`의 상태에만 차이가 있으므로 생략한다.\n\n# `container`에서 실제 값을 추출하는 방법\n```python\nfrom returns.maybe import Maybe\nfrom returns.primitives.exceptions import UnwrapFailedError\nfrom returns.result import ResultE\n\nassert ResultE.from_value(1).unwrap() == 1\ntry:\n    result = ResultE.from_failure(1).unwrap()\nexcept Exception as exc:\n    result = exc\nassert isinstance(result, UnwrapFailedError)\nassert ResultE.from_value(1).value_or(2) == 1\nassert ResultE.from_failure(1).value_or(2) == 2\n\nassert Maybe.from_optional(1).unwrap() == 1\ntry:\n    result = Maybe.from_optional(None).unwrap()\nexcept Exception as exc:\n    result = exc\nassert isinstance(result, UnwrapFailedError)\nassert Maybe.from_optional(1).value_or(2) == 1\nassert Maybe.from_optional(None).value_or(2) == 2\nassert Maybe.from_optional(1).or_else_call(lambda: 2) == 1\nassert Maybe.from_optional(None).or_else_call(lambda: 2) == 2\n```\n`Container`로 감싸진 내부의 값을 추출하기 위해서는 `unwrap` 또는 `value_or` 또는 'or_else_call` 메소드를 사용하면 된다.\n\n* `unwrap` 메소드는 __성공__ 일 때만 정상적으로 추출이 가능하다.\n\n* `value_or`는 __실패__ 일 때 처리가 가능하게 만든다.\n\n* `or_else_call`는 __실패__ 일 때 반환할 값을 지연시킬 수 있다.\n\u003e `or_else_call` 메소드는 `Maybe`에는 있고 `Result`에는 없다. `Result`에서는 `alt`가 있기 때문이다.\n\u003e\n\u003e 또한 `unwrap`이 불가능한 경우도 있다. `IO`가 대표적이다.\n\n# 원문\n[Railway oriented programming](https://returns.readthedocs.io/en/latest/pages/railway.html)","mtime":"2022-09-13T22:23:54.967+09:00","href":"python/returns2","data":{"title":"returns로 파이썬 타입을 명확하게 만들자 2 - ROP","tags":["python","returns","함수형 프로그래밍","@all"],"page":"dry-python/returns","summary":"파이썬 타입을 명확하게 만들면 vscode가 착해진다","date":"2022-09-13T22:22:07.993+09:00"}}]],["fastapi 튜토리얼",[{"name":"fastapi 튜토리얼 -1- 초기 설정","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## 초기 설정\n\n### 파이썬 설정\n\n우선 다음 명령어로 가상 파이썬 환경부터 잡아줬다.\n\n```bash\n❯ pyenv virtualenv 3.10.4 jeffastor_tutor\n❯ pyenv local jeffastor_tutor\n```\n\n실제로는 **`docker`** 로 실행하겠지만, **`vscode`** 를 사용하면서 **`pylance`** 의 자동완성과 타입 추론 기능을 사용하기 위해, 따로 만들었다.\n\n그리고 필수 패키지와 개인적으로 선호하는 **`orjson`** 을 설치한다.\n\n```bash\n❯ poetry init\n❯ poetry add fastapi \"uvicorn[standard]\" orjson\n❯ poetry add --dev black isort\n❯ cat pyproject.toml\n[tool.poetry]\nname = \"jeffastor_tutor\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"phi \u003cphi.friday@gmail.com\u003e\"]\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\nfastapi = \"^0.75.2\"\nuvicorn = {extras = [\"standard\"], version = \"^0.17.6\"}\norjson = \"^3.6.8\"\n\n[tool.poetry.dev-dependencies]\nblack = \"^22.3.0\"\nisort = \"^5.10.1\"\n\n[build-system]\nrequires = [\"poetry-core\u003e=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n```\n\n\u003e - fastapi - 백엔드 구축에 사용할 프레임워크\n\u003e - uvicorn - fastapi 앱을 사용하기 위한 asgi 서버\n\u003e - orjson - 좀 더 빠르고, 정확하고, 다양하게 파이썬 객체를 json으로 변환해주는 라이브러리\n\n### `fastapi` 기본 구성 설정\n\n**JeffAstor**가 제시한 디렉토리/모듈 구성은 대부분 그대로 가져갈 생각이다.\n\n```bash\n❯ mkdir backend backend/app backend/tests\n❯ mkdir backend/app/api backend/app/core\n❯ touch backend/app/api/__init__.py backend/app/api/server.py\n```\n\n```python\n# backend/app/api/server.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import ORJSONResponse\n\n\ndef get_application() -\u003e FastAPI:\n    app = FastAPI(title='jeffastor_tutor', default_response_class=ORJSONResponse)\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    return app\n\napp = get_application()\n```\n\n`CORSMiddleware`에 대해서는 지금 신경쓸 필요 없으며, 나중에 관련해서 자세히 설명하겠다고 한다.\n\n`default_response_class`는 **`fastapi`** 의 `response`를 직렬화 할 때 **`orjson`** 을 사용하기 위해 `ORJSONResponse`를 지정했다.\n\n### `docker` 설정\n\n이제 서버를 실행할 **`docker`** 를 설정한다.\n\n```bash\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes\n❯ touch docker-compose.yml backend/Dockerfile backend/.env\n```\n\n```Dockerfile\n# backend/Dockerfile\nFROM python:3.10-slim-bullseye\nWORKDIR /backend\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONBUFFERED 1\n# install system dependencies\n# RUN apt-get update \\\n#   \u0026\u0026 apt-get -y install netcat gcc postgresql \\\n#   \u0026\u0026 apt-get clean\n# install python dependencies\n# RUN pip install --upgrade pip\nCOPY ./requirements.txt /backend/requirements.txt\nRUN pip install -r requirements.txt\nCOPY . /backend\n```\n\n```yaml\n# docker-compose.yml\n# prettier-ignore\nversion: \"3.8\"\nservices:\n  server:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    volumes:\n      - ./backend/:/backend/\n    command: uvicorn app.api.server:app --reload --workers 2 --host 0.0.0.0 --port 8000\n    env_file:\n      - ./backend/.env\n    ports:\n      - 8000:8000\n```\n\nsql 서버는 다른 컨테이너로 관리할 예정이기에 주석처리했다.\n\n이제 **`docker`** 를 실행해보자.\n\n```bash\n❯ docker-compose up --build\n\n```\n\n브라우저에서 `localhost:8000`에 접속해보면\n\n```yaml\n{ 'detail': 'Not Found' }\n```\n\n아직 아무런 라우터를 추가하지 않았기에 나오는 기본값이 출력된다.\n\n## 기본 라우터 생성\n\n서버를 중단하지 않고, 이어서 라우터를 추가한다.\n\n```bash\n❯ mkdir backend/app/api/routes\n❯ touch backend/app/api/routes/__init__.py\n❯ touch backend/app/api/routes/cleanings.py\n```\n\n```python\n# backend/app/api/routes/cleanings.py\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/\")\nasync def get_all_cleanings() -\u003e list[dict]:\n    cleanings = [\n        {\"id\": 1, \"name\": \"My house\", \"cleaning_type\": \"full_clean\", \"price_per_hour\": 29.99},\n        {\"id\": 2, \"name\": \"Someone else's house\", \"cleaning_type\": \"spot_clean\", \"price_per_hour\": 19.99}\n    ]\n    return cleanings\n```\n\n```python\n# backend/app/api/routes/__init__.py\nfrom fastapi import APIRouter\n\nfrom .cleanings import router as cleanings_router\n\nrouter = APIRouter()\n\nrouter.include_router(cleanings_router, prefix=\"/cleanings\", tags=[\"cleanings\"])\n```\n\n원문은 절대참조로 작성했지만, **`docker`** 실행 환경에서는 정상적으로 작동하지만, 편집 환경에서는 **`pylance`** 가 정상적으로 인식하지 못하므로 상대참조로 변경했다.\n\n끝으로 `get_application`함수를 수정한다.\n\n```python\n# backend/app/api/server.py\n(...)\nfrom .routes import router as api_router\n\n\ndef get_application() -\u003e FastAPI:\n    app = FastAPI(title='jeffastor_tutor', default_response_class=ORJSONResponse)\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    app.include_router(api_router, prefix='/api')\n\n    return app\n(...)\n```\n\n**`uvicorn`** 의 `reload` 옵션을 켰기 때문에, 별다른 조작 없이 수정사항이 반영된 상태로 서버가 다시 실행된다. [http://localhost:8000/api/cleanings/](http://localhost:8000/api/cleanings/)에서 다음과 같은 결과를 확인할 수 있다.\n\n```yaml\n[\n  {\n    'id': 1,\n    'name': 'My house',\n    'cleaning_type': 'full_clean',\n    'price_per_hour': 29.99,\n  },\n  {\n    'id': 2,\n    'name': \"Someone else's house\",\n    'cleaning_type': 'spot_clean',\n    'price_per_hour': 19.99,\n  },\n]\n```\n\n다음 챕터에서는 sql 서버를 연결하고, **`pytest`** 를 이용하여 테스트를 진행한다.\n\n참고로, **`docker`** 로 실행된 서버는\n\n```bash\n❯ docker-compose down\n```\n\n으로 종료가 가능하다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -1- 초기 설정","data":{"title":"fastapi 튜토리얼 -1- 초기 설정","date":"2022-04-27T23:30:14.239+09:00","tags":["fastapi","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -2- sql 서버 연결","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `sql` 서버 연결을 위한 초기 설정\n\n### `docker-compose` 설정\n\nsql 서버는 **`postgres`** 를 사용하기로 한다. 따라서 필요한 파이썬 패키지를 추가로 설치하고, `docker-compose.yml` 파일을 수정한다.\n\n```bash\n❯ poetry add asyncpg sqlalchemy sqlmodel\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes\n```\n\n```yaml\n# docker-compose.yml\n# prettier-ignore\nversion: \"3.8\"\nservices:\n  server:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    volumes:\n      - ./backend/:/backend/\n    command: uvicorn app.api.server:app --reload --workers 2 --host 0.0.0.0 --port 8000\n    env_file:\n      - ./backend/.env\n    ports:\n      - 8000:8000\n    depends_on:\n      - db\n\n  db:\n    image: postgres:14-alpine\n    volumes:\n      - ./postgres_data:/var/lib/postgresql/data/\n    env_file:\n      - ./backend/.env\n    ports:\n      - 5432:5432\n```\n\n### `git` 구성\n\n이유는 모르겠지만, **jeffastor**는 이전 글부터가 아닌, 이번 글 부터 **`git`** 으로 관리를 시작한다..\n\n```bash\n❯ touch .gitignore\n```\n\n```yaml\n# .gitignore\n# Byte-compiled files\n__pycache__/\n# Environment files\n.env\n```\n\n```bash\n❯ git init\n❯ git add .\n❯ git commit -m \"Dockerized FastAPI app with postgres.\"\n```\n\n### 환경변수 설정\n\n**`postgres`** 및 서버 전반적으로 사용할 환경변수를 설정한다.\n\n```python\n# backend/.env\nSECRET_KEY=supersecret\n\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=postgres\nPOSTGRES_SERVER=db\nPOSTGRES_PORT=5432\nPOSTGRES_DB=postgres\n```\n\n`SECRET_KEY`의 경우, 지금은 기본값으로 사용하지만 나중에 수정할거니 걱정하지 않아도 된다고 한다..\n\n### `config.py` 설정\n\n이제 서버에서 사용할 설정 파일을 생성한다.\n\n```bash\n❯ touch backend/app/core/config.py\n```\n\n```python\n# backend/app/core/config.py\nfrom sqlalchemy.engine.url import URL\nfrom starlette.config import Config\nfrom starlette.datastructures import Secret\n\nconfig = Config(\".env\")\n\nPROJECT_NAME = \"jeffastor_tutor\"\nVERSION = \"1.0.0\"\nAPI_PREFIX = \"/api\"\n\nSECRET_KEY = config(\"SECRET_KEY\", cast=Secret, default=\"CHANGEME\")\n\nPOSTGRES_USER = config(\"POSTGRES_USER\", cast=str)\nPOSTGRES_PASSWORD = config(\"POSTGRES_PASSWORD\", cast=Secret)\nPOSTGRES_SERVER = config(\"POSTGRES_SERVER\", cast=str, default=\"db\")\nPOSTGRES_PORT = config(\"POSTGRES_PORT\", cast=int, default=5432)\nPOSTGRES_DB = config(\"POSTGRES_DB\", cast=str)\n\nDATABASE_URL = config(\n    \"DATABASE_URL\",\n    cast=str,\n    default=URL.create(\n        drivername=\"postgresql+asyncpg\",\n        username=POSTGRES_USER,\n        password=POSTGRES_PASSWORD,\n        host=POSTGRES_SERVER,\n        port=POSTGRES_PORT,\n        database=POSTGRES_DB,\n    ).render_as_string(hide_password=False),\n)\n```\n\n원 예제와 다르게, **`sqlmodel`** 을 사용할 예정이라 url을 다르게 설정했다.\n\n\u003e 설명에 따르면, 기본값이 없는 `config` 객체에 설정된 모든 값은 `.env`파일에서 값을 제공해야하고, 그렇지 않으면 에러가 발생한다고 한다.\n\n## `sql` 서버 연결 스크립트 작성\n\n이제 sql 서버와 연결하기 위한 모듈과 앱 시작/종료 이벤트와 관련한 작업 파일을 생성한다.\n\n```bash\n❯ mkdir backend/app/db\n❯ touch backend/app/db/__init__.py backend/app/db/tasks.py backend/app/db/engine.py  backend/app/core/tasks.py\n```\n\n### 엔진 설정\n\n```python\n# backend/app/db/engine.py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.pool import QueuePool\n\nfrom ..core.config import DATABASE_URL\n\nengine = create_async_engine(\n    DATABASE_URL, pool_size=10, poolclass=QueuePool, pool_pre_ping=True\n)\n```\n\n```python\n# backend/app/db/tasks.py\nimport logging\nfrom typing import cast\n\nfrom fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\nfrom .engine import engine\n\nlogger = logging.getLogger(__name__)\n\n\nasync def connect_to_db(app: FastAPI) -\u003e None:\n    try:\n        async with engine.connect():\n            logger.info(\n                f\"connected db: {engine.url.render_as_string(hide_password=True)}\"\n            )\n        app.state._db = engine\n    except Exception as e:\n        logger.warning(\"--- DB CONNECTION ERROR ---\")\n        logger.warning(e)\n        logger.warning(\"--- DB CONNECTION ERROR ---\")\n\n\nasync def close_db_connection(app: FastAPI) -\u003e None:\n    engine = cast(AsyncEngine, app.state._db)\n    try:\n        await engine.dispose()\n    except Exception as e:\n        logger.warning(\"--- DB DISCONNECT ERROR ---\")\n        logger.warning(e)\n        logger.warning(\"--- DB DISCONNECT ERROR ---\")\n```\n\n```python\n# backend/app/core/tasks.py\nfrom typing import Any, Callable, Coroutine\n\nfrom fastapi import FastAPI\n\nfrom ..db.tasks import close_db_connection, connect_to_db\n\n\ndef create_start_app_handler(app: FastAPI) -\u003e Callable[[], Coroutine[Any, Any, None]]:\n    async def start_app() -\u003e None:\n        await connect_to_db(app)\n\n    return start_app\n\n\ndef create_stop_app_handler(app: FastAPI) -\u003e Callable[[], Coroutine[Any, Any, None]]:\n    async def stop_app() -\u003e None:\n        await close_db_connection(app)\n\n    return stop_app\n```\n\n`AsyncEngine` 인스턴스를 생성하고, 이 인스턴스를 이용해서 앱을 시작할 때와 종료할 때 실행할 두가지 핸들러를 정의했다.\n\n\u003e 기존 글에서는 엔진을 직접 만들기 보다 **`databases`** 를 이용하는데, 일단 이전에 사용한 적 있는 **`sqlmodel`** 로 진행한다.\n\n이 핸들러는 sql 서버 연결이 정상적으로 이루어졌다면, 앱의 `state`에 `_db`라는 속성으로 `AsyncEngine` 인스턴스를 호출할 수 있게 한다.\n그리고 종료할 때, 이 인스턴스와 연결된 모든 세션을 종료한다.\n이제 이 핸들러를 적용한다.\n\n```python\n# backend/app/api/routes/server.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import ORJSONResponse\n\nfrom ..core import config, tasks\nfrom .routes import router as api_router\n\n\ndef get_application() -\u003e FastAPI:\n    app = FastAPI(\n        title=config.PROJECT_NAME,\n        version=config.VERSION,\n        default_response_class=ORJSONResponse,\n    )\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    app.add_event_handler(\"startup\", tasks.create_start_app_handler(app))\n    app.add_event_handler(\"shutdown\", tasks.create_stop_app_handler(app))\n\n    app.include_router(api_router, prefix=config.API_PREFIX)\n\n    return app\n\n\napp = get_application()\n```\n\n만약 **`docker`** 실행 시 정상적으로 작동한다면, sql 서버를 사용할 준비가 끝났다.\n\n### `alembic`을 사용한 마이그레이션\n\n이제 **`alembic`** 을 사용한 마이그레이션을 구성한다고 하는데.. 사용해본적이 한번도 없어서 생소한 라이브러리다. 그러니 일단 그대로 따라하는데 중점을 둔다.\n\n```bash\n❯ mkdir backend/app/db/migrations backend/app/db/repositories\n❯ touch backend/app/db/migrations/script.py.mako backend/app/db/migrations/env.py backend/app/db/repositories/__init__.py backend/app/db/repositories/base.py backend/alembic.ini\n```\n\n\u003e **`mako`** 확장자는 [Mako](https://www.makotemplates.org/) 템플릿이라고 한다.\n\n```yaml\n# backend/alembic.ini\n# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts\nscript_location = ./app/db/migrations\n\n# template used to generate migration files\n# file_template = %%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.\n# prepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the python-dateutil library that can be\n# installed by adding `alembic[tz]` to the pip requirements\n# string value is passed to dateutil.tz.gettz()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the\n# \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version location specification; This defaults\n# to test/versions.  When using multiple version\n# directories, initial revisions must be specified with --version-path.\n# The path separator used here should be the separator specified by \"version_path_separator\" below.\n# version_locations = %(here)s/bar:%(here)s/bat:test/versions\nversion_locations = ./app/db/migrations/versions\n\n# version path separator; As mentioned above, this is the character used to split\n# version_locations. The default within new alembic.ini files is \"os\", which uses os.pathsep.\n# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.\n# Valid values for version_path_separator are:\n#\n# version_path_separator = :\n# version_path_separator = ;\n# version_path_separator = space\n# version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\n# sqlalchemy.url = driver://user:pass@localhost/dbname\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the bash_scripts runner, against the \"black\" entrypoint\n# hooks = black\n# black.type = bash_scripts\n# black.entrypoint = black\n# black.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# Logging configuration\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = bash\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARN\nhandlers = bash\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARN\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_bash]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S\n```\n\n```python\n# backend/app/db/migrations/script.py.mako\n\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n${imports if imports else \"\"}\n\n# revision identifiers, used by Alembic.\nrevision = ${repr(up_revision)}\ndown_revision = ${repr(down_revision)}\nbranch_labels = ${repr(branch_labels)}\ndepends_on = ${repr(depends_on)}\n\n\ndef upgrade():\n    ${upgrades if upgrades else \"pass\"}\n\n\ndef downgrade():\n    ${downgrades if downgrades else \"pass\"}\n```\n\n각종 설정이 추가되는데, **`mako`** 템플릿 파일은 마이그레이션 스크립트를 생성하고, 그 과정을 로그로 남기는 것이라고 한다... 실제로 봐야 알 수 있을 듯.\n\n이제 끝으로 `env.py`를 작성해야하는데, 이제보니 첫 과정에서 **`alembic`** 를 추가하지 않았기에, 그 과정을 함께한다.\n\n```bash\n❯ poetry add alembic\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes\n```\n\n```python\n# backend/app/db/migrations/env.py\nimport asyncio\nimport logging\nimport pathlib\nimport sys\nfrom logging.config import fileConfig\nfrom typing import cast\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy.future.engine import Engine\n\nsys.path.append(str(pathlib.Path(__file__).resolve().parents[3]))\nfrom app.core.config import DATABASE_URL  # noqa\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\nlogger = logging.getLogger(\"alembic.env\")\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    # url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        # url=url,\n        url=DATABASE_URL,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection):\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    config.set_main_option(\"sqlalchemy.url\", DATABASE_URL)\n    connectable = AsyncEngine(\n        cast(\n            Engine,\n            engine_from_config(\n                config.get_section(config.config_ini_section),\n                prefix=\"sqlalchemy.\",\n                poolclass=pool.NullPool,\n                future=True,\n            ),\n        )\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\nif context.is_offline_mode():\n    logger.info(\"Running migrations offline\")\n    run_migrations_offline()\nelse:\n    logger.info(\"Running migrations online\")\n    asyncio.run(run_migrations_online())\n```\n\n이제 첫번째 마이그레이션을 **`docker`** 내부에서 실행하면 된다고 하는데...\n\n```bash\nroot@bad23fe368a6:/backend# ls\nDockerfile  alembic.ini  app  requirements.txt  tests\nroot@bad23fe368a6:/backend# alembic revision -m \"create account table\"\n  Generating\n  /backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n  ...  done\n```\n\n마이그레이션이 정상적으로 진행됐다!\n그리고 다음과 같은 파일을 확인할 수 있다.\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n\"\"\"create account table\n\nRevision ID: f721febf752b\nRevises:\nCreate Date: 2022-04-27 17:21:25.945460\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'f721febf752b'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    pass\n\n\ndef downgrade():\n    pass\n```\n\n### 마이그레이션 테스트 모델 생성 및 확인\n\n`env.py` 파일의\n\n```python\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None\n```\n\n주석에 적혀있듯이, `autogenerate` 옵션을 사용하면 자동으로 모델 기반으로 생성해준다고 한다. 다만 이 기능이 완벽하지는 않은지, 원 작성자 **jeffastor**는 마이그레이션으로 작성된 스크립트에\n\n```python\ndef create_cleanings_table() -\u003e None:\n    op.create_table(\n        \"cleanings\",\n        sa.Column(\"id\", sa.Integer, primary_key=True),\n        sa.Column(\"name\", sa.Text, nullable=False, index=True),\n        sa.Column(\"description\", sa.Text, nullable=True),\n        sa.Column(\"cleaning_type\", sa.Text, nullable=False, server_default=\"spot_clean\"),\n        sa.Column(\"price\", sa.Numeric(10, 2), nullable=False),\n    )\n```\n\n이라는 함수를 새로 작성해서 진행했다. **`sqlmodel`** 을 사용하는 만큼, 임시로 모델을 생성하고, 그 모델에서 자동으로 생성된 테이블에서 `Column`을 추출하는 방식으로 진행한다. 추후 모델을 정의할 파일 위치를 확인하면 옮기고 수정할 예정.\n\n```bash\n❯ mkdir backend/app/db/models\n❯ touch backend/app/db/models/base.py backend/app/db/models/temp.py\n```\n\n```python\n# touch backend/app/db/models/base.py\nclass base_model(SQLModel):\n    @classmethod\n    def get_table(cls) -\u003e Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n```\n\n```python\n# backend/app/db/models/temp.py\nfrom pydantic import condecimal\nfrom sqlmodel import Field\n\nfrom .base import base_model\n\n\nclass cleanings(base_model, table=True):\n    id: int | None = Field(None, primary_key=True)\n    name: str = Field(index=True)\n    description: str | None = None\n    cleaning_type: str = Field(\n        (_default_cleaning_type := \"spot_clean\"),\n        sa_column_kwargs={\"server_default\": _default_cleaning_type},\n    )\n    price: condecimal(max_digits=10, decimal_places=2)  # type: ignore\n```\n\n이 튜토리얼은 청소 관련 주제로 작성되기에, 테이블 이름이 `cleanings`이다.\n\n\u003e - `id`: 각 항목에 대한 고유한 식별값.\n\u003e - `name`: 해당 항목에 대한 이름. `index=True` 옵션으로 인해 더 빠른 조회가 가능하다.\n\u003e - `description`: 해당 항목에 대한 설명이지만, `null`값(파이썬에서는 `None`값)이 가능하다.\n\u003e - `cleaning_type`: 해당 항목의 타입\n\u003e - `price`: 해당 항목의 가격\n\n모델을 정의했으니, 이제 예제를 따라 함수를 정의한다.\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -\u003e None:\n    import sys\n    from pathlib import Path\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.db.models.temp import cleanings\n\n    table = cleanings.get_table()\n\n    op.create_table(\n        table.name,\n        *table.columns\n    )\n\ndef upgrade():\n    create_cleanings_table()\n\n\ndef downgrade():\n    op.drop_table('cleanings')\n```\n\n대부분의 경우 **`sqlmodel`** 의 `Field`의 변수로 가능하고, `server_default`에 대해서만 따로 `sa_column_kwargs`로 처리했다. 이렇게 하지 않아도 쿼리에 정상적으로 기본값이 적용되는 것으로 알고 있지만, 혹시 몰라서..\n\n이제 마이그레이션을 진행한다.\n\n```bash\nroot@9c425f594efa:/backend# alembic upgrade head\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -\u003e f721febf752b, create account table\n```\n\n테이블이 정상적으로 생성됐는지, `db` 컨테이너에서 **`psql`** 을 이용해 확인해본다.\n\n```bash\nbash-5.1# psql -h localhost -U postgres --dbname=postgres\npsql (14.2)\nType \"help\" for help.\n\npostgres=# select * from cleanings;\n id | name | description | cleaning_type | price\n----+------+-------------+---------------+-------\n(0 rows)\n```\n\n정상적으로 생성 된 것을 확인했다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -2- sql 서버 연결","data":{"title":"fastapi 튜토리얼 -2- sql 서버 연결","date":"2022-04-28T19:51:57.390+09:00","tags":["fastapi","alembic","postgres","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -3- sql 모델 정의","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## **cleanings** 모델 생성\n\n### 모델 정의\n\n작성 전 미리 전반적인 내용을 훑어보니, `repository`는 **`sqlmodel`** 사용시 딱히 의미가 없는 모듈이므로 제거하자.\n또한, 지난 글에서 임시로 생성한 `models`의 위치가 `db`의 하위 모듈이 아닌 `app`의 하위 모듈로 결정됐기에 같이 수정한다.\n\n```bash\n❯ rm -rf backend/app/db/repositories\n❯ mv backend/app/db/models backend/app/models\n❯ touch backend/app/models/__init__.py\n❯ mv backend/app/models/base.py backend/app/models/core.py\n❯ mv backend/app/models/temp.py backend/app/models/cleaning.py\n```\n\n```python\n# backend/app/models/core.py\nfrom typing import Any, TypeVar, cast\n\nfrom sqlmodel import Field, SQLModel, Table\n\n_T = TypeVar(\"_T\", bound=SQLModel)\n\n\nclass fix_parse_obj_model(SQLModel):\n    \"\"\"\n    sqlmodel에서 parse_obj 리턴값 정상적으로 수정하기 전까지 사용\n    \"\"\"\n    @classmethod\n    def parse_obj(cls: type[_T], obj: Any, update: dict[str, Any] | None = None) -\u003e _T:\n        return cast(_T, super().parse_obj(obj, update))\n\n\nclass base_model(fix_parse_obj_model):\n    @classmethod\n    def get_table(cls) -\u003e Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n\n\nclass id_model(fix_parse_obj_model):\n    id: int | None = Field(None, primary_key=True)\n```\n\n```python\n# backend/app/models/cleaning.py\nfrom enum import Enum\n\nfrom pydantic import condecimal\nfrom sqlmodel import Field\n\nfrom .core import base_model, id_model\n\nprice_decimal_type = condecimal(max_digits=10, decimal_places=2)\n\n\nclass cleaning_type_enum(str, Enum):\n    dust_up = \"dust_up\"\n    spot_clean = \"spot_clean\"\n    full_clean = \"full_clean\"\n\n\nclass cleaning_base(base_model):\n    name: str | None = None\n    description: str | None = None\n    cleaning_type: cleaning_type_enum = cleaning_type_enum.spot_clean\n    price: price_decimal_type | None = None\n\n\nclass cleaning_create(cleaning_base):\n    name: str\n    price: price_decimal_type\n\n\nclass cleaning_update(cleaning_base):\n    cleaning_type: cleaning_type_enum | None = None\n\n\nclass cleanings(id_model, cleaning_base, table=True):\n    name: str = Field(index=True)\n    cleaning_type: cleaning_type_enum = Field(\n        cleaning_type_enum.spot_clean,\n        sa_column_kwargs={\"server_default\": cleaning_type_enum.spot_clean},\n    )\n    price: price_decimal_type\n\n\nclass cleaning_public(id_model, cleaning_base):\n    ...\n```\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -\u003e None:\n    import sys\n    from pathlib import Path\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n\n(...)\n```\n\n`get_table` 메소드가 정의된 `base_model`을 상속하는 5개 모델은 각 리소스에 사용될 패턴을 보여준다.\n\n\u003e - `cleaning_base`: 공유 속성\n\u003e - `cleaning_create`: 새로운 리소스를 생성 ~ **POST**\n\u003e - `cleaning_update`: 기존 리소스를 수정 ~ **PUT**\n\u003e - `cleaning`: 데이터베이스에 정의될 테이블이자 레코드 ~ **GET**, **POST**, **PUT**,...\n\u003e - `cleaning_public`: 레코드에 대한 반환 형태 ~ **GET**, **POST**, **PUT**,...\n\n### `session` 모듈 정의\n\n원 작성자인 **jeffastor**는 이후 `repository` 모듈을 생성하여 CRUD 과정에 필요한 프로세스를 구현했지만, **`sqlmodel`** 을 사용하기에 그러한 과정이 따로 필요하지 않다.\n앱에서 사용할 `session`에 대해서만 따로 정의한다.\n\n```bash\n❯ touch backend/app/db/session.py\n```\n\n```python\n# backend/app/db/session.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n\nasync def get_database(request: Request) -\u003e AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -\u003e AsyncIterator[AsyncSession]:\n    async with AsyncSession(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n## `cleanings` 모델 `api` 예시\n\n### `cleanings` 레코드 추가 `POST` `api` 예시\n\n이제 세션을 활용한 간단한 형태의 **POST** api를 생성한다.\n\n```python\n# backend/app/api/routes/cleanings.py\nfrom fastapi import APIRouter, Body, Depends\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom starlette.status import HTTP_201_CREATED\n\nfrom ...db.session import get_session\nfrom ...models.cleaning import cleaning_create, cleaning_public, cleanings\n\nrouter = APIRouter()\n\n\n@router.get(\"/\")\nasync def get_all_cleanings() -\u003e list[dict]:\n    cleanings = [\n        {\n            \"id\": 1,\n            \"name\": \"My house\",\n            \"cleaning_type\": \"full_clean\",\n            \"price_per_hour\": 29.99,\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Someone else's house\",\n            \"cleaning_type\": \"spot_clean\",\n            \"price_per_hour\": 19.99,\n        },\n    ]\n    return cleanings\n\n\n@router.post(\n    \"/\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\nasync def create_new_cleaning(\n    new_cleaning: cleaning_create = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    # data = cleanings.from_orm(new_cleaning) 으로 해도 가능\n    # exclude_none=True, exclude_unset=True 옵션을 위해 parse_obj 사용\n    data = cleanings.parse_obj(\n        new_cleaning.dict(\n            exclude_none=True,\n            exclude_unset=True,\n        )\n    )\n    session.add(data)\n    await session.flush()\n    await session.commit()\n    await session.refresh(data)\n\n    return data\n```\n\n이제 **`docker`** 로 서비스를 실행하고, [http://localhost:8000/docs](http://localhost:8000/docs)에서 생성한 **POST** api가 정상적으로 작동하는지 확인한다.\n\n`body`에 값을\n\n```yaml\n{\n  'new_cleaning':\n    { 'name': 'string', 'description': 'string', 'cleaning_type': 'asd', 'price': 0 },\n}\n```\n\n이렇게 주면\n\n```yaml\n{\n  'detail':\n    [\n      {\n        'loc': ['body', 'new_cleaning', 'cleaning_type'],\n        'msg': \"value is not a valid enumeration member; permitted: 'dust_up', 'spot_clean', 'full_clean'\",\n        'type': 'type_error.enum',\n        'ctx': { 'enum_values': ['dust_up', 'spot_clean', 'full_clean'] },\n      },\n    ],\n}\n```\n\n이렇게 왜 에러(422)가 나는지 친절하게 설명도 해준다.\n정상적인 값을 넣으면\n\n```yaml\n{\n  'new_cleaning':\n    { 'name': 'test', 'description': 'test', 'cleaning_type': 'dust_up', 'price': 123 },\n}\n```\n\n설정한대로\n\n```yaml\n{\n  'name': 'test',\n  'description': 'test',\n  'cleaning_type': 'dust_up',\n  'price': 123,\n  'id': 1,\n}\n```\n\n`cleaning_public`의 스키마에 맞게 값을 반환(201)한다. 만약 `cleaning_public`가 `id_model`을 상속하도록 정의하지 않았다면 `id`속성은 생략된 채로 반환됐을 것이다.\n\n\u003e **`fastapi`** 가 위 **POST** api에서 실행한 과정\n\u003e\n\u003e 1. **`json`** 형태의 `body`를 읽는다.\n\u003e 2. `body`의 값을 검증한다. ~ **`pydantic`**\n\u003e 3. 검증 결과에 따라 에러를 반환하거나, 생성한 모델 객체로 계산한 결과를 반환한다.\n\n### `FastAPI`의 `DI` 사용법\n\n`Depends`로 변수를 처리하는 방식이 생소할 수 있다. 사용자의 요청을 처리하는 방식을 사전에 호출 가능한 형태로 정의하고, 그 과정을 한번에 실행한 결과를 파라미터로 받아서 사용할 수 있게 한다.\n\n직전에 생성한 `session.py`에서 `get_database`가 `request`를 받고,\n`get_session`이 `get_database`를 받고,\n`create_new_cleaning`이 `get_session`을 받아서 `session`객체를 파라미터로 사용할 수 있게 한다.\n\n마지막으로, sql 서버에서 정상적으로 레코드가 입력됐는지 확인해본다.\n\n```bash\nbash-5.1# psql -h localhost -U postgres --dbname=postgres\npsql (14.2)\nType \"help\" for help.\n\npostgres=# select * from cleanings;\n name | description | cleaning_type | price  | id\n------+-------------+---------------+--------+----\n test | test        | dust_up       | 123.00 |  1\n(1 row)\n```\n\n다음에는 **`pytest`** 를 활용한다.\n**`alembic`** 처럼 사용해본적이 없기에 기대가 된다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -3- sql 모델 정의","data":{"title":"fastapi 튜토리얼 -3- sql 모델 정의","date":"2022-04-28T21:51:36.869+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -4- pytest 적용 및 실행","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `pytest`를 사용한 테스트 코드 작성 및 실행\n\n테스트 코드를 작성하는게 도움이 된다 아니다로 많이 싸우지만, 적어도 **jeffastor** 자신은 이 과정 자체를 즐기고 있다고 밝히며, **`pytest`** 를 적용하는데 한 챕터를 할애한다.\n\n### 패키지 설치\n\n우선 테스트 코드 종속성 패키지부터 설치한다.\n\n```bash\n❯ poetry add --dev pytest pytest-asyncio httpx asgi-lifespan\n```\n\n\u003e **`pytest-asyncio`** 는 비동기로 작성된 api를 테스트하는데 사용하고, **asgi-lifespan`** 은 앱을 실행하지 않고 테스트하기 위해 사용한다.\n\n그리고 이제 **`pytest`** 가 **`docker`** 에서 실행될 수 있게, 개발용 종속성 패키지도 **`docker`** 이미지를 빌드과정에 추가한다.\n\n```bash\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ docker-compose build\n```\n\n### `pytest` 설정 파일 작성\n\n이제 기본적인 테스트 코드를 작성한다.\n\n```bash\n❯ touch backend/tests/__init__.py backend/tests/conftest.py backend/tests/test_cleanings.py\n```\n\n```python\n# backend/tests/conftest.py\nimport os\nimport warnings\nfrom typing import AsyncIterator\n\nimport alembic\nimport pytest\nfrom alembic.config import Config\nfrom asgi_lifespan import LifespanManager\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n\n# Apply migrations at beginning and end of testing session\n@pytest.fixture(scope=\"session\")\ndef apply_migrations():\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n    os.environ[\"TESTING\"] = \"1\"\n    config = Config(\"alembic.ini\")\n\n    alembic.command.upgrade(config, \"head\")  # type: ignore\n    yield\n    alembic.command.downgrade(config, \"base\")  # type: ignore\n\n\n# Create a new application for testing\n@pytest.fixture\ndef app(apply_migrations: None) -\u003e FastAPI:\n    from app.api.server import get_application\n\n    return get_application()\n\n\n# Grab a reference to our database when needed\n@pytest.fixture\ndef engine(app: FastAPI) -\u003e AsyncEngine:\n    return app.state._db\n\n\n@pytest.fixture\nasync def session(engine: AsyncEngine) -\u003e AsyncSession:\n    session = AsyncSession(engine, autoflush=False, autocommit=False)\n    try:\n        return session\n    finally:\n        await session.close()\n\n\n# Make requests in our tests\n@pytest.fixture\nasync def client(app: FastAPI) -\u003e AsyncIterator[AsyncClient]:\n    async with LifespanManager(app):\n        async with AsyncClient(\n            app=app,\n            base_url=\"http://testserver\",\n            headers={\"Content-Type\": \"application/json\"},\n        ) as client:\n            yield client\n\n```\n\n[원문](https://www.jeffastor.com/blog/testing-fastapi-endpoints-with-docker-and-pytest)에 설명이 꽤 있으니 읽어보면 좋을듯.\n\n### 테스트 데이터베이스 엔진 및 마이그레이션 설정\n\n추가로 테스트 환경에서 정상적으로 작동하도록, 기존에 작성한 모듈을 수정한다.\n\n```python\n# backend/app/db/engine.py\nfrom os import getenv\n\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\nfrom sqlalchemy.pool import QueuePool\n\nfrom ..core.config import DATABASE_URL\n\n\ndef is_test() -\u003e bool:\n    return (env_val := getenv(\"TESTING\", None)) is not None and bool(env_val)\n\n\ndef get_test_url(url: URL) -\u003e URL:\n    if url.database is None:\n        raise ValueError(\"database name is None\")\n\n    return url.set(database=f\"{url.database}_test\")\n\n\ndef get_test_engine(engine: AsyncEngine) -\u003e AsyncEngine:\n    if not is_test():\n        return engine\n    return create_engine_from_url(get_test_url(engine.url))\n\n\ndef create_engine_from_url(url: str | URL, **kwargs: Any) -\u003e AsyncEngine:\n    return create_async_engine(\n        url, pool_size=10, poolclass=QueuePool, pool_pre_ping=True, **kwargs\n    )\n\n\nengine = create_engine_from_url(DATABASE_URL)\n```\n\n```python\n# backend/app/db/tasks.py\n(...)\n\nfrom .engine import engine, get_test_engine\n\n(...)\n\nasync def connect_to_db(app: FastAPI) -\u003e None:\n    _engine = get_test_engine(engine)\n\n    try:\n        async with _engine.connect():\n            logger.info(\n                f\"connected db: {_engine.url.render_as_string(hide_password=True)}\"\n            )\n        app.state._db = _engine\n    except Exception as e:\n        logger.warning(\"--- DB CONNECTION ERROR ---\")\n        logger.warning(e)\n        logger.warning(\"--- DB CONNECTION ERROR ---\")\n\n(...)\n```\n\n```python\n# backend/app/db/migrations/env.py\nimport asyncio\nimport logging\nimport pathlib\nimport sys\nfrom logging.config import fileConfig\nfrom typing import cast\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlalchemy.exc import InvalidRequestError\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlalchemy.future.engine import Engine\n\nsys.path.append(str(pathlib.Path(__file__).resolve().parents[3]))\nfrom app.db.engine import engine, get_test_url, is_test\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\nlogger = logging.getLogger(\"alembic.env\")\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    if is_test():\n        raise InvalidRequestError(\n            \"Running testing migrations offline currently not permitted.\"\n        )\n\n    # url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        # url=url,\n        url=engine.url.render_as_string(hide_password=False),\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection):\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    url = engine.url\n    if is_test():\n        from sqlalchemy import text\n\n        url = get_test_url(url)\n        async with engine.connect() as conn:\n            conn = await conn.execution_options(isolation_level=\"AUTOCOMMIT\")\n            await conn.execute(text(f\"drop database if exists {url.database}\"))\n            await conn.execute(text(f\"create database {url.database}\"))\n\n    config.set_main_option(\"sqlalchemy.url\", url.render_as_string(hide_password=False))\n    connectable = AsyncEngine(\n        cast(\n            Engine,\n            engine_from_config(\n                config.get_section(config.config_ini_section),\n                prefix=\"sqlalchemy.\",\n                poolclass=pool.NullPool,\n                future=True,\n            ),\n        )\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\nif context.is_offline_mode():\n    logger.info(\"Running migrations offline\")\n    run_migrations_offline()\nelse:\n    logger.info(\"Running migrations online\")\n    asyncio.run(run_migrations_online())\n```\n\n이제 `TESTING`이라는 환경변수 값이 정상적으로 입력되어 있다면 테스트 DB를 사용한다. 또한, 마이그레이션시 테스트 DB가 이미 생성되어 있다면, 해당 DB를 지우고 새로 생성한다.\n\n### 테스트 코드 작성\n\n이제 이전에 작성한 라우터를 테스트 하는 테스트 코드를 작성한다.\n\n```python\n# backend/tests/test_cleanings.py\nimport pytest\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom starlette.status import HTTP_404_NOT_FOUND, HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCleaningsRoutes:\n    @pytest.mark.asyncio\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    @pytest.mark.asyncio\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_422_UNPROCESSABLE_ENTITY\n```\n\n이 테스트 코드는 우선 이전 챕터에서 작성한 `cleanings:create-cleaning` api가 존재하는지, 그리고 정상적으로 작동하는지 확인한다.\n\n이전에 어떻게 사용되는지 몰랐던 `conftest.py`에서 `pytest.fixture`로 데코레이트된 함수 `app`, `client`가 여기서 사용된다. `TestCleaningsRoutes`의 각 메소드의 파라미터와 이름이 일치하는 함수를 호출하여, 리턴값을 파라미터로 사용한다.\n\n`TestCleaningsRoutes.test_invalid_input_raises_error`에서 `json` 파라미터로 빈 딕셔너리를 제공했기에, 이전에 작성한 모델인 `cleaning_create`의 필수 값인 `name`과 `price`이 없어서 에러가 발생할 것으로 예상된다.\n\n이제 실제로 테스트를 실행해본다.\n\n```bash\nroot@3190a4d68f18:/backend# pytest -v\n==================================================== test session starts =====================================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 -- /usr/local/bin/python\ncachedir: .pytest_cache\nrootdir: /backend\nplugins: anyio-3.5.0, asyncio-0.18.3\nasyncio: mode=legacy\ncollected 2 items\n\ntests/test_cleanings.py::TestCleaningsRoutes::test_routes_exist PASSED                                                 [ 50%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error FAILED                                   [100%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error ERROR                                    [100%]\n\n=========================================================== ERRORS ===========================================================\n__________________________ ERROR at teardown of TestCleaningsRoutes.test_invalid_input_raises_error __________________________\n\n    @pytest.fixture(scope=\"session\")\n    def apply_migrations():\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n        os.environ[\"TESTING\"] = \"1\"\n        config = Config(\"alembic.ini\")\n\n        alembic.command.upgrade(config, \"head\")  # type: ignore\n        yield\n\u003e       alembic.command.downgrade(config, \"base\")  # type: ignore\n\ntests/conftest.py:24:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n(...)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n\u003e   ???\nE   RuntimeError: Task \u003cTask pending name='Task-20' coro=\u003crun_migrations_online() running at /backend/./app/db/migrations/env.py:88\u003e cb=[_run_until_complete_cb() at /usr/local/lib/python3.10/asyncio/base_events.py:184]\u003e got Future \u003cFuture pending cb=[Protocol._on_waiter_completed()]\u003e attached to a different loop\n\nasyncpg/protocol/protocol.pyx:338: RuntimeError\n-------------------------------------------------- Captured stderr teardown --------------------------------------------------\nINFO  [alembic.env] Running migrations online\n========================================================== FAILURES ==========================================================\n____________________________________ TestCleaningsRoutes.test_invalid_input_raises_error _____________________________________\n\nself = \u003ctests.test_cleanings.TestCleaningsRoutes object at 0x7fc9e092b610\u003e\napp = \u003cfastapi.applications.FastAPI object at 0x7fc9e0928eb0\u003e, client = \u003chttpx.AsyncClient object at 0x7fc9df873640\u003e\n\n    @pytest.mark.asyncio\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n\u003e       assert res.status_code != HTTP_422_UNPROCESSABLE_ENTITY\nE       assert 422 != 422\nE        +  where 422 = \u003cResponse [422 Unprocessable Entity]\u003e.status_code\n\ntests/test_cleanings.py:18: AssertionError\n====================================================== warnings summary ======================================================\n../usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:191\n  /usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:191: DeprecationWarning: The 'asyncio_mode' default value will change to 'strict' in future, please explicitly use 'asyncio_mode=strict' or 'asyncio_mode=auto' in pytest configuration file.\n    config.issue_config_time_warning(LEGACY_MODE, stacklevel=2)\n\n../usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:230\n  /usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:230: DeprecationWarning: '@pytest.fixture' is applied to \u003cfixture client, file=/backend/tests/conftest.py, line=42\u003e in 'legacy' mode, please replace it with '@pytest_asyncio.fixture' as a preparation for switching to 'strict' mode (or use 'auto' mode to seamlessly handle all these fixtures as asyncio-driven).\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n================================================== short test summary info ===================================================\nFAILED tests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error - assert 422 != 422\nERROR tests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error - RuntimeError: Task \u003cTask pending name...\n====================================== 1 failed, 1 passed, 2 warnings, 1 error in 0.44s ======================================\nsys:1: SAWarning: The garbage collector is trying to clean up connection \u003cAdaptedConnection \u003casyncpg.connection.Connection object at 0x7fc9e082a6c0\u003e\u003e. This feature is unsupported on async dbapi, since no IO can be performed at this stage to reset the connection. Please close out all connections when they are no longer used, calling ``close()`` or using a context manager to manage their lifetime.\n```\n\n예상했던 첫번째와 달리, 두번째 에러가 당황스럽다. 확인해보니 비동기 엔진을 **`pytest`** 에서 사용할 때, 이벤트 루프 때문에 런타임 에러가 발생했다. **`pytest`** 에 익숙하지 않기에, 해결할 방법 또한 당장 알아내기가 어렵다. 급한대로 **`alembic`** 사용시 동기 엔진을 사용하기로 했다.\n\n```bash\n❯ poetry add --dev psycopg2-binary\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ docker-compose build\n```\n\n```python\n# backend/app/db/engine.py\nfrom os import getenv\nfrom typing import Any, Literal, overload\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\nfrom sqlalchemy.future.engine import Engine\nfrom sqlalchemy.pool import QueuePool\n\nfrom ..core.config import DATABASE_URL\n\n\ndef is_test() -\u003e bool:\n    return (env_val := getenv(\"TESTING\", None)) is not None and bool(env_val)\n\n\ndef get_test_url(url: URL) -\u003e URL:\n    if url.database is None:\n        raise ValueError(\"database name is None\")\n\n    return url.set(database=f\"{url.database}_test\")\n\n\ndef get_engine_kwargs(**kwargs: Any) -\u003e dict[str, Any]:\n    return {\n        \"pool_size\": 10,\n        \"poolclass\": QueuePool,\n        \"pool_pre_ping\": True,\n        \"future\": True,\n    } | kwargs\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine) -\u003e AsyncEngine:\n    ...\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine, is_sync: Literal[True] = ...) -\u003e Engine:\n    ...\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine, is_sync: Literal[False] = ...) -\u003e AsyncEngine:\n    ...\n\n\n@overload\ndef get_test_engine(engine: AsyncEngine, is_sync: bool = ...) -\u003e AsyncEngine | Engine:\n    ...\n\n\ndef get_test_engine(engine: AsyncEngine, is_sync: bool = False) -\u003e AsyncEngine | Engine:\n    if is_test():\n        engine = create_engine_from_url(\n            get_test_url(engine.url), pool_pre_ping=pool_pre_ping\n        )\n\n    if is_sync:\n        return convert_async_to_sync(engine)\n    return engine\n\n\ndef convert_async_to_sync(engine: AsyncEngine, **kwargs: Any) -\u003e Engine:\n    return create_sync_engine_from_url(\n        engine.url.set(drivername=engine.url.drivername.split(\"+\")[0]), **kwargs\n    )\n\n\ndef create_sync_engine_from_url(url: str | URL, **kwargs: Any) -\u003e Engine:\n    return create_engine(url, **get_engine_kwargs(**kwargs))\n\n\ndef create_engine_from_url(url: str | URL, **kwargs: Any) -\u003e AsyncEngine:\n    return create_async_engine(url, **get_engine_kwargs(**kwargs))\n\n\nengine = create_engine_from_url(DATABASE_URL)\n```\n\n```python\n# backend/app/db/migrations/env.py\nimport logging\nimport pathlib\nimport sys\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlalchemy.exc import InvalidRequestError\n\nsys.path.append(str(pathlib.Path(__file__).resolve().parents[3]))\nfrom app.db.engine import engine, get_test_engine, is_test\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\nlogger = logging.getLogger(\"alembic.env\")\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = None\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    if is_test():\n        raise InvalidRequestError(\n            \"Running testing migrations offline currently not permitted.\"\n        )\n\n    # url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        # url=url,\n        url=engine.url.render_as_string(hide_password=False),\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection):\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    _engine = get_test_engine(engine, is_sync=True)\n    url = _engine.url\n\n    if is_test():\n        from sqlalchemy import text\n\n        with _engine.connect() as conn:\n            conn = conn.execution_options(isolation_level=\"AUTOCOMMIT\")\n            conn.execute(text(f\"drop database if exists {url.database}\"))\n            conn.execute(text(f\"create database {url.database}\"))\n\n    config.set_main_option(\"sqlalchemy.url\", url.render_as_string(hide_password=False))\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n        future=True,\n    )\n\n    with connectable.connect() as connection:\n        do_run_migrations(connection)\n\n    connectable.dispose()\n\n\nif context.is_offline_mode():\n    logger.info(\"Running migrations offline\")\n    run_migrations_offline()\nelse:\n    logger.info(\"Running migrations online\")\n    run_migrations_online()\n```\n\n이제 다시 **`pytest`** 를 실행해보면\n\n```bash\n(...)\n\n================================================== short test summary info ===================================================\nFAILED tests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error - assert 422 != 422\n================================================ 1 failed, 1 passed in 0.35s =================================================\n```\n\n정상적으로 2번째 메소드만 에러를 발생시킨다.\n이제 이전에 작성한 **POST** api에 대한 테스트 코드를 작성해보자.\n\n```python\n# backend/app/models/cleaning.py\n(...)\n\nclass cleaning_update(cleaning_base):\n    cleaning_type: cleaning_type_enum | None = None\n\n(...)\n```\n\n```python\n# backend/tests/test_cleanings.py\nimport orjson\nimport pytest\nfrom app.models.cleaning import cleaning_create\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n# decorate all tests with @pytest.mark.asyncio\npytestmark = pytest.mark.asyncio\n\n\n@pytest.fixture\ndef new_cleaning():\n    return cleaning_create.parse_obj(\n        dict(\n            name=\"test cleaning\",\n            description=\"test description\",\n            price=0.00,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n\n\nclass TestCleaningsRoutes:\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCreateCleaning:\n    async def test_valid_input_creates_cleaning(\n        self, app: FastAPI, client: AsyncClient, new_cleaning: cleaning_create\n    ) -\u003e None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": orjson.loads(new_cleaning.json())},\n        )\n        assert res.status_code == HTTP_201_CREATED\n\n        created_cleaning = cleaning_create(**res.json())\n        assert created_cleaning == new_cleaning\n\n    @pytest.mark.parametrize(\n        \"invalid_payload, status_code\",\n        (\n            (None, 422),\n            ({}, 422),\n            ({\"name\": \"test_name\"}, 422),\n            ({\"price\": 10.00}, 422),\n            ({\"name\": \"test_name\", \"description\": \"test\"}, 422),\n        ),\n    )\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient, invalid_payload: dict, status_code: int\n    ) -\u003e None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": invalid_payload},\n        )\n        assert res.status_code == status_code\n```\n\n`cleanings:create-cleaning` api가 의도한대로 데이터를 추가하고, 반환하는지 확인하는 코드가 추가됐다.\n\n또한, 에러를 발생하는 `body`의 형태와, 그러한 `body`에 대해 기대하는 `status_code`를 지정해서 확인한다.\n\n결과는 다음과 같이 정상적으로 나와야 한다.\n\n```bash\n==================================================== test session starts =====================================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 -- /usr/local/bin/python\ncachedir: .pytest_cache\nrootdir: /backend\nplugins: anyio-3.5.0, asyncio-0.18.3\nasyncio: mode=auto\ncollected 8 items\n\ntests/test_cleanings.py::TestCleaningsRoutes::test_routes_exist PASSED                                                 [ 12%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error PASSED                                   [ 25%]\ntests/test_cleanings.py::TestCreateCleaning::test_valid_input_creates_cleaning PASSED                                  [ 37%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[None-422] PASSED                          [ 50%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload1-422] PASSED              [ 62%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload2-422] PASSED              [ 75%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload3-422] PASSED              [ 87%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload4-422] PASSED              [100%]\n\n===================================================== 8 passed in 0.54s ======================================================\n```\n\n## TDD 방법론에 따른 개발 연습\n\n이제 **`pytest`** 를 사용하는 방식에 대해 어느정도 감이 잡히는 느낌이다.\n**jeffastor**는 이러한 테스트 코드를 이용해서, **TDD**(테스트 주도 개발)을 권장하는 것 같다.\n**TDD**는 다음의 3단계 프로세스를 따른다.\n\n\u003e 1. 실패를 확인할 수 있는 테스트 코드를 작성한다.\n\u003e 2. 테스트 코드를 통과할 수 있도록 코드를 작성한다.\n\u003e 3. 자신이 만족할 수준으로 코드를 수정, 테스트, 리팩토링, 모듈화 등을 실시한다.\n\n### `GET` `api` 생성\n\n위 프로세스를 따라서 **GET** api를 생성해보자.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nfrom app.models.cleaning import cleaning_create, cleanings\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n(...)\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(self, app: FastAPI, client: AsyncClient) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-cleaning-by-id\", id=\"1\"))\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings(**res.json())\n        assert cleaning.id == 1\n```\n\n작성한 테스트 코드의 `TestGetCleaning.test_get_cleaning_by_id` 메소드를 통과할 수 있도록, **GET** api를 작성해보자.\n\n```python\n# backend/app/api/routes/cleanings.py\nfrom fastapi import APIRouter, Body, Depends, HTTPException, Path\nfrom starlette.status import HTTP_201_CREATED, HTTP_404_NOT_FOUND\n\n(...)\n\n@router.get(\n    \"/{id}\", response_model=cleaning_public, name=\"cleanings:get-cleaning-by-id\"\n)\nasync def get_cleaning_by_id(\n    id: int = Path(..., ge=1),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n    return cleaning\n```\n\n확인해본 결과, 모두 잘 작동한다.\n하지만 테스트 코드에 문제가 있다. `id=1`로 하드코딩된 상태이기 때문. 따라서 하드코딩을 제거하기 위한 새로운 `fixture`를 생성할 필요가 있다.\n\n```python\n# backend/tests/test_cleanings.py\n\n(...)\n\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_cleaning(session: AsyncSession) -\u003e cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.from_orm(new_cleaning_create)\n    session.add(new_cleaning)\n    await session.commit()\n    await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        print(test_cleaning)\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.parse_obj(res.json())\n        assert cleaning == test_cleaning\n```\n\n`refresh` 메소드를 사용하여 정확한 id를 가지고 비교를 해서 에러가 없을거라 생각했는데,\n\n```bash\n================================================== short test summary info ===================================================\nERROR tests/test_cleanings.py::TestGetCleaning::test_get_cleaning_by_id - sqlalchemy.exc.OperationalError: (psycopg2.errors...\n================================================= 9 passed, 1 error in 5.74s =================================================\nsys:1: SAWarning: The garbage collector is trying to clean up connection \u003cAdaptedConnection \u003casyncpg.connection.Connection object at 0x7fabadaffbc0\u003e\u003e. This feature is unsupported on async dbapi, since no IO can be performed at this stage to reset the connection. Please close out all connections when they are no longer used, calling ``close()`` or using a context manager to manage their lifetime.\n```\n\n**`pytest`** 에서 `fixture`를 생성할 때 연결한 `session`을 제대로 정리하지 않아서 에러가 발생했다. **`pytest`** 에서는 `NullPool`을 사용하고, **`pytest`** 에서 `session` 객체를 `fixture`로 사용하지 않도록 하자.\n\n```python\nfrom sqlalchemy.pool import AsyncAdaptedQueuePool, NullPool, QueuePool\n\n(...)\n\ndef get_engine_kwargs(\n    is_sync: bool, is_test: bool = False, **kwargs: Any\n) -\u003e dict[str, Any]:\n    params: dict[str, Any] = {\"pool_pre_ping\": True, \"future\": True}\n\n    if is_test:\n        params[\"poolclass\"] = NullPool\n    else:\n        params[\"pool_size\"] = 10\n        params[\"poolclass\"] = QueuePool\n\n    return params | kwargs\n\n\n(...)\n\ndef get_test_engine(engine: AsyncEngine, is_sync: bool = False) -\u003e AsyncEngine | Engine:\n    if _is_test := is_test():\n        engine = create_engine_from_url(get_test_url(engine.url), is_test=_is_test)\n\n    if is_sync:\n        return convert_async_to_sync(engine, is_test=_is_test)\n    return engine\n\n(...)\n```\n\n```python\n# backend/tests/conftest.py\nimport os\nimport warnings\nfrom typing import AsyncIterator\n\nimport alembic\nimport pytest\nfrom alembic.config import Config\nfrom asgi_lifespan import LifespanManager\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\n\n# Apply migrations at beginning and end of testing session\n@pytest.fixture(scope=\"session\")\ndef apply_migrations():\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n    os.environ[\"TESTING\"] = \"1\"\n    config = Config(\"alembic.ini\")\n\n    alembic.command.upgrade(config, \"head\")  # type: ignore\n    yield\n    alembic.command.downgrade(config, \"base\")  # type: ignore\n\n\n# Create a new application for testing\n@pytest.fixture\ndef app(apply_migrations: None) -\u003e FastAPI:\n    from app.api.server import get_application\n\n    return get_application()\n\n\n# Grab a reference to our database when needed\n@pytest.fixture\ndef engine(app: FastAPI) -\u003e AsyncEngine:\n    return app.state._db\n\n\n# Make requests in our tests\n@pytest.fixture\nasync def client(app: FastAPI) -\u003e AsyncIterator[AsyncClient]:\n    async with LifespanManager(app):\n        async with AsyncClient(\n            app=app,\n            base_url=\"http://testserver\",\n            headers={\"Content-Type\": \"application/json\"},\n        ) as client:\n            yield client\n```\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -\u003e cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.from_orm(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n(...)\n```\n\n다시 **`pytest`** 를 실행했을 때, 정상적으로 잘 되는 것을 확인했다.\n\n### `GET` `api`에 유효하지 않은 값에 대한 테스트 코드\n\n이어서, 유효하지 않은 값에 대한 테스트 코드를 추가한다.\n원 예제는 `id=-1`에 대해 404 에러 코드를 반환하지만, 이전에 **GET** api를 정의할 때 `id: int = Path(..., ge=1)` 으로 정의했기에 422에러가 반환된다. 따라서 그 부분만 수정했다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        print(test_cleaning)\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.parse_obj(res.json())\n        assert cleaning == test_cleaning\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n```\n\n테스트시, 별 문제 없이 통과한다.\n\n```bash\nroot@5984264d864d:/backend# pytest -v --asyncio-mode=auto\n==================================================== test session starts =====================================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 -- /usr/local/bin/python\ncachedir: .pytest_cache\nrootdir: /backend\nplugins: anyio-3.5.0, asyncio-0.18.3\nasyncio: mode=auto\ncollected 12 items\n\ntests/test_cleanings.py::TestCleaningsRoutes::test_routes_exist PASSED                                                 [  8%]\ntests/test_cleanings.py::TestCleaningsRoutes::test_invalid_input_raises_error PASSED                                   [ 16%]\ntests/test_cleanings.py::TestCreateCleaning::test_valid_input_creates_cleaning PASSED                                  [ 25%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[None-422] PASSED                          [ 33%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload1-422] PASSED              [ 41%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload2-422] PASSED              [ 50%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload3-422] PASSED              [ 58%]\ntests/test_cleanings.py::TestCreateCleaning::test_invalid_input_raises_error[invalid_payload4-422] PASSED              [ 66%]\ntests/test_cleanings.py::TestGetCleaning::test_get_cleaning_by_id PASSED                                               [ 75%]\ntests/test_cleanings.py::TestGetCleaning::test_wrong_id_returns_error[500-404] PASSED                                  [ 83%]\ntests/test_cleanings.py::TestGetCleaning::test_wrong_id_returns_error[-1-422] PASSED                                   [ 91%]\ntests/test_cleanings.py::TestGetCleaning::test_wrong_id_returns_error[None-422] PASSED                                 [100%]\n\n===================================================== 12 passed in 0.86s =====================================================\n```\n\n다음 챕터는 CRUD api를 잘 생성하기 위한 작업으로 보인다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -4- pytest 적용 및 실행","data":{"title":"fastapi 튜토리얼 -4- pytest 적용 및 실행","date":"2022-04-30T02:43:31.082+09:00","tags":["fastapi","tdd","pytest","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n아래 문제로 인해 해당 챕터를 진행하면서 이전 챕터의 글을 포함해서 수정하다 보니 제대로 수정이 된건지 아닌지 확인하기가 어렵다..\n어쩌면 [이곳](https://github.com/phi-friday/jeffastor_tutor)에서 코드를 확인하는게 도움이 될 수 있다.\n\n특히 이 챕터의 테스트 코드에 적용된 `Decimal`이나 `f-string`도 원래는 **TDD** 과정 중에서 적용한 것이지만, 이미 글 쓰는 흐름이 다 꼬여서 생략했다.\n\n---\n\n## `SQLModel`의 **validataion** 관련 해결\n\n[링크](https://velog.io/@phi0friday/sqlmodel-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-validation)와 같은 이유로 인해, **`sqlmodel`** 로 생성한 모델에 대한 전반적인 수정이 필요하므로, 아래와 같이 수정을 진행했다.\n\n```python\n# backend/app/models/core.py\nfrom typing import Any, TypeVar, cast\n\nfrom sqlmodel import Field, SQLModel, Table\n\n_T = TypeVar(\"_T\", bound=SQLModel)\n\n\nclass fix_return_type_model(SQLModel):\n    \"\"\"\n    sqlmodel에서 parse_obj 리턴값 정상적으로 수정하기 전까지 사용\n    +\n    validate 또한 같은 문제 있음\n    \"\"\"\n\n    @classmethod\n    def parse_obj(cls: type[_T], obj: Any, update: dict[str, Any] | None = None) -\u003e _T:\n        return cast(_T, super().parse_obj(obj, update))\n\n    @classmethod\n    def validate(cls: type[_T], value: Any) -\u003e _T:\n        return cast(_T, super().validate(value))\n\n\nclass base_model(fix_return_type_model):\n    @classmethod\n    def get_table(cls) -\u003e Table:\n        if (table := getattr(cls, \"__table__\", None)) is None:\n            raise ValueError(\"not table\")\n        return table\n\n\nclass id_model(fix_return_type_model):\n    id: int | None = Field(None, primary_key=True)\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\nasync def create_new_cleaning(\n    new_cleaning: cleaning_create = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    # data = cleanings.from_orm(new_cleaning) 으로 해도 가능\n    # exclude_none=True, exclude_unset=True 옵션을 위해 parse_obj 사용\n    # sqlmodel table=True 관련 validation 문제로 인해 validate사용\n    data = cleanings.validate(\n        new_cleaning.dict(\n            exclude_none=True,\n            exclude_unset=True,\n        )\n    )\n    session.add(data)\n    await session.flush()\n    await session.commit()\n    await session.refresh(data)\n\n    return data\n```\n\n```python\n# backend/tests.py\n(...)\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -\u003e cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning == test_cleaning\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [cleanings.validate(l) for l in json]\n        assert test_cleaning in all_cleanings\n```\n\n---\n\n## `RESTful` `CRUD` `api` 생성\n\n**RESTful** 표준에 따라, 다음과 같이 엔드포인트를 생성하고자 한다.\n\n| 엔드포인트     | 메소드 | 설명                               |\n| :------------- | :----- | :--------------------------------- |\n| /cleaning      | POST   | 새로운 cleaning 레코드 생성        |\n| /cleaning/{id} | GET    | id에 해당하는 cleaning 레코드 호출 |\n| /cleaning      | GET    | 전체 cleaning 레코드 호출          |\n| /cleaning/{id} | PATCH  | id에 해당하는 cleaning 레코드 수정 |\n| /cleaning/{id} | PUT    | id에 해당하는 cleaning 레코드 교체 |\n| /cleaning/{id} | DELET  | id에 해당하는 cleaning 레코드 제거 |\n\n이전 챕터에서, 새로운 레코드를 생성하는 것과, 기존의 레코드를 `id`를 이용하여 호출하는, 두개의 엔드포인트를 생성했다. 다른 4가지 또한, **TDD** 방법론에 맞게 작성한다.\n\n\u003e 원 예제에서 **jeffastor**는 **PATCH** api를 작성하지 않고 **PUT** api만 작성했다. 그런데 작동 방식을 보면 **jeffastor**가 작성한 **PUT** api는 **PATCH** api처럼 작동한다. 이와 관련해 약간의 수정이 함께 진행된다.\n\n### `GET` `api`\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [cleanings.parse_obj(l) for l in json]\n        assert test_cleaning in all_cleanings\n        assert test_cleaning in all_cleanings\n```\n\n이제 **`pytest`** 를 **`docker`** 컨테이너 내부에서 실행하면, 다음과 같은 에러를 확인할 수 있다.\n\n```bash\n(...)\n\n================================================= FAILURES ==================================================\n_______________________ TestGetCleaning.test_get_all_cleanings_returns_valid_response _______________________\n\nself = \u003ctests.test_cleanings.TestGetCleaning object at 0x7feb2db9b370\u003e\napp = \u003cfastapi.applications.FastAPI object at 0x7feb2b01fd90\u003e\nclient = \u003chttpx.AsyncClient object at 0x7feb2b01e6e0\u003e\ntest_cleaning = cleanings(name='fake cleaning name', price=Decimal('9.99'), id=3, description='fake cleaning description', cleaning_type='spot_clean')\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n\u003e       res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n\ntests/test_cleanings.py:125:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = \u003cfastapi.routing.APIRouter object at 0x7feb2b01d180\u003e, name = 'cleanings:get-all-cleanings'\npath_params = {}, route = \u003cfastapi.routing.APIRoute object at 0x7feb2b045480\u003e\n\n    def url_path_for(self, name: str, **path_params: str) -\u003e URLPath:\n        for route in self.routes:\n            try:\n                return route.url_path_for(name, **path_params)\n            except NoMatchFound:\n                pass\n\u003e       raise NoMatchFound()\nE       starlette.routing.NoMatchFound\n\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: NoMatchFound\n\n(...)\n```\n\n\u003e 현재 설정으로는, `test_cleaning`을 사용할 때 마다 새로운 레코드를 생성하고 있다. 만약 `unique` 설정이 있다면 에러를 발생시킬 것이다. 이 문제는 이후 다룰 것이므로, 지금은 신경쓰지 않아도 된다고 **jeffastor**는 밝힌다.\n\n이제 테스트를 통과할 수 있도록, 라우터를 수정합니다. 정말 연습해보기 위해, 이후 내용은 제대로 읽지 않고 직접 코드를 작성해봤습니다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom typing import cast\nfrom sqlmodel import select\n\n(...)\n\n@router.get(\n    \"\", response_model=list[cleaning_public], name=\"cleanings:get-all-cleanings\"\n)\nasync def get_all_cleanings(\n    session: AsyncSession = Depends(get_session),\n) -\u003e list[cleanings]:\n    # 아직 sqlmodel의 async session은 type hint와 관련해서 제대로 지원하지 않습니다.\n    # 제대로 작성된게 맞는지 확인해보고 싶다면,\n    # session.sync_session에서 type hint 관련해서만 확인해보면 됩니다.\n    #\n    # sync_session = session.sync_session\n    # table = sync_session.exec(select(cleanings))\n    # rows = table.all()\n    table = await session.exec(select(cleanings))  # type: ignore\n    rows = cast(list[cleanings], table.all())\n    return rows\n\n@router.post(\n    \"\",\n    response_model=cleaning_public,\n    name=\"cleanings:create-cleaning\",\n    status_code=HTTP_201_CREATED,\n)\n\n(...)\n```\n\n테스트 결과 통과했습니다.\n\n\u003e 원 작성자 **jeffator**의 경우, **TDD**에 대해 익숙해지지 위해 처음에는 `None`을 반환하고, 그 다음에는 빈 리스트 `[]`를 반환하고, 그 다음에는 가짜 레코드 `[{ \"id\": 1, \"name\": \"fake cleaning\", \"price\": 0}]`를 반환하고, 끝으로 세션에 연결해서 레코드를 반환합니다.\n\n### `PUT` `api`...? `PATCH` `api`\n\n다음과 같이 테스트 코드를 추가합니다.\n\n```python\n# backend/tests/test_cleanings.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.put(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n첫번째는 **PUT** api가 의도한대로 작동하는지 확인하고, 두번째는 의도한대로 에러를 반환하는지 확인하는 메소드입니다.\n이제 위 테스트 코드를 통과할 수 있도록 **PUT** 메소드를 작성합니다.\n\n\u003e 다만 위 테스트 코드에서 이해가 되지 않는 부분이 있는데,\n\n```python\n# make sure that no other attributes' values have changed\nfor attr, value in updated_cleaning.dict().items():\n    if attr not in attrs_to_change:\n        assert getattr(test_cleaning, attr) == value\n```\n\n\u003e 이다. 이건 **PATCH** 아닌가? 일단 따라가본다.\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\nfrom pydantic import ValidationError\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    try:\n        cleanings.from_orm(update_cleaning)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n`update_cleaning`이 정상적인 `cleanings` 레코드를 생성할 수 있는지 확인하고, `id`에 해당하는 `cleanings` 레코드를 호출 한 다음, 해당 레코드의 값을 수정하고 커밋했다.\n\n테스트 실행결과 이상하다고 생각했던 부분이 맞았다.\n**`pytest`** 에 익숙하지 않아 처음에 알아보지 못한 문제인데,\n\n```python\nattrs_to_change = ['cleaning_type']\nvalues = ['full_clean']\n```\n\n다음과 같이 변수가 정의된다..\n따라서, 위 예제를 모두 **PUT**에서 **PATCH**로 변경 후 다시 진행한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(\n                    test_cleaning.id,\n                ),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.parse_obj(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 400),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=exc.json()\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n기존에 작성한 **PUT** api는 제거하지 않고 놔둔다. 마지막에 다시 사용할 것이다.\n\n테스트 결과 모두 정상적으로 통과했다.\n\n### `DELETE` `api`\n\n이어서 **DELETE** 테스트 코드와 api를 생성한다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -\u003e None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -\u003e None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.delete(\"/{id}/\", response_model=int, name=\"cleanings:delete-cleaning-by-id\")\nasync def delete_cleaning_by_id(\n    id: int = Path(..., ge=1, title=\"The ID of the cleaning to delete.\"),\n    session: AsyncSession = Depends(get_session),\n) -\u003e int:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    await session.delete(cleaning)\n    await session.flush()\n    await session.commit()\n\n    return id\n```\n\n테스트도 정상적으로 통과한다.\n\n```bash\ntests/test_cleanings.py::TestDeleteCleaning::test_can_delete_cleaning_successfully PASSED             [ 86%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[500-404] PASSED [ 90%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[0-422] PASSED [ 93%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[-1-422] PASSED [ 96%]\ntests/test_cleanings.py::TestDeleteCleaning::test_delete_cleaning_with_invalid_input_throws_error[None-422] PASSED [100%]\n```\n\n\u003e **DELETE**와 같은 api는 `status_code=204`와 함께 `contents`가 없는 `response`를 반환하는게 맞다고 한다. 현재는 적용하지 않는다.\n\n### `PUT` api\n\n원 예제는 여기서 끝이지만, 추가로 **PUT** api에 대해 직접 작성해본다.\n\n```python\n# backend/tests/test_cleanings.py\n(...)\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning)\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n나름 여러 과정을 거쳤는데, **`sqlmodel`** 관련 문제를 알아보다 보니 너무 꼬였다. 과정은 생략..\n\n다음은 마이그레이션 진행 후 유저 관련 설정을 추가하는 것 같다. 유저 관련해서는 **`fastapi-users`** 라는 좋은 라이브러리가 있으니, 원 예제와 같은 흐름이지만 **`fastapi-user`** 를 쓰는 쪽으로 진행할 예정.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","data":{"title":"fastapi 튜토리얼 -5- TDD 방법론으로 RESTful API 생성","date":"2022-05-02T20:47:43.741+09:00","tags":["crud","fastapi","restful","tdd","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `cleanings`, `users` 모델 생성 및 수정\n\n시작부터 마이그레이션을 진행하길래 어떤건가 했더니, 이전에 작성했던 `cleanings` 테이블에 시간 속성(생성, 수정)을 sql 서버에서 자동으로 처리하도록 하는 트리거를 생성하는 과정이 있었다. sql 서버에서 직접 처리하는게 가장 간단한 방법이라고 한다. 일단 무시.\n\n이것과는 별개로, 이전에 마이그레이션 관련 코드 작성시 문제가 있는 형태로 작성한 것 같아서, 관련해서 조금 수정한다.\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -\u003e None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\n이제 원 예제와 같이, 다운그레이드 후, 시간 속성부터 추가한 다음, 유저 관련 테이블을 설정하고 업그레이드를 실시한다. 원 예제와 순서를 맞춰가기 위해 약간 꼬인 느낌이 있는데, 지금 작성하는 유저 테이블은 **`fastapi-users`** 에서 작성하는 모델 형태를 따라간다.\n\n```bash\nroot@c62cf3d05043:/backend# alembic downgrade base\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running downgrade f721febf752b -\u003e , create account table\n```\n\n### 시간 속성 관련 코어 모델 추가\n\n```python\n# backend/app/models/core.py\nfrom datetime import datetime\n\n(...)\n\n_D = TypeVar(\"_D\", bound=\"datetime_model\")\n\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -\u003e _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def attrs(cls) -\u003e set[str]:\n        return set(cls.__fields__.keys())\n```\n\n### 시간 속성 추가로 인한 기존 모델 변경점 대응 수정\n\n\u003e 아래 내용은 단순히 시간 속성 추가로 인해 코드가 너무 나열돼있어서 접어놓고 싶지만 velog가 해당 기능을 지원하지 않는다.. velog에서 자동 생성된 목차를 선택해서 다음 항목으로 넘어갈 수 있다.\n\n```python\n# backend/app/models/cleaning.py\n(...)\n\nfrom .core import base_model, datetime_model, id_model\n\n(...)\n\nclass cleanings(id_model, datetime_model, cleaning_base, table=True):\n    name: str = Field(index=True)\n    cleaning_type: cleaning_type_enum = Field(\n        cleaning_type_enum.spot_clean,\n        sa_column_kwargs={\"server_default\": cleaning_type_enum.spot_clean},\n    )\n    price: price_decimal_type\n\n(...)\n```\n\n```python\n# backend/tests/test_cleaning.py\nfrom contextlib import suppress\nfrom decimal import Decimal, InvalidOperation\n\nimport orjson\nimport pytest\nfrom app.models.cleaning import cleaning_create, cleanings\nfrom app.models.core import datetime_model\nfrom fastapi import FastAPI\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n\n# decorate all tests with @pytest.mark.asyncio\npytestmark = pytest.mark.asyncio\n\n\n@pytest.fixture\ndef new_cleaning():\n    return cleaning_create.parse_obj(\n        dict(\n            name=\"test cleaning\",\n            description=\"test description\",\n            price=0.00,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n\n\nclass TestCleaningsRoutes:\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code != HTTP_404_NOT_FOUND\n\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient\n    ) -\u003e None:\n        res = await client.post(app.url_path_for(\"cleanings:create-cleaning\"), json={})\n        assert res.status_code == HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestCreateCleaning:\n    async def test_valid_input_creates_cleaning(\n        self, app: FastAPI, client: AsyncClient, new_cleaning: cleaning_create\n    ) -\u003e None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": orjson.loads(new_cleaning.json())},\n        )\n        assert res.status_code == HTTP_201_CREATED\n\n        created_cleaning = cleaning_create(**res.json())\n        assert created_cleaning == new_cleaning\n\n    @pytest.mark.parametrize(\n        \"invalid_payload, status_code\",\n        (\n            (None, 422),\n            ({}, 422),\n            ({\"name\": \"test_name\"}, 422),\n            ({\"price\": 10.00}, 422),\n            ({\"name\": \"test_name\", \"description\": \"test\"}, 422),\n        ),\n    )\n    async def test_invalid_input_raises_error(\n        self, app: FastAPI, client: AsyncClient, invalid_payload: dict, status_code: int\n    ) -\u003e None:\n        res = await client.post(\n            app.url_path_for(\"cleanings:create-cleaning\"),\n            json={\"new_cleaning\": invalid_payload},\n        )\n        assert res.status_code == status_code\n\n\n@pytest.fixture\nasync def test_cleaning(engine: AsyncEngine) -\u003e cleanings:\n    new_cleaning_create = cleaning_create.parse_obj(\n        dict(\n            name=\"fake cleaning name\",\n            description=\"fake cleaning description\",\n            price=9.99,\n            cleaning_type=\"spot_clean\",\n        )\n    )\n    new_cleaning = cleanings.validate(new_cleaning_create)\n    async with AsyncSession(engine, autocommit=False) as session:\n        session.add(new_cleaning)\n        await session.commit()\n        await session.refresh(new_cleaning)\n\n    return new_cleaning\n\n\nclass TestGetCleaning:\n    async def test_get_cleaning_by_id(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id))\n        )\n        assert res.status_code == HTTP_200_OK\n        cleaning = cleanings.validate(res.json())\n        assert cleaning.dict(exclude=datetime_model.attrs) == test_cleaning.dict(\n            exclude=datetime_model.attrs\n        )\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_wrong_id_returns_error(\n        self, app: FastAPI, client: AsyncClient, id: int, status_code: int\n    ) -\u003e None:\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(id))\n        )\n        assert res.status_code == status_code\n\n    async def test_get_all_cleanings_returns_valid_response(\n        self, app: FastAPI, client: AsyncClient, test_cleaning: cleanings\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"cleanings:get-all-cleanings\"))\n        assert res.status_code == HTTP_200_OK\n        assert isinstance((json := res.json()), list)\n        assert len(json) \u003e 0\n        all_cleanings = [\n            cleanings.validate(l).dict(exclude=datetime_model.attrs) for l in json\n        ]\n        assert test_cleaning.dict(exclude=datetime_model.attrs) in all_cleanings\n\n\nclass TestPatchCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            ([\"name\"], [\"new fake cleaning name\"]),\n            ([\"description\"], [\"new fake cleaning description\"]),\n            ([\"price\"], [3.14]),\n            ([\"cleaning_type\"], [\"full_clean\"]),\n            (\n                [\"name\", \"description\"],\n                [\n                    \"extra new fake cleaning name\",\n                    \"extra new fake cleaning description\",\n                ],\n            ),\n            ([\"price\", \"cleaning_type\"], [42.00, \"dust_up\"]),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        res = await client.patch(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-patch\",\n                id=str(test_cleaning.id),\n            ),\n            json=update_cleaning,\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert (\n            updated_cleaning.id == test_cleaning.id\n        )  # make sure it's the same cleaning\n        # make sure that any attribute we updated has changed to the correct value\n        for attr, value in zip(attrs_to_change, values):\n            attr_to_change = getattr(updated_cleaning, attr)\n            assert attr_to_change != getattr(test_cleaning, attr)\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert attr_to_change == value\n        # make sure that no other attributes' values have changed\n        for attr, value in updated_cleaning.dict().items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert getattr(test_cleaning, attr) == value\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\"}, 422),\n            (500, {\"name\": \"test3\"}, 404),\n            (1, None, 422),\n            (1, {\"cleaning_type\": \"invalid cleaning type\"}, 422),\n            (1, {\"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-patch\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n\n\nclass TestDeleteCleaning:\n    async def test_can_delete_cleaning_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n    ) -\u003e None:\n        # delete the cleaning\n        res = await client.delete(\n            app.url_path_for(\n                \"cleanings:delete-cleaning-by-id\", id=str(test_cleaning.id)\n            ),\n        )\n        assert res.status_code == HTTP_200_OK\n        # ensure that the cleaning no longer exists\n        res = await client.get(\n            app.url_path_for(\"cleanings:get-cleaning-by-id\", id=str(test_cleaning.id)),\n        )\n        assert res.status_code == HTTP_404_NOT_FOUND\n\n    @pytest.mark.parametrize(\n        \"id, status_code\",\n        (\n            (500, 404),\n            (0, 422),\n            (-1, 422),\n            (None, 422),\n        ),\n    )\n    async def test_delete_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        id: int,\n        status_code: int,\n    ) -\u003e None:\n        res = await client.delete(\n            app.url_path_for(\"cleanings:delete-cleaning-by-id\", id=str(id)),\n        )\n        assert res.status_code == status_code\n\n\nclass TestPutCleaning:\n    @pytest.mark.parametrize(\n        \"attrs_to_change, values\",\n        (\n            (\n                [\"name\", \"description\", \"price\"],\n                [\n                    \"new fake cleaning name\",\n                    \"new fake cleaning description\",\n                    \"123.1\",\n                ],\n            ),\n            (\n                [\"name\", \"price\", \"cleaning_type\"],\n                [\"extra new fake cleaning name\", 15555.51, \"dust_up\"],\n            ),\n            (\n                [\"name\", \"price\"],\n                [\"extra new fake cleaning name\", Decimal(\"2.12\")],\n            ),\n        ),\n    )\n    async def test_update_cleaning_with_valid_input(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_cleaning: cleanings,\n        attrs_to_change: list[str],\n        values: list[str | int | float],\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": dict(zip(attrs_to_change, values))}\n\n        print(orjson.loads(orjson.dumps(update_cleaning, default=str)))\n        res = await client.put(\n            app.url_path_for(\n                \"cleanings:update-cleaning-by-id-as-put\",\n                id=str(test_cleaning.id),\n            ),\n            json=orjson.loads(orjson.dumps(update_cleaning, default=str)),\n        )\n        assert res.status_code == HTTP_200_OK\n        updated_cleaning = cleanings.validate(res.json())\n        assert updated_cleaning.id == test_cleaning.id\n\n        for attr, value in update_cleaning[\"update_cleaning\"].items():\n            if attr == \"price\":\n                with suppress(InvalidOperation, ValueError):\n                    value = Decimal(f\"{float(value):.2f}\")\n            assert value == getattr(updated_cleaning, attr)\n\n        for attr, value in updated_cleaning.dict(exclude={\"id\"}).items():\n            if attr not in attrs_to_change and attr not in datetime_model.attrs:\n                assert value == cleanings.__fields__[attr].default\n\n    @pytest.mark.parametrize(\n        \"id, payload, status_code\",\n        (\n            (-1, {\"name\": \"test\"}, 422),\n            (0, {\"name\": \"test2\", \"price\": 123}, 422),\n            (500, {\"name\": \"test3\", \"price\": 33.3}, 404),\n            (1, None, 422),\n            (\n                1,\n                {\n                    \"name\": \"test5\",\n                    \"price\": \"123.3\",\n                    \"cleaning_type\": \"invalid cleaning type\",\n                },\n                422,\n            ),\n            (1, {\"name\": \"test6\", \"price\": 123.3, \"cleaning_type\": None}, 422),\n        ),\n    )\n    async def test_update_cleaning_with_invalid_input_throws_error(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        id: int,\n        payload: dict,\n        status_code: int,\n    ) -\u003e None:\n        update_cleaning = {\"update_cleaning\": payload}\n        res = await client.patch(\n            app.url_path_for(\"cleanings:update-cleaning-by-id-as-put\", id=str(id)),\n            json=update_cleaning,\n        )\n        assert res.status_code == status_code\n```\n\n```python\n# backend/app/api/routes/cleanings.py\n(...)\n\n@router.patch(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-patch\",\n)\nasync def update_cleaning_by_id_as_patch(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    # validate 관련 문제 해결 전까지는 이렇게..\n    update_dict = update_cleaning.dict(exclude_unset=True)\n    try:\n        cleanings.validate(cleaning.dict() | update_dict)\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in update_dict.items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n\n@router.put(\n    \"/{id}\",\n    response_model=cleaning_public,\n    name=\"cleanings:update-cleaning-by-id-as-put\",\n)\nasync def update_cleaning_by_id_as_put(\n    id: int = Path(..., ge=1),\n    update_cleaning: cleaning_update = Body(..., embed=True),\n    session: AsyncSession = Depends(get_session),\n) -\u003e cleanings:\n    if (cleaning := await session.get(cleanings, id)) is None:\n        raise HTTPException(\n            status_code=HTTP_404_NOT_FOUND, detail=\"No cleaning found with that id.\"\n        )\n\n    try:\n        new_cleaning = cleanings.validate(update_cleaning.dict(exclude_unset=True))\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=orjson.loads(exc.json())\n        )\n\n    for attr, value in new_cleaning.dict(exclude={\"id\"}).items():\n        setattr(cleaning, attr, value)\n\n    session.add(cleaning.update())\n    await session.flush()\n    await session.commit()\n    await session.refresh(cleaning)\n\n    return cleaning\n```\n\n```python\n# backend/app/db/migration/versions/f721febf752b_create_account_table.py\n(...)\n\ndef create_cleanings_table() -\u003e None:\n    import sys\n    from pathlib import Path\n\n    sys.path.append(Path(__file__).resolve().parents[4].as_posix())\n    from app.models.cleaning import cleanings\n    from app.models.core import datetime_model\n\n    table = cleanings.get_table()\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        table.name, *[col for col in table.columns if col.name in col_names]\n    )\n\n(...)\n```\n\n이렇게 수정하면 추가, 수정 시간 속성을 문제없이 사용할 수 있다..\n큰 문제가 없다면 그냥 트리거를 이용하자.\n\n### `users` 모델 생성\n\n```bash\n❯ poetry add 'fastapi-users[sqlalchemy2]'\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ touch backend/app/models/user.py\n❯ docker-compose up --build\n```\n\n원 예제에서 **`JWT`** 를 사용하기에 따라간다.\n\n```python\n# backend/app/models/user.py\nfrom uuid import uuid4\n\nfrom fastapi_users import models\nfrom pydantic import UUID4, EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field\n\nfrom .core import base_model, datetime_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\nclass user_base(models.BaseUser, datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(models.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(models.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_read(user_base):\n    ...\n\n\nclass user(user_base, models.BaseUserDB):\n    ...\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n위 스크립트에서 정의한 모델은, **`pydantic`** 의 `BaseModel`을 상속받는, **`fastapi-users`** 에서 정의된 모델을 상속받아서 정의한다. 기본적으로 가지고 있는 속성은 다음과 같다.\n\n\u003e `id` : `UUID`로 임의 생성\n\u003e `email`: `xxx@yyy.zz`의 형태로 구성된 문자열\n\u003e `is_active`: 해당 유저 레코드가 활성화된 상태인지 확인\n\u003e `is_superuser`: 해당 유저가 관리자인지 확인\n\u003e `is_verified`: 선택적으로 사용 가능한, 해당 유저에 대한 추가적인 검증 통과 여부를 확인. 흔히 이메일로 검증을 진행함.\n\u003e `password`: 해당 유저가 로그인시 사용하는 비밀번호로, 실제 데이터베이스에는 `hashed_password` 속성으로 암호화 후 저장된다.\n\n추가적으로 필요한 속성이 있다던가, 제약사항이 있다면 위 스크립트와 같이 모델에 새로 정의를 해도 좋고, 이후 정의할 `UserManager` 클래스의 `on_after_register` 등의 메소드에 제약사항을 적용해도 된다.\n\n그리고 추가된 모델을 마이그레이션 설정에 추가한다.\n\n```python\n# backend/app/db/migrations/versions/f721febf752b_create_account_table.py\n\"\"\"create account table\n\nRevision ID: f721febf752b\nRevises:\nCreate Date: 2022-04-27 17:21:25.945460\n\n\"\"\"\nimport sys\nfrom pathlib import Path\n\nimport sqlalchemy as sa\nfrom alembic import op\n\nsys.path.append(Path(__file__).resolve().parents[4].as_posix())\nfrom app.models.cleaning import cleanings\nfrom app.models.core import datetime_model\nfrom app.models.user import user_model\n\n# revision identifiers, used by Alembic.\nrevision = \"f721febf752b\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ncleanings_table = cleanings.get_table()\nusers_table = user_model.get_table()\n\n\ndef create_cleanings_table() -\u003e None:\n    col_names = {\"id\", \"name\", \"description\", \"cleaning_type\", \"price\"}.union(\n        datetime_model.attrs\n    )\n\n    op.create_table(\n        cleanings_table.name,\n        *[col for col in cleanings_table.columns if col.name in col_names]\n    )\n\n\ndef create_user_table() -\u003e None:\n    col_names = {\n        \"id\",\n        \"name\",\n        \"hashed_password\",\n        \"email\",\n        \"is_active\",\n        \"is_superuser\",\n        \"is_verified\",\n    }.union(datetime_model.attrs)\n\n    op.create_table(\n        users_table.name, *[col for col in users_table.columns if col.name in col_names]\n    )\n\n\ndef upgrade():\n    create_cleanings_table()\n    create_user_table()\n\n\ndef downgrade():\n    op.drop_table(cleanings_table.name)\n    op.drop_table(users_table.name)\n```\n\n이제 드디어 마이그레이션을 할 준비가 끝났다.\n\n```bash\nroot@77f86a971288:/backend# alembic upgrade head\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -\u003e f721febf752b, create account table\n```\n\n## `FastAPI-Users`\n\n원 예제에서는 이제 테스트 코드를 작성한다. 하지만 `fastapi-users`를 사용하기 위해서, 사전 작업이 몇가지 필요한데, 지금 진행하는 작업이 다음 챕터나 그 다음 챕터에 나오는 내용과 비슷할 수 있다..\n\n### 간단한 설명\n\n**`fastapi-users`** 의 설명에 따르면, **`fastapi-users`** 는 `Transport`와 `Strategy` 이 두가지를 조합해서 사용하는 방식이다. 지금 이 예제는 **`Bearer`** 와 **`JWT`** 를 조합해서 쓰는 방식이라고 생각할 수 있다.\n\n\u003e - **`Bearer`** : `header`에 토큰을 저장\n\u003e - **`JWT`** : `JSON`형태의 토큰을 암호화 하여 저장(토큰 발행 이후 서버에서 무효화 불가능). 자세한 설명은 [여기](https://jwt.io/introduction)에서 확인할 수 있다.\n\n### 인증 백엔드 설정\n\n인증과 관련한 모듈을 저장할 경로를 생성하고 백엔드부터 앞에서 간략하게 설명한 인증 백엔드부터 생성한다.\n\n```bash\n❯ mkdir backend/app/services\n❯ touch backend/app/services/__init__.py backend/app/services/authentication.py\n```\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ..core.config import SECRET_KEY\nfrom ..db.session import get_session\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n\n\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user, session, user_model)  # type: ignore\n\n\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n\n\ndef create_strategy() -\u003e Strategy:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n\n\ndef create_backend() -\u003e list[AuthenticationBackend]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n\n\nclass UserManager(BaseUserManager[user_create, user]):\n    user_db_model = user\n    reset_password_token_secret = str(SECRET_KEY)\n    verification_token_secret = str(SECRET_KEY)\n\n    async def on_after_register(self, user: user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(user_db=Depends(get_user_db)):\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(*backends: AuthenticationBackend) -\u003e FastAPIUsers:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user_base,\n        user_create_model=user_create,\n        user_update_model=user_update,\n        user_db_model=user,\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n\n```\n\n뭔가 많이 적었지만 실제로 직접 작성했다고 할만한건 데이터클래스 **`fastapi_user`** 정도 밖에 없다. 전부 **`fastapi-users`** 레퍼런스에 있는 내용이다.\n\n`UserManager` 와 `AuthenticationBackend` 인스턴스는 이후 계정과 관련된 작업을 할때 자주 사용된다.\n\n### 토큰 `api` 생성\n\n이제 토큰을 생성하는 api를 생성한다. 이 api의 엔드포인트는 `Transport`를 생성할 때 사용한 `tokenUrl`의 값과 일치해야한다.\n\n```python\n# backend/app/api/routes/token.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi_users import models\nfrom fastapi_users.authentication import Strategy\nfrom fastapi_users.manager import BaseUserManager\nfrom fastapi_users.router import ErrorCode\nfrom starlette.status import HTTP_400_BAD_REQUEST\n\nfrom .authentication import fastapi_user as fastapi_user_class\nfrom .authentication import get_user_manager\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -\u003e dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n### 인증 백엔드 확인용 임시 `api` 생성\n\n이어서 인증 백엔드 설정이 잘 됐는지 확인해볼 임시 라우터를 생성한다. 실제로 사용할 생각은 아니고, 말 그대로 임시 확인용이다.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter\n\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\nrouter.include_router(\n    fastapi_user.users.get_auth_router(fastapi_user.backends[0]), prefix=\"/auth\"\n)\nrouter.include_router(fastapi_user.users.get_register_router(), prefix=\"/auth\")\nrouter.include_router(fastapi_user.users.get_verify_router(), prefix=\"/auth\")\n```\n\n```python\n# backend/api/routes/__init__.py\nfrom fastapi import APIRouter\n\nfrom .cleanings import router as cleanings_router\nfrom .token import router as token_router\nfrom .users import router as users_router\n\nrouter = APIRouter()\n\nrouter.include_router(cleanings_router, prefix=\"/cleanings\", tags=[\"cleanings\"])\nrouter.include_router(users_router, prefix=\"/users\", tags=[\"users\"])\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n이제 [http://localhost:8000/docs](http://localhost:8000/docs)에서 확인해보면 **`fastapi-users`** 에서 설정한 내용을 바탕으로 생성해놓은 유저 관련 api를 사용할 수 있다. 또한, 로그인시 생성되는 토큰을 헤더에 추가하면 **`swagger`** 에서 로그인을 시도해볼 수 있다.\n\n다음은 이번에 작성한 내용을 좀 더 다듬고, 이전까지 했던 방식으로 **TDD** 방법론에 따라 api를 생성할 생각이다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","data":{"title":"fastapi 튜토리얼 -6- FastAPI Users를 사용한 유저 api 생성","date":"2022-05-03T01:35:06.494+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## 시작하기 전 변경사항\n\n이전 챕터에서 밝힌 것 처럼, 다소 난잡하다고 생각되는 부분 몇가지를 수정하자. 지금 수정한 부분이 나중에 원 예제에서 다른 방향으로 수정될 수도 있지만, 그때 가서 생각하자.\n\n\u003e ### backend/app/core/config.py\n\u003e\n\u003e $\\rightarrow$ 1개 설정 변수 생성\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token\"\n```\n\n\u003e ### backend/app/db/engine.py\n\n```python\nfrom ..core.config import DATABASE_URL\n```\n\n$\\rightarrow$ `core.config` 에서 값을 불러오는 방식으로\n\n```python\nfrom ..core import config\n```\n\n\u003e ### backend/app/models/user.py\n\n```python\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\u003e\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(sa_column_kwargs={\"unique\": True})\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n$\\rightarrow$ `unique=True`대신 `index=True`로 변경\n\n```python경\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\u003e\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n```\n\n\u003e ### backend/app/services/authentication.py\n\n```python\nfrom ..core.config import SECRET_KEY\n```\n\n$\\rightarrow$ `core.config` 에서 값을 불러오는 방식으로\n\n```python\nfrom ..core import config\n```\n\n---\n\n```python\nfrom ..models.user import user, user_base, user_create, user_model, user_update\n```\n\n$\\rightarrow$ `models.user` 에서 모델을 불러오는 방식으로\n\n```python\nfrom ..models import user\n```\n\n---\n\n```python\nfrom pydantic import BaseModel\n\u003e\n(...)\n\u003e\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n\u003e\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n\u003e\n    @classmethod\n    def from_token(cls, token: str) -\u003e \"token_model\":\n        return cls(access_token=token)\n```\n\n$\\rightarrow$ 새로 정의\n\n---\n\n```python\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=\"api/auth/token\")\n```\n\n$\\rightarrow$ `config.TOKEN_PREFIX` 설정 변수 참조\n\n```python\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n```\n\n---\n\n```python\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\u003e\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+\u003c\u003e@\\#$%\u0026\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\u003e\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -\u003e None:\n        if len(password) \u003c self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) \u003e self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\u003e\n        for pattern in self.re_password_deny_list:\n            if pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\u003e\n        for pattern in self.re_password_need_list:\n            if not pattern.match(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n```\n\n$\\rightarrow$ 비밀번호 유효성 검사 로직 추가\n\n---\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user:\n    users: FastAPIUsers\n    backends: list[AuthenticationBackend]\n\u003e\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user\":\n        backends = create_backend()\n        users = create_fastapi_users(*backends)\n        return cls(users=users, backends=backends)\n```\n\n$\\rightarrow$ 원래는 삭제하려 했으나, 특정 기능 추가 후 사용. 의존성이 마음에 들지 않지만, 사실상 설정용 객체라 일단 무시.\n\n```python\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n\u003e\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\u003e\n    @property\n    def backends(self) -\u003e Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n\u003e\n    @property\n    def user_manager_depends(self) -\u003e user_manager_type:\n        return Depends(self.users.get_user_manager)\n\u003e\n    def strategy_depends(self, num: int = 0, /) -\u003e strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n---\n\n끝으로, **`fastapi-users`** 의 각 클래스가 제네릭인 것을 확인해서, 이전에 정의한 유저 모델을 이용해서 타입 힌트를 추가했다. 이하 스크립트 전문\n\n```python\n# backend/app/services/authentication.py\nfrom dataclasses import dataclass\nfrom typing import AsyncGenerator, Sequence\n\u003e\nfrom fastapi import Depends, Request\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import (\n    AuthenticationBackend,\n    BearerTransport,\n    JWTStrategy,\n    Strategy,\n    Transport,\n)\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom pydantic import BaseModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\u003e\nfrom ..core import config\nfrom ..db.session import get_session\nfrom ..models import user\n\u003e\nuser_manager_type = BaseUserManager[user.user_create, user.user]\nstrategy_type = Strategy[user.user_create, user.user]\n\u003e\n\u003e\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n\u003e\n    @classmethod\n    def from_token(cls, token: str) -\u003e \"token_model\":\n        return cls(access_token=token)\n\u003e\n\u003e\nasync def get_user_db(session: AsyncSession = Depends(get_session)):\n    yield SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n\u003e\n\u003e\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\u003e\n\u003e\ndef create_strategy() -\u003e Strategy[user.user_create, user.user]:\n    return JWTStrategy(secret=str(config.SECRET_KEY), lifetime_seconds=3600)\n\u003e\n\u003e\ndef create_backend() -\u003e list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=\"bearer_jwt\", transport=transport, get_strategy=create_strategy\n        )\n    ]\n\u003e\n\u003e\nclass UserManager(BaseUserManager[user.user_create, user.user]):\n    user_db_model = user.user\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\u003e\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\u003e\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\u003e\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\u003e\n\u003e\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -\u003e AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\u003e\n\u003e\ndef create_fastapi_users(\n    *backends: AuthenticationBackend[user.user_create, user.user],\n) -\u003e FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]:\n    return FastAPIUsers(\n        get_user_manager=get_user_manager,\n        auth_backends=backends,\n        user_model=user.user_base,\n        user_create_model=user.user_create,\n        user_update_model=user.user_update,\n        user_db_model=user.user,\n    )\n\u003e\n\u003e\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: FastAPIUsers[user.user_base, user.user_create, user.user_update, user.user]\n\u003e\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\u003e\n    @property\n    def backends(self) -\u003e Sequence[AuthenticationBackend[user.user_create, user.user]]:\n        return self.users.authenticator.backends\n\u003e\n    @property\n    def user_manager_depends(self) -\u003e user_manager_type:\n        return Depends(self.users.get_user_manager)\n\u003e\n    def strategy_depends(self, num: int = 0, /) -\u003e strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n\u003e ### backend/app/services/token.py\n\n#### 위치 변경\n\n`backend/app/services/token.py`\n$\\rightarrow$ `backend/app/api/routes/token.py`\n\n---\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ 클래스 이름 변경에 따른 수정\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import HTTP_400_BAD_REQUEST\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```pyhon\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom fastapi_users import models\n\u003e\n@router.post(\"/token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: BaseUserManager[models.UC, models.UD] = Depends(get_user_manager),\n    strategy: Strategy[models.UC, models.UD] = Depends(\n        fastapi_user.backends[0].get_strategy\n    ),\n) -\u003e dict[str, str]:\n    user = await user_manager.authenticate(credentials)\n    if user is None or not user.is_active:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not user.is_verified:\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\u003e\n    token = await strategy.write_token(user)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n```\n\n$\\rightarrow$ 최상위 엔드포인트 사용 + `user_manager_type`, `strategy_type`, `token_model` 사용\n\n```python\nfrom ...services.authentication import strategy_type, token_model, user_manager_type\n\u003e\n(...)\n\u003e\n@router.post(\"\", name=\"users:create-token\")\nasync def create_token(\n    credentials: OAuth2PasswordRequestForm = Depends(),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n    strategy: strategy_type = fastapi_user.strategy_depends(),\n) -\u003e token_model:\n    get_user = await user_manager.authenticate(credentials)\n    if get_user is None or not get_user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n        )\n    if not get_user.is_verified:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n        )\n\u003e\n    token = await strategy.write_token(get_user)\n    return token_model.from_token(token)\n```\n\n\u003e ### backend/app/api/routes/cleanings.py\n\n```python\nfrom ...services.authentication import fastapi_user as fastapi_user_class\n```\n\n$\\rightarrow$ 클래스 이름 변경에 따른 수정\n\n```python\nfrom ...services.authentication import fastapi_user_class\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```python\nfrom fastapi import status\n```\n\n---\n\n```python\nfrom ...models.cleaning import (\n    cleaning_create,\n    cleaning_public,\n    cleaning_update,\n    cleanings,\n)\n```\n\n$\\rightarrow$ `models.cleaning` 에서 모델을 불러오는 방식으로\n\n```python\nfrom ...models import cleaning\n```\n\n\u003e ### backend/app/api/routes/\\_\\_init\\_\\_.py\n\n```python\nrouter.include_router(token_router, prefix=\"/auth\", tags=[\"token\"])\n```\n\n$\\rightarrow$ `auth` 대신 `token`으로 단일화\n\n```python\nrouter.include_router(token_router, prefix=\"/token\", tags=[\"token\"])\n```\n\n\u003e ### backend/tests/conftest.py\n\n```python\n@pytest.fixture(\n    params=[pytest.param((\"asyncio\", {\"use_uvloop\": True}), id=\"asyncio+uvloop\")]\n)\ndef anyio_backend(request):\n    return request.param\n```\n\n$\\rightarrow$ **`pytest`** 백엔드로 **`anyio+uvloop`** 를 사용하기 위한 설정 추가\n\n\u003e ### backend/tests/test_cleanings.py\n\n```python\npytestmark = pytest.mark.asyncio\n```\n\n$\\rightarrow$ **`pytest`** 백엔드로 **`anyio+uvloop`** 를 사용하기 위한 설정 추가\n\n```python\npytestmark = pytest.mark.anyio\n```\n\n---\n\n```python\nfrom starlette.status import (\n    HTTP_200_OK,\n    HTTP_201_CREATED,\n    HTTP_404_NOT_FOUND,\n    HTTP_422_UNPROCESSABLE_ENTITY,\n)\n```\n\n$\\rightarrow$ `fastapi.status` 에서 값을 불러오는 방식으로\n\n```python\nfrom fastapi import status\n```\n\n\u003e ### 신규 생성) backend/pytest.ini\n\n```bash\n❯ touch backend/pytest.ini\n```\n\n```yaml\n[pytest]\nfilterwarnings =\n    ignore::sqlalchemy.exc.SAWarning\n```\n\n$\\rightarrow$ **`sqlalchemy`** 에서 보내는 경고를 **`pytest`** 에서 출력하지 않도록 설정\n\n위 수정에서 확인할 수 있듯이, **`pytest`** 백엔드로 **`anyio`** 를 쓰기 때문에, **`pytest-asyncio`** 는 이제 필요가 없으므로 제거한다.\n\n```bash\n❯ poetry remove --dev pytest-asyncio\n❯ poetry export -f requirements.txt --output backend/requirements.txt --without-hashes --dev\n❯ docker-compose build\n```\n\n깜박하고 넘어간 경우가 있을텐데, 테스트 코드를 실행해보면 금방 수정할 수 있다.\n\n## `TDD` 방법론에 따른 유저 생성 `api` 만들기\n\n### 라우터 존재 확인\n\n원 예제의 **jeffastor**는 회원가입 api에 요청을 보내고 에러 코드를 확인하는 방식으로 만들었지만, 최근에 **RESTful** api 생성과 관련해서 [좋은 글](https://sanghaklee.tistory.com/57)을 확인했기에, **OPTIONS** api로 대신하고자 한다.\n\n```bash\n❯ touch backend/tests/test_users.py\n```\n\n```python\n# backend/tests/test_users.py\nimport pytest\nfrom fastapi import FastAPI, status\nfrom httpx import AsyncClient\n\npytestmark = pytest.mark.anyio\n\n\nclass TestUserRoutes:\n    api_name = \"users:get-allowed-methods\"\n\n    async def test_routes_exist(self, app: FastAPI, client: AsyncClient) -\u003e None:\n        res = await client.options(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_204_NO_CONTENT\n        assert not res.content\n        headers = res.headers\n        assert \"Allow\" in headers\n        allowed_methods_str = headers[\"Allow\"]\n        allowed_methods = {\n            method_str.strip().lower() for method_str in allowed_methods_str.split(\",\")\n        }\n        assert len(allowed_methods) \u003e 0\n        for method_str in (\"post\",):\n            assert method_str in allowed_methods\n```\n\n테스트를 실행해보면 당연히 에러가 나온다.\n\n```bash\nroot@90b2a10bcb6d:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py F                                                                                 [100%]\n\n================================================= FAILURES ==================================================\n_____________________________ TestUserRoutes.test_routes_exist[asyncio+uvloop] ______________________________\ntests/test_users.py:10: in test_routes_exist\n    res = await client.options(app.url_path_for(\"users:get-allowed-methods\"))\n/usr/local/lib/python3.10/site-packages/starlette/applications.py:108: in url_path_for\n    return self.router.url_path_for(name, **path_params)\n/usr/local/lib/python3.10/site-packages/starlette/routing.py:590: in url_path_for\n    raise NoMatchFound()\nE   starlette.routing.NoMatchFound\n----------------------------------------- Captured stderr teardown ------------------------------------------\nINFO  [alembic.env] Running migrations online\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\n========================================== short test summary info ==========================================\nFAILED tests/test_users.py::TestUserRoutes::test_routes_exist[asyncio+uvloop] - starlette.routing.NoMatchF...\n======================================= 1 failed, 39 passed in 4.52s ========================================\n```\n\n이제 에러를 해결하기 위한 라우터를 생성한다.\n\n```python\n# backend/app/api/routes/users.py\nfrom fastapi import APIRouter, Response, status\n\nfrom ...services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\nrouter = APIRouter()\n\n\n@router.options(\"\", name=\"users:get-allowed-methods\")\nasync def get_allowed_user_methods() -\u003e Response:\n    from functools import reduce\n\n    method_sets = [getattr(route, \"methods\") for route in router.routes]\n    all_methods = reduce(lambda left, right: left | right, method_sets, set())\n    all_methods_str = \", \".join(all_methods)\n\n    return Response(\n        status_code=status.HTTP_204_NO_CONTENT, headers={\"Allow\": all_methods_str}\n    )\n\n\n@router.post(\"\")\nasync def post_temp():\n    ...\n```\n\n임시로 가짜 **POST** api를 정의했기에, 테스트를 실행해도 에러가 발생하지 않는다.\n\n```bash\nroot@96deef95611e:/backend# pytest --tb=short\n============================================ test session starts ============================================\nplatform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /backend, configfile: pytest.ini\nplugins: anyio-3.5.0\ncollected 40 items\n\ntests/test_cleanings.py .......................................                                       [ 97%]\ntests/test_users.py .                                                                                 [100%]\n\n============================================ 40 passed in 4.03s =============================================\n```\n\n### 회원가입\n\n우선, 기존에 작성했던 유저 모델에 대해 이메일로 검색할 수 있는 메소드를 하나 생성한다. 관련해서 종종 쓰이기 때문.\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar, cast\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlmodel.sql.expression import Select\n\n(...)\n\n_T = TypeVar(\"_T\", bound=\"user_model\")\n\n(...)\n\nclass user(user_base, models.BaseUserDB):\n    def to_model(self) -\u003e \"user_model\":\n        return user_model.validate(self)\n\n\nclass user_model(base_model, datetime_model, table=True):\n    __tablename__: str = \"users\"\n\n    id: UUID4 = Field(default_factory=uuid4, primary_key=True)\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: AsyncSession, email: str\n    ) -\u003e _T | None:\n        is_user_cur = await session.exec(\n            cast(Select[_T], select(cls).where(cls.email == email))\n        )\n        return is_user_cur.first()\n```\n\n\u003e 아직 **`sqlmodel`** 의 `async` 지원이 부족해서, `typing.cast`를 이용해서 `Select` 타입으로 강제해서 사용했다.\n\n\u003e `user`와 `user_model`을 하나로 합칠 수 있을 것 같은데, 이건 나중에 시간내서 확인해볼 생각.\n\n이제 **`fastapi-users`** 를 사용할 때가 왔다. 우선 테스트 코드부터 작성한다.\n\n```python\n# backend/tests/test_users.py\nfrom app.models import user\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\nclass TestUserRegistration:\n    api_name = \"users:register-new-user\"\n\n    async def test_users_can_register_successfully(\n        self, app: FastAPI, client: AsyncClient, engine: AsyncEngine\n    ) -\u003e None:\n        new_user = {\n            \"email\": \"shakira@shakira.io\",\n            \"name\": \"shakirashakira\",\n            \"password\": \"chantaje@1\",\n        }\n        # make sure user doesn't exist yet\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is None\n        # send post request to create user and ensure it is successful\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status.HTTP_201_CREATED\n        # ensure that the user now exists in the db\n        async with AsyncSession(engine, autocommit=False) as session:\n            is_user = await user.user_model.get_from_email(\n                session=session, email=new_user[\"email\"]\n            )\n        assert is_user is not None\n        assert is_user.email == new_user[\"email\"]\n        assert is_user.name == new_user[\"name\"]\n        # check that the user returned in the response is equal to the user in the database\n        created_user = user.user_model.validate(\n            res.json() | {\"hashed_password\": \"whatever\"}\n        )\n        exclude_attr_set = user.user_model.datetime_attrs | {\"id\", \"hashed_password\"}\n        assert created_user.dict(exclude=exclude_attr_set) == is_user.dict(\n            exclude=exclude_attr_set\n        )\n\n    @pytest.mark.parametrize(\n        \"attr, value, status_code\",\n        (\n            (\"email\", \"shakira@shakira.io\", 400),\n            (\"name\", \"sha\", 422),\n            (\"name\", \"shafasdfsdwerewfsdfxcvxcvxcv\", 422),\n            (\"email\", \"invalid_email@one@two.io\", 422),\n            (\"password\", \"short\", 422),\n            (\n                \"password\",\n                (\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                    \"longlonglonglonglonglonglonglonglonglonglonglong\"\n                ),\n                422,\n            ),\n            (\"password\", \"pattern@\", 422),\n            (\"name\", \"shakira@#$%^\u003c\u003e\", 422),\n            (\"name\", \"ab\", 422),\n        ),\n    )\n    async def test_user_registration_fails_when_credentials_are_taken(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        attr: str,\n        value: str,\n        status_code: int,\n    ) -\u003e None:\n        new_user = {\n            \"email\": \"nottaken@email.io\",\n            \"name\": \"not_taken_username\",\n            \"password\": \"freepassword@1\",\n        }\n        new_user[attr] = value\n        res = await client.post(\n            app.url_path_for(self.api_name), json={\"new_user\": new_user}\n        )\n        assert res.status_code == status_code\n```\n\n이제 위 테스트 코드를 통과할 수 있을 것 같은 api를 생성한다.\n\n```python\nimport re\n\nimport orjson\nfrom fastapi import Body, HTTPException, Request\nfrom fastapi_users.manager import InvalidPasswordException, UserAlreadyExists\nfrom pydantic import ValidationError\n\nfrom ...models import user\nfrom ...services.authentication import user_manager_type\n\n(...)\n\nre_deny_name = re.compile(r\"[^a-zA-Z0-9_-]\")\n\n(...)\n\n@router.post(\n    \"\",\n    name=\"users:register-new-user\",\n    response_model=user.user_read,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def register_new_user(\n    request: Request,\n    new_user: user.user_create = Body(..., embed=True),\n    user_manager: user_manager_type = fastapi_user.user_manager_depends,\n):\n    if re_deny_name.search(new_user.name):\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=(\n                \"The name can only contain the following characters: \"\n                f\"{re_deny_name.pattern.replace('^','')}\"\n            ),\n        )\n\n    try:\n        return await user_manager.create(new_user, safe=True, request=request)\n    except UserAlreadyExists as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=(\n                \"That email is already taken. \"\n                \"Login with that email or register with another one.\"\n            ),\n        )\n    except ValidationError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=orjson.loads(exc.json()),\n        )\n    except InvalidPasswordException as exc:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=exc.reason,\n        )\n\n```\n\n\u003e 따로 적지는 않았지만, **TDD** 방법론을 충실히 이행하면서 만들어진 테스트 코드와 api다.\n\n위 코드를 기반으로 테스트를 실행해보면, 모두 정상적으로 실행되는 것을 확인할 수 있다.\n\n### 토큰\n\n**`fastapi-users`** 덕분에 토큰 등에 대한 별다른 작업 없이 깔끔하게 끝났지만, 원 예제에서는 토큰과 관련된 몇가지 작업이 진행된다. 해당 과정 중 해보면 좋을 것 같은 부분만 따라서 진행한다.\n\n#### 토큰 관련 설정 수정 및 추가\n\n초기에 대충 작성해놨던 `SECRET_KEY` 등의 값을 지정해준다. 이 값을 직접 작성하기 보다는 그냥 터미널 명령어로 생성된 임의의 값을 사용하는 것이 좋다.\n\n```bash\n❯ openssl rand -hex 32\n```\n\n이제 이 값을 `.env` 파일에 추가하면 된다. 이 외에도 몇몇 값을 추가로 더 설정하는데 각 값은 다음과 같다.\n\n\u003e `ACCESS_TOKEN_EXPIRE_SECONDS`: 토큰의 만료시간(초)\n\u003e `JWT_ALGORITHM`: 토큰 암호화 알고리즘\n\u003e `JWT_AUDIENCE`: 토큰 발급/수신 대상\n\u003e `JWT_TOKEN_PREFIX`: 토큰 타입?(얘는 확실하지 않음)\n\n이제 `config.py`가 위 값을 잘 읽을 수 있게 수정한다.\n\n```python\n# backend/app/core/config.py\n(...)\n\nACCESS_TOKEN_EXPIRE_MINUTES = config(\n    \"ACCESS_TOKEN_EXPIRE_MINUTES\", cast=int, default=60 * 60\n)\nJWT_ALGORITHM = config(\"JWT_ALGORITHM\", cast=str, default=\"HS256\")\nJWT_AUDIENCE = config(\"JWT_AUDIENCE\", cast=str, default=\"phresh:auth\")\nJWT_TOKEN_PREFIX = config(\"JWT_TOKEN_PREFIX\", cast=str, default=\"Bearer\")\n\n(...)\n```\n\n그리고 이 값을 잘 참조할 수 있도록 수정한다.\n\n```python\n# backend/app/services/authentication.py\n(...)\n\nclass token_model(BaseModel):\n    access_token: str\n    token_type: str = config.JWT_TOKEN_PREFIX\n\n    @classmethod\n    def from_token(cls, token: str) -\u003e \"token_model\":\n        return cls(access_token=token)\n\n(...)\n\ndef create_strategy() -\u003e Strategy[user.user_create, user.user]:\n    return JWTStrategy(\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n(...)\n```\n\n테스트 코드에서 사용할 `fixture`를 정의한다. 중복 이메일을 허용하지 않기에 주의해서 작성한다.\n\n```python\n# backend/tests/conftest.py\nfrom app.models import user\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n(...)\n\n@pytest.fixture\nasync def test_user(engine: AsyncEngine) -\u003e user.user_model:\n    new_user = user.user_create.parse_obj(\n        dict(\n            email=\"lebron@james.io\",\n            name=\"lebronjames\",\n            password=\"heatcavslakers@1\",\n        )\n    )\n\n    async with AsyncSession(engine, autocommit=False) as session:\n        db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n        manager = UserManager(db)\n\n        try:\n            new_user_db = await manager.get_by_email(new_user.email)\n        except UserNotExists:\n            new_user_db = await manager.create(new_user, safe=True)\n\n    return new_user_db.to_model()\n```\n\n이제 이 `fixture`를 이용해서 토큰을 발급받고, 검증하는 테스트 코드를 작성한다.\n\n\u003e 2022.05.06. 아래 테스트 코드는 사실상 무의미하기에, 없어도 좋다. **TDD**에 익숙하지 않은 것도 있고, 원 예제의 내용과 다른 방식으로 api를 생성하다보니 헷갈려서 잘못 작성한 것 같다. 다음 챕터의 로그인 테스트 코드를 확인하자.\n\n```python\nclass TestAuthTokens:\n    api_name = \"users:create-token\"\n\n    async def test_can_create_access_token_successfully(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -\u003e None:\n        access_token = await strategy.write_token(user=test_user)\n        creds = decode_jwt(\n            access_token,\n            str(config.SECRET_KEY),\n            [config.JWT_AUDIENCE],\n            [config.JWT_ALGORITHM],\n        )\n\n        assert creds.get(\"user_id\") is not None\n        user_id = creds[\"user_id\"]\n        assert config.JWT_AUDIENCE in creds[\"aud\"]\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            user_model = await session.get(user.user_model, user_id)\n        assert user_model is not None\n\n        assert user_model.name == test_user.name\n\n    async def test_token_missing_user_is_invalid(\n        self, app: FastAPI, client: AsyncClient\n    ) -\u003e None:\n        res = await client.post(\n            url=app.url_path_for(self.api_name),\n            data={\"username\": \"unknown\", \"password\": \"testpassword@1\"},\n        )\n        assert res.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n```\n\n원 예제는 테스트 코드가 조금 더 풍부하지만, **`fastapi-users`** 를 사용중이기에, 불필요한 과정이라 생각됐다. 위 테스트 코드에서 `strategy`를 이용하여 직접 `access_token`을 생성해보기도 하고 복호화해보기도 하며, `access_token`로 부터 유저를 불러오기도 한다. 끝으로 이러한 과정이 진행되는 api를 호출해보기도 한다.\n\n테스트는 문제없이 잘 진행됐다.\n\n다음 챕터에서는 지금까지 만든 유저 api로 로그인 등을 시도한다. 참고로, 현재 선택한 전략으로는, 서버가 이미 발급한 토큰에 대해 처리가 불가능하므로, 로그아웃 기능을 생성할 수 없다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","data":{"title":"fastapi 튜토리얼 -7- FastAPI Users를 사용한 유저 api 생성 2","date":"2022-05-05T06:13:07.421+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## 토큰 발행 방식 수정\n\n### 기존 코드 수정\n\n이전에 토큰 발행 api를 직접 작성했는데, 좀 더 알아보니, **`fastapi-users`** 에서 제공하는 `login` api와 동일하다. 따라서 토큰 발행과 관련해서 약간의 수정을 진행한다.\n\n\u003e #### backend/app/core/config.py\n\u003e\n\u003e 토큰 경로 수정\n\n```python\nTOKEN_PREFIX = API_PREFIX + \"/token/login\"\n```\n\n---\n\n`AUTH_BACKEND_NAME` 추가\n\n```python\nAUTH_BACKEND_NAME = config(\n    \"AUTH_BACKEND_NAME\", cast=str, default=f\"{JWT_TOKEN_PREFIX}-jwt\"\n)\n```\n\n\u003e #### backend/app/services/authentication.py\n\u003e\n\u003e 토큰 모델 제거\n\n```python\n# class token_model(BaseModel):\n#     access_token: str\n#     token_type: str = config.JWT_TOKEN_PREFIX\n\u003e\n#     @classmethod\n#     def from_token(cls, token: str) -\u003e \"token_model\":\n#         return cls(access_token=toke\n```\n\n---\n\n`AUTH_BACKEND_NAME` 참조 추가\n\n```python\ndef create_backend() -\u003e list[AuthenticationBackend[user.user_create, user.user]]:\n    transport = create_transport()\n    return [\n        AuthenticationBackend(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n```\n\n\u003e #### backend/app/api/routes/token.py\n\u003e\n\u003e **`fastapi-users`** 라우터 추가\n\u003e 편의상 당분간 `requires_verification=False`로 한다.\n\n```python\n# name: auth:{backend.name}.login\nrouter.include_router(\n    fastapi_user.users.get_auth_router(\n        fastapi_user.backends[0], requires_verification=False\n    )\n)\n```\n\n---\n\n기존 api 제거\n\n```python\n# @router.post(\"\", name=\"users:create-token\")\n# async def create_token(\n#     credentials: OAuth2PasswordRequestForm = Depends(),\n#     user_manager: user_manager_type = fastapi_user.user_manager_depends,\n#     strategy: strategy_type = fastapi_user.strategy_depends(),\n# ) -\u003e token_model:\n#     get_user = await user_manager.authenticate(credentials)\n#     if get_user is None or not get_user.is_active:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_BAD_CREDENTIALS,\n#         )\n#     if not get_user.is_verified:\n#         raise HTTPException(\n#             status_code=status.HTTP_400_BAD_REQUEST,\n#             detail=ErrorCode.LOGIN_USER_NOT_VERIFIED,\n#         )\n\u003e\n#     token = await strategy.write_token(get_user)\n#     return token_model.from_token(token)\n```\n\n\u003e #### backend/tests/test_users.py\n\u003e\n\u003e `api_name` 수정\n\n```python\nclass TestAuthTokens:\n    api_name = f\"auth:{config.AUTH_BACKEND_NAME}.login\"\n```\n\n### **`fastapi-users`** 가 제공하는 `api`의 검증 방식\n\n\u003e 현재 사용중인 **`fastapi-users`** 의 버전은 `9.3.1`이라는 것에 유의한다.\n\n우선 이메일을 기준으로 유저를 조회 한 다음, 비밀번호를 검증한다.\n그리고 해당 유저 레코드의 `is_active`가 `True`인지 확인하고, `requires_verification` 값에 따라 `is_verified`가 `True`인지 확인한다.\n\n유저가 존재하지 않거나, `is_active=False`이거나, `requires_verification=True`이면서 `is_verified=False`인 경우 에러(400)을 반환한다.\n\n## `TDD` 방법론에 따른 로그인 `api`\n\n### 일반적인 로그인 방식\n\n| 사용자                             | 프론트엔드                                    | 백엔드                         |\n| ---------------------------------- | --------------------------------------------- | ------------------------------ |\n| `name`, `password` 입력            |                                               |                                |\n|                                    | `name`, `password` 백엔드로 전송              |                                |\n|                                    |                                               | `name`, `password` 유효성 검사 |\n|                                    |                                               | 토큰 생성                      |\n|                                    |                                               | 토큰 프론트엔드로 전송         |\n|                                    | 토큰 임시 저장                                |\n| 로그인이 필요한 특정 페이지로 이동 |                                               |                                |\n|                                    | 저장된 토큰(Authorization 헤더) 백엔드로 전송 |                                |\n|                                    |                                               | 토큰 유효성 검사               |\n|                                    |                                               | 컨텐츠 전송                    |\n| ...                                | ...                                           | ...                            |\n\n### 로그인 테스트 코드 작성\n\n```python\n# backend/tests/test_users.py\nfrom app.services.authentication import UserManager\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n(...)\n\nclass TestUserLogin:\n    api_name = \"users:login-email-and-password\"\n\n    async def test_user_can_login_successfully_and_receives_valid_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        engine: AsyncEngine,\n    ) -\u003e None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        login_data = {\"email\": test_user.email, \"password\": \"heatcavslakers@1\"}\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status.HTTP_200_OK\n        # check that token exists in response and has user encoded within it\n        token = res.json().get(\"access_token\")\n\n        async with AsyncSession(engine, autocommit=False) as session:\n            db = SQLAlchemyUserDatabase(user.user, session, user.user_model)  # type: ignore\n            manager = UserManager(db)\n\n            read_user: user.user_model | None = await strategy.read_token(\n                token, manager\n            )\n        assert read_user is not None\n        assert read_user.name == test_user.name\n        assert read_user.email == test_user.email\n        # check that token is proper type\n        assert \"token_type\" in res.json()\n        assert res.json().get(\"token_type\") == \"bearer\"\n\n    @pytest.mark.parametrize(\n        \"credential, wrong_value, status_code\",\n        (\n            (\"email\", \"wrong@email.com\", 401),\n            (\"email\", None, 401),\n            (\"email\", \"notemail\", 401),\n            (\"password\", \"wrongpassword@1\", 401),\n            (\"password\", None, 401),\n        ),\n    )\n    async def test_user_with_wrong_creds_doesnt_receive_token(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        credential: str,\n        wrong_value: str,\n        status_code: int,\n    ) -\u003e None:\n        client.headers[\"content-type\"] = \"application/x-www-form-urlencoded\"\n        user_data = test_user.dict()\n        user_data[\"password\"] = \"heatcavslakers@1\"\n        user_data[credential] = wrong_value\n        login_data = {\n            \"username\": user_data[\"email\"],\n            \"password\": user_data[\"password\"],  # insert password from parameters\n        }\n        res = await client.post(app.url_path_for(self.api_name), data=login_data)\n        assert res.status_code == status_code\n        assert \"access_token\" not in res.json()\n```\n\n사용자가 `email`과 `password`를 올바르게 보냈을 때 얻게 되는 토큰으로 부터, **`fastapi_users`** 를 이용해서 불러온 유저 레코드가 `test_user`와 일치하는지 확인한다.\n\n여기서 로그인의 경우 `json` 파라미터가 아닌 `data` 파라미터로 데이터를 전송하고, `content-type` 헤더로 `application/x-www-form-urlencoded`를 가지고 있어야 한다는 점에 유의한다.\n\n### 로그인 `api` 작성\n\n토큰 발행 api가 로그인 api이므로, 따로 작성할 필요가 없다.\n만약 400에러가 아닌 401에러를 반환하고 싶다면, 이전 챕터처럼 직접 작성하면 된다.\n\n### 인증 `Depends` 생성\n\n이제 토큰을 발급받은 경우에만 사용이 가능한 api에 대한 인증 절차를 정의해야한다. **`fastapi`** 에서는 이러한 기능은 `Depends`를 사용해서 생성할 수 있다. 또한, **`fastapi-users`** 에서 관련된 함수를 이미 만들어서 제공하고 있다. 우선 테스트 코드부터 작성한다.\n\n```python\n# backend/tests/conftest.py\nfrom app.services.authentication import create_strategy\nfrom sqlmodel import select\n\n(...)\n\n@pytest.fixture\nasync def authorized_client(\n    client: AsyncClient, test_user: user.user_model\n) -\u003e AsyncClient:\n    from app.core import config\n\n    strategy = create_strategy()\n    access_token = await strategy.write_token(user=test_user)  # type: ignore\n\n    client.headers[\"Authorization\"] = f\"{config.JWT_TOKEN_PREFIX} {access_token}\"\n    return client\n```\n\n방금 작성한 `authorized_client`를 이용해서 인증이 필요한 라우터에 접근이 가능하다.\n\n\u003e 쓰다보니 `user.user`와 `user.user_model`이 따로 있는게 너무 불편한데, 언제 한번 합치는 시도를 해봐야 할듯. `AsyncSession` 관련해서도 언제한번 해결을 해야할 것 같고..\n\n```python\n# backend/tests/test_users.py\n(...)\n\nclass TestUserMe:\n    api_name = \"users:get-current-user\"\n\n    async def test_authenticated_user_can_retrieve_own_data(\n        self,\n        app: FastAPI,\n        authorized_client: AsyncClient,\n        test_user: user.user_model,\n    ) -\u003e None:\n        res = await authorized_client.get(app.url_path_for(self.api_name))\n        assert res.status_code == status.HTTP_200_OK\n        res_dict: dict = res.json()\n        res_dict[\"hashed_password\"] = \"testpassword@1\"\n        read_user = user.user_model.validate(res_dict)\n        assert read_user.email == test_user.email\n        assert read_user.name == test_user.name\n        assert read_user.id == test_user.id\n\n    async def test_user_cannot_access_own_data_if_not_authenticated(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n    ) -\u003e None:\n        res = await client.get(app.url_path_for(\"users:get-current-user\"))\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n\n    @pytest.mark.parametrize(\n        \"jwt_prefix\",\n        (\n            (\"\",),\n            (\"value\",),\n            (\"Token\",),\n            (\"JWT\",),\n            (\"Swearer\",),\n        ),\n    )\n    async def test_user_cannot_access_own_data_with_incorrect_jwt_prefix(\n        self,\n        app: FastAPI,\n        client: AsyncClient,\n        test_user: user.user_model,\n        strategy: JWTStrategy,\n        jwt_prefix: str,\n    ) -\u003e None:\n        token = await strategy.write_token(test_user)\n        res = await client.get(\n            app.url_path_for(\"users:get-current-user\"),\n            headers={\"Authorization\": f\"{jwt_prefix} {token}\"},\n        )\n        assert res.status_code == status.HTTP_401_UNAUTHORIZED\n```\n\n위 테스트를 통과할 수 있는 api를 작성한다.\n\n```python\nfrom fastapi import Depends\n\n(...)\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\n\n(...)\n\n@router.get(\"/me\", response_model=user.user_read, name=\"users:get-current-user\")\nasync def get_currently_authenticated_user(\n    current_user: user.user = Depends(get_current_user),\n) -\u003e user.user_model:\n    return current_user.to_model()\n```\n\n`optional=False, active=True, verified=False, superuser=False`으로 값을 지정했기에, 해당 함수는 일치하는 유저가 없거나 `is_active` 값이 `False`이면 에러(401)을 반환한다.\n\n테스트 통과도 잘되고, **`swagger`** 에서도 확인이 간단한 api가 생성됐다. 유저 인증 관련해서는 사실상 이게 끝이다. 코드를 조금 더 정리할 수는 있지만 핵심은 비슷할 것이다.\n\n다음 챕터에서는 유저 프로필을 설정한다.\n그 전에 앞에서 언급한 유저 모델과 관련된 수정을 진행할 수도 있다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","data":{"title":"fastapi 튜토리얼 -8- FastAPI Users를 사용한 유저 api 생성 3","date":"2022-05-06T06:26:51.932+09:00","tags":["fastapi","fastapi-users","python","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `Session`의 코드를 그대로 복붙\n\n이전까지 글에서 계속해서 `AsyncSession`의 타입 관련 문제가 발생하는게 너무 짜증나서, 임시로 땜빵용 클래스를 생성해서 사용하기로 했다.\n\n````python\n# backend/app/db/session.py\n(...)\n\n_TSelectParam = TypeVar(\"_TSelectParam\")\n\nclass async_session(AsyncSession):\n    # sqlmodel.orm.session.Session\n    @overload\n    async def exec(\n        self,\n        statement: Select[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Result[_TSelectParam]:\n        ...\n\n    @overload\n    async def exec(\n        self,\n        statement: SelectOfScalar[_TSelectParam],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e ScalarResult[_TSelectParam]:\n        ...\n\n    async def exec(\n        self,\n        statement: Union[\n            Select[_TSelectParam],\n            SelectOfScalar[_TSelectParam],\n            Executable[_TSelectParam],\n        ],\n        *,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Mapping[str, Any] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Union[Result[_TSelectParam], ScalarResult[_TSelectParam]]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().exec(\n            statement,  # type: ignore\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def execute(\n        self,\n        statement: _Executable,\n        params: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]] = None,\n        execution_options: Optional[Mapping[str, Any]] = util.EMPTY_DICT,\n        bind_arguments: Optional[Mapping[str, Any]] = None,\n        _parent_execute_state: Optional[Any] = None,\n        _add_event: Optional[Any] = None,\n        **kw: Any,\n    ) -\u003e Result[Any]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        ***\n\n        🚨 You probably want to use `session.exec()` instead of `session.execute()`.\n\n        This is the original SQLAlchemy `session.execute()` method that returns objects\n        of type `Row`, and that you have to call `scalars()` to get the model objects.\n\n        For example:\n\n        ```Python\n        heroes = session.execute(select(Hero)).scalars().all()\n        ```\n\n        instead you could use `exec()`:\n\n        ```Python\n        heroes = session.exec(select(Hero)).all()\n        ```\n        \"\"\"\n        return await super().execute(  # type: ignore\n            statement,\n            params=params,\n            execution_options=execution_options,\n            bind_arguments=bind_arguments,\n            _parent_execute_state=_parent_execute_state,\n            _add_event=_add_event,\n            **kw,\n        )\n\n    async def get(\n        self,\n        entity: Type[_TSelectParam],\n        ident: Any,\n        options: Optional[Sequence[Any]] = None,\n        populate_existing: bool = False,\n        with_for_update: Optional[Union[Literal[True], Mapping[str, Any]]] = None,\n        identity_token: Optional[Any] = None,\n    ) -\u003e Optional[_TSelectParam]:\n        \"\"\"\n        sqlmodel.orm.session.Session\n        \"\"\"\n        return await super().get(\n            entity,\n            ident,\n            options=options,\n            populate_existing=populate_existing,\n            with_for_update=with_for_update,\n            identity_token=identity_token,\n        )\n````\n\n주석을 보면 알겠지만, 그냥 `sqlmodel.orm.session.Session` 객체의 각 메소드의 타입 힌트를 그대로 가져왔다. 이에 맞춰서 다른 스크립트의 `AsyncSession`도 모두 `async_session`에 대한 스크립트로 변환해준다. 그리고 테스트 코드를 실행해보면 문제없이 실행되는 것을 확인할 수 있다.\n\n---\n\n## `datetime_model` 관련 문제 해결\n\n`datetime_model`의 `datetime_attrs` 속성이 의도한대로 출려되지 않는 문제가 있어서 추가로 수정했다. `cls.__fields__.keys()` 를 `datetime_model.__fields__.keys()`로 수정한 것외에 모두 동일하다.\n\n```python\n# backend/app/models/core.py\n(...)\n\nclass datetime_model(fix_return_type_model):\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n    def update(self: _D) -\u003e _D:\n        self.updated_at = datetime.now()\n        return self\n\n    @classmethod\n    @property\n    def datetime_attrs(cls) -\u003e set[str]:\n        return set(datetime_model.__fields__.keys())\n```\n\n## `id_model` 세분화\n\n기존에 사용하던 `id_model`을 `int_id_model`과 `uuid_id_model`로 세분화해서 사용하기로 했다.\n\n```python\n# backend/app/models/core.py\nfrom uuid import uuid4\nfrom pydantic import UUID4\n\n(...)\n\nclass id_model(fix_return_type_model):\n    @classmethod\n    @property\n    def id_type(cls) -\u003e Any:\n        return cls.__fields__[\"id\"].type_\n\n\nclass int_id_model(id_model):\n    id: int | None = Field(None, primary_key=True)\n\n\nclass uuid_id_model(id_model):\n    id: UUID4 | None = Field(default_factory=uuid4, primary_key=True)\n```\n\n## `dependencies` 모듈 생성\n\n기존에 사용하던 `get_session`이나 `get_current_user`같은 `Depends`와 함께 사용하던 함수를 따로 관리하기로 했다.\n\n```python\n# backend/app/dependencies/database.py\nfrom typing import AsyncIterator\n\nfrom fastapi import Depends, Request\nfrom sqlalchemy.ext.asyncio.engine import AsyncEngine\n\nfrom ..db.session import async_session\n\n\nasync def get_database(request: Request) -\u003e AsyncEngine:\n    if (engine := getattr(request.app.state, \"_db\", None)) is None:\n        raise AttributeError(\"there is no database engine in request as state\")\n    return engine\n\n\nasync def get_session(\n    engine: AsyncEngine = Depends(get_database),\n) -\u003e AsyncIterator[async_session]:\n    async with async_session(engine, autoflush=False, autocommit=False) as session:\n        yield session\n```\n\n```python\n# backend/app/dependencies/auth.py\nfrom ..services.authentication import fastapi_user_class\n\nfastapi_user = fastapi_user_class.init()\n\nget_current_user = fastapi_user.users.current_user(\n    optional=False, active=True, verified=False, superuser=False\n)\nget_user_manager = fastapi_user.get_user_manager\nget_backend = fastapi_user.get_backend\nget_transport = fastapi_user.get_transport\nget_strategy = fastapi_user.get_strategy\n```\n\n```python\n# backend/app/services/authentication/authentication.py\n(...)\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n    named_backends: dict[str, auth_backend_type] = field(default_factory=dict)\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -\u003e Sequence[auth_backend_type]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def get_user_manager(self):\n        return self.users.get_user_manager\n\n    def find_backend(self, _val: str, /) -\u003e auth_backend_type:\n        for backend in self.backends:\n            if backend.name == _val:\n                return backend\n        raise IndexError(f\"there is not auth_backend name: {_val}\")\n\n    def get_backend(self, _val: int | str = 0, /) -\u003e auth_backend_type:\n        if isinstance(_val, int):\n            return self.backends[_val]\n\n        if (backend := self.named_backends.get(_val)) is None:\n            backend = self.named_backends[_val] = self.find_backend(_val)\n        return backend\n\n    def get_transport(self, _val: int | str = 0, /) -\u003e Transport:\n        backend = self.get_backend(_val)\n        return backend.transport\n\n    def get_strategy(self, _val: int | str = 0, /):\n        backend = self.get_backend(_val)\n        return backend.get_strategy\n```\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","data":{"title":"fastapi 튜토리얼 -8.1- SQLModel AsyncSession 관련 타입 문제 임시 해결 + 추가 수정","date":"2022-05-07T22:08:12.781+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}},{"name":"fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","content":"\n**`fastapi`** 사용법을 다시 공부할겸, 참고할만한 좋은 [예제](https://www.jeffastor.com/blog/populating-cleaning-jobs-with-user-offers-in-fastapi)가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다.\n지난번처럼 어쩌다 그만둘 수도 있긴 하지만...\n\n---\n\n## `Breaking` `changes`\n\n이틀전 **`fastapi-users`** 에 큰 변화가 생겼다. `v10` 릴리즈가 공개됐는데, `db` 모델과 여러 제네릭 타입에 대한 변화가 생겨서, `v10`을 이용하려면 대응 패치가 필수적인 상황..\n\n아래는 해당 릴리즈에 대한 전문이다.\n\n\u003e ### [Breaking changes](https://github.com/fastapi-users/fastapi-users/releases/tag/v10.0.0)\n\u003e\n\u003e Version 10 marks important changes in how we manage User models and their ID.\n\u003e\n\u003e Before, we were relying only on Pydantic models to work with users. In particular the current_user dependency would return you an instance of UserDB, a Pydantic model. This proved to be quite problematic with some ORM if you ever needed to retrieve relationship data or make specific requests.\n\u003e\n\u003e Now, FastAPI Users is designed to always return you a native object for your ORM model, whether it's an SQLAlchemy model or a Beanie document. Pydantic models are now only used for validation and serialization inside the API.\n\u003e\n\u003e Before, we were forcing the use of UUID as primary key ID; a consequence of the design above. This proved to be quite problematic on some databases, like MongoDB which uses a special ObjectID format by default. Some SQL folks also prefer to use traditional auto-increment integers.\n\u003e\n\u003e Now, FastAPI Users is designed to use generic ID type. It means that you can use any type you want for your user's ID. By default, SQLAlchemy adapter still use UUID; but you can quite easily switch to another thing, like an integer. Beanie adapter for MongoDB will use native ObjectID by default, but it also can be overriden.\n\n### 유저 모델 생성 및 수정\n\n기존 `fastapi_users.models` 에서 `fastapi_users.schemas`로 바뀐 것 외에 크게 달라진 것은 없다. 사실 이전에 얘기했던 `user` 와 `user_model`을 통합하는 작업을 이미 한 다음 `v10` 릴리즈를 확인했기에 더욱 그렇게 느껴졌다...\n\n```python\n# backend/app/models/user.py\nfrom typing import TypeVar\n\nfrom fastapi_users import schemas\nfrom pydantic import EmailStr\nfrom pydantic import Field as _Field\nfrom sqlmodel import Field, select\n\nfrom ..db.session import async_session\nfrom .core import base_model, datetime_model, uuid_id_model\n\nmin_name_length = 4\nmax_name_length = 20\n\n\n_T = TypeVar(\"_T\", bound=\"user\")\nid_model = uuid_id_model\nuser_id_type = id_model.id_type\n\n\nclass user(id_model, datetime_model, base_model, table=True):\n    __tablename__: str = \"users\"\n\n    name: str = Field(min_length=min_name_length, max_length=max_name_length)\n    hashed_password: str = Field(max_length=2**10)\n    email: EmailStr = Field(index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    is_verified: bool = False\n\n    @classmethod\n    async def get_from_email(\n        cls: type[_T], session: async_session, email: str\n    ) -\u003e _T | None:\n        is_user_cur = await session.exec(select(cls).where(cls.email == email))\n        return is_user_cur.first()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.validate(self)\n\n\nclass user_read(schemas.BaseUser[user_id_type], datetime_model):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_create(schemas.BaseUserCreate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n\n\nclass user_update(schemas.BaseUserUpdate):\n    name: str = _Field(min_length=min_name_length, max_length=max_name_length)\n```\n\n### 인증 모듈 제네릭 타입 덮어씌우기\n\n**`fastapi-users`** 에서 원하는 형태는 `SQLAlchemyBaseUserTable`를 상속한 클래스를 사용하는 것이지만, **`sqlmodel`** 도 그대로 사용하고 **`fastapi-users`** 의 타입 힌트도 그대로 사용하고 싶기에, 두 라이브러리를 엮어줄 새로운 제네릭 클래스를 생성한다.\n`# type: ignore`를 남발하기에 그다지 좋은 모습이라고 생각되지 않지만, 이거 외에 당장 생각나는 방법이 없기에 일단 넘어가자.\n\n```bash\n❯ mkdir backend/app/services/authentication\n❯ mv backend/app/services/authentication.py backend/app/services/authentication/authentication.py\n❯ touch backend/app/services/authentication/__init__.py backend/app/services/authentication/convert.py\n```\n\n```python\n# backend/app/services/authentication/__init__.py\nfrom .authentication import *\n```\n\n```python\n# backend/app/services/authentication/convert.py\nfrom typing import Generic, TypeVar\n\nfrom fastapi_users import BaseUserManager, FastAPIUsers\nfrom fastapi_users.authentication import AuthenticationBackend, JWTStrategy, Strategy\nfrom fastapi_users.db import SQLAlchemyUserDatabase\n\nfrom ...models.core import base_model\nfrom ...models.user import user\n\nuser_id_type = user.id_type\n_T = TypeVar(\"_T\", bound=base_model)\n_D = TypeVar(\"_D\")\n\n# fmt: off\nclass user_db_class(SQLAlchemyUserDatabase[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass strategy_class(Strategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass jwt_strategy_class(JWTStrategy[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass auth_backend_class(AuthenticationBackend[_T, _D], Generic[_T, _D]): ... # type: ignore\nclass user_manager_class(BaseUserManager[_T, _D], Generic[_T, _D]): ...  # type: ignore\nclass fastapi_users_class(FastAPIUsers[_T, _D], Generic[_T, _D]): ...  # type: ignore\n# fmt: on\n\n\nuser_manager_type = user_manager_class[user, user_id_type]\nstrategy_type = strategy_class[user, user_id_type]\n```\n\n### 변경점 인증 모듈에 적용\n\n```python\n# backend/app/services/authentication/authentication.py\nimport re\nfrom dataclasses import dataclass\nfrom re import Pattern\nfrom typing import AsyncGenerator, Sequence\n\nfrom fastapi import Depends, Request\nfrom fastapi_users import IntegerIDMixin, InvalidPasswordException\nfrom fastapi_users.authentication import BearerTransport, Transport\n\nfrom ...core import config\nfrom ...db.session import async_session, get_session\nfrom ...models import user\nfrom .convert import (\n    auth_backend_class,\n    fastapi_users_class,\n    jwt_strategy_class,\n    strategy_class,\n    strategy_type,\n    user_db_class,\n    user_id_type,\n    user_manager_class,\n    user_manager_type,\n)\n\n\nasync def get_user_db(\n    session: async_session = Depends(get_session),\n) -\u003e AsyncGenerator[user_db_class[user.user, user_id_type], None]:\n    yield user_db_class(session, user.user)\n\n\ndef create_transport() -\u003e Transport:\n    return BearerTransport(tokenUrl=config.TOKEN_PREFIX)\n\n\ndef create_strategy() -\u003e strategy_class[user.user, user_id_type]:\n    return jwt_strategy_class(  # type: ignore\n        secret=str(config.SECRET_KEY),\n        lifetime_seconds=config.ACCESS_TOKEN_EXPIRE_SECONDS,\n        token_audience=[config.JWT_AUDIENCE],\n        algorithm=config.JWT_ALGORITHM,\n    )\n\n\ndef create_backend() -\u003e list[auth_backend_class[user.user, user_id_type]]:\n    transport = create_transport()\n    return [\n        auth_backend_class(\n            name=config.AUTH_BACKEND_NAME,\n            transport=transport,\n            get_strategy=create_strategy,\n        )\n    ]\n\n\nclass UserManager(IntegerIDMixin, user_manager_class[user.user, user_id_type]):\n    reset_password_token_secret = str(config.SECRET_KEY)\n    verification_token_secret = str(config.SECRET_KEY)\n\n    min_password_length: int = 10\n    max_password_length: int = 30\n    re_password_need_list: list[Pattern] = [\n        re.compile(r\"[a-zA-Z]\"),\n        re.compile(r\"[0-9]\"),\n        re.compile(r\"[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+\u003c\u003e@\\#$%\u0026\\\\\\=\\(\\'\\\"]\"),\n    ]\n    re_password_deny_list: list[Pattern] = []\n\n    async def validate_password(\n        self, password: str, user: user.user_create | user.user\n    ) -\u003e None:\n        if len(password) \u003c self.min_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at least {self.min_password_length} characters\"\n            )\n        elif len(password) \u003e self.max_password_length:\n            raise InvalidPasswordException(\n                reason=f\"Password should be at most {self.max_password_length} characters\"\n            )\n\n        for pattern in self.re_password_deny_list:\n            if pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password should not include {pattern.pattern}\"\n                )\n\n        for pattern in self.re_password_need_list:\n            if not pattern.search(password):\n                raise InvalidPasswordException(\n                    reason=f\"Password must include {pattern.pattern}\"\n                )\n\n    async def on_after_register(self, user: user.user, request: Request | None = None):\n        print(f\"User {user.id} has registered.\")\n\n    async def on_after_forgot_password(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"User {user.id} has forgot their password. Reset token: {token}\")\n\n    async def on_after_request_verify(\n        self, user: user.user, token: str, request: Request | None = None\n    ):\n        print(f\"Verification requested for user {user.id}. Verification token: {token}\")\n\n\nasync def get_user_manager(\n    user_db=Depends(get_user_db),\n) -\u003e AsyncGenerator[UserManager, None]:\n    yield UserManager(user_db)\n\n\ndef create_fastapi_users(\n    *backends: auth_backend_class[user.user, user_id_type],\n) -\u003e fastapi_users_class[user.user, user_id_type]:\n    return fastapi_users_class(\n        get_user_manager=get_user_manager, auth_backends=backends\n    )\n\n\n@dataclass(frozen=True)\nclass fastapi_user_class:\n    users: fastapi_users_class[user.user, user_id_type]\n\n    @classmethod\n    def init(cls) -\u003e \"fastapi_user_class\":\n        users = create_fastapi_users(*create_backend())\n        return cls(users=users)\n\n    @property\n    def backends(self) -\u003e Sequence[auth_backend_class[user.user, user_id_type]]:\n        return self.users.authenticator.backends  # type: ignore\n\n    @property\n    def user_manager_depends(self) -\u003e user_manager_type:\n        return Depends(self.users.get_user_manager)\n\n    def strategy_depends(self, num: int = 0, /) -\u003e strategy_type:\n        backend = self.backends[num]\n        return Depends(backend.get_strategy)\n```\n\n꽤 많이 바뀌긴 했지만, 실제로 사용할때는 이름정도만 바뀌지 사용법 자체는 변한게 없다. 바뀐 이름에 맞춰서 라우터와 테스트 코드를 수정해주면, 정상적으로 작동하는 것을 확인할 수 있다.\n\n이번 기회에 테스트 코드가 얼마나 좋은건지 알게됐다.. 긴가민가할때 `pytest --tb=short` 한방이면 의문이 해결된다.\n\n사실 변경할게 하나 더 남긴 했지만, 이거 아직 시도해보지 않았다.\n현재 헤더를 사용한 인증 방식인데, 쿠키를 사용하고, `access-token`과 `refresh-token`을 사용한 방식으로 변경해보려 한다. 다만 **`fastapi-users`** 자체적으로는 지원하지 않기에, 직접 작성할 필요가 있어서 약간 고민이 필요할듯.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","data":{"title":"fastapi 튜토리얼 -8.2- FastAPI Users v10 대응","date":"2022-05-07T23:00:58.369+09:00","tags":["fastapi","fastapi-users","python","sqlmodel","@all"],"page":"fastapi 튜토리얼","summary":"fastapi 사용법을 다시 공부할겸, 참고할만한 좋은 예제가 있어서 이 시리즈를 약간의 변경을 주고 따라가보려 한다."}}]],["파이썬 동시성 프로그래밍",[{"name":"파이썬으로 동시성 프로그래밍을 쉽게 하는법","content":"\n## 동시성 프로그래밍이란\n\n동시성 프로그래밍은, **한 사람이 두가지 이상의 일을 같이 작업하는 것**을 말합니다.\n\n예를 들자면, 한 사람이 세탁기를 돌리고, 세탁기가 돌아가던 중 설거지를 하고, 설거지를 하던 중 전화를 받고, 세탁기가 끝나서 빨래를 널고, 설거지를 마저 끝내는 것입니다.\n\n이것을 만약 순차적으로 한다면, 세탁기를 돌리고 끝날 때 까지 기다린 다음 빨래를 널고, 이후 설거지를 합니다. 설거지가 끝나지 않았으니 전화는 받을 수 없고, 설거지가 끝난 다음 전화를 받습니다.\n\n어떤 방식이 더 효율적인지는 따로 설명하지 않아도 알 수 있습니다.\n\n### `asyncio`, 동시성 프로그래밍의 아주 간단한 예\n\n```python\nimport asyncio\nfrom datetime import datetime\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await asyncio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    tasks = [just_sleep(num, 1) for num in range(5)]\n    await asyncio.gather(*tasks)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n`asyncio`는 파이썬의 동시성 프로그래밍을 위한 기본 라이브러리입니다. 동시성 프로그래밍을 위해서는 `async`와 `await` 키워드를 알아야 합니다.\n\n\u003e `async`는 이 함수가 다른 작업을 위해 기다릴 수 있다는 것을 의미합니다.\n\u003e `await`은 `async`로 정의된 함수가 기다리는 지점을 특정합니다.\n\n따라서 위 코드는 1초간 기다리는 5개의 작업을 실시하는 간단한 코드입니다.\n\n\u003e 1초간 기다리 행위는, 데이터를 쓰거나 읽는 등의 작업이 걸리는 시간을 흉내내는 것입니다.\n\n실제로 실행해보면, 다음과 같은 출력을 얻습니다.\n\n```log\n2021-11-27 16:17:25.901585:: num=0, second=1 sleep start\n2021-11-27 16:17:25.901626:: num=1, second=1 sleep start\n2021-11-27 16:17:25.901642:: num=2, second=1 sleep start\n2021-11-27 16:17:25.901653:: num=3, second=1 sleep start\n2021-11-27 16:17:25.901662:: num=4, second=1 sleep start\n2021-11-27 16:17:26.902915:: num=0, second=1 sleep end\n2021-11-27 16:17:26.902996:: num=1, second=1 sleep end\n2021-11-27 16:17:26.903025:: num=2, second=1 sleep end\n2021-11-27 16:17:26.903053:: num=3, second=1 sleep end\n2021-11-27 16:17:26.903080:: num=4, second=1 sleep end\n```\n\n`num=0`인 작업이 `await asyncio.sleep(sencond=1)`에서 1초간 대기하기 때문에, 그동안 `num=1`작업을 실행할 수 있습니다.\n\n\u003e #### 왜 `time.sleep`이 아닌 `asyncio.sleep`인가?\n\u003e\n\u003e `time.sleep`은 블로킹 함수입니다. 블로킹 함수는 `async`로 정의되지 않아 기다릴 수 없는 함수입니다. 만약 `asyncio.sleep`대신 `time.sleep`을 사용한다면, io작업을 흉내낸다기 보다, cpu작업을 흉내내게 됩니다.\n\n### 하지만 뭔가 어색하다\n\n구글에서 검색해서 얻을 수 있는 자료나, 시중에서 판매하는 책을 보면 `yield` 키워드를 쓴다던가, `ensure_future`를 쓴다던가, `get_running_loop`를 쓴다던가.. 최신의 `asyncio`의 사용법에 맞지 않은 방법을 소개하는 글이 많습니다.\n\n\u003e 물론 `ensure_future`나 `get_running_loop`와 같은 함수를 쓸 수도 있습니다. 하지만 **저수준 api를 다뤄야 할 때 필요하지, 대부분의 경우 그렇지 않습니다.**\n\n아직 파이썬에서 동시성 프로그래밍을 제대로 지원한지 얼마 되지 않아, 버전이 올라갈수록 변경사항이 많아서 이런 일이 생긴겁니다.\n\n## `trio`, 조금 더 현대적인 방식으로\n\n그렇다면 차라리 더 최근에 만들어진 라이브러리를 사용하는게 어떨까요? 적어도 검색했을때 헷갈리는 일은 없을테니까요.\n\n기본 라이브러리인 `asyncio` 대신 `trio`라는 라이브러리가 있습니다. 개인적으로 좋아하는 `open_nursery`라는 함수가 있습니다. ~~끔찍한 gather는 이제 그만두고~~ 앞에서 `asyncio`로 작성한 코드를 `trio`로는 어떻게 작성할 수 있을까요.\n\n```python\nfrom datetime import datetime\n\nimport trio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await trio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with trio.open_nursery() as nursery:\n        for num in range(5):\n            nursery.start_soon(just_sleep, num, 1)\n\n\nif __name__ == \"__main__\":\n    trio.run(main)\n```\n\n사실 여기서 달라진건 많이 없습니다. 특징적인 부분은 `gather`로 작업을 모으는 대신, `nursery` 블록에서 `nursery.start_soon` 메소드로 `just_sleep` 작업 5개를 지시한 것입니다.\n\n출력 결과를 보면 이전과 대동소이합니다.\n\n```log\n2021-11-27 16:38:19.661314:: num=4, second=1 sleep start\n2021-11-27 16:38:19.661370:: num=3, second=1 sleep start\n2021-11-27 16:38:19.661393:: num=2, second=1 sleep start\n2021-11-27 16:38:19.661415:: num=1, second=1 sleep start\n2021-11-27 16:38:19.661434:: num=0, second=1 sleep start\n2021-11-27 16:38:20.662955:: num=4, second=1 sleep end\n2021-11-27 16:38:20.663113:: num=3, second=1 sleep end\n2021-11-27 16:38:20.663196:: num=2, second=1 sleep end\n2021-11-27 16:38:20.663272:: num=1, second=1 sleep end\n2021-11-27 16:38:20.663347:: num=0, second=1 sleep end\n```\n\n### 다른게 별로 없는데 왜 `trio`를 써야하지\n\n위 코드만 봤을때, `trio`를 써서 얻는 이득은 그다지 없어 보입니다. 하지만 그건 지금 코드가 아주 간단한 형태로 작성되어 있기 때문에 그렇습니다. 이후 사용하게 될 `channel` (`anyio`에서는 `stream`) 과 `CancelScope`, `Semaphore` 에서 그 이점이 드러나게 됩니다.\n\n### 잘 작성된 document\n\n`trio`의 [document](https://trio.readthedocs.io/en/stable/index.html)는 꽤 잘만들었다 생각합니다. 사용하다 막히는 부분이 있을때 따로 검색하기 보다는 공식 문서를 다시 한번 읽어보는게 도움이 되는 경우가 더 많았습니다.\n\n### 아쉽게도 기존 asyncio와 호환 안됨\n\n`trio`는 다 좋은데 기존 `asyncio`와 호환이 되지 않습니다. 즉, 이미 `asyncio`로 작성된 코드가 있다면 `trio`를 사용하기 위해서는 전부 수정을 해야합니다.\n\n무엇보다도 `uvloop`를 지원하지 않습니다. `uvloop`는 간단한 사용법으로 파이썬 동시성 프로그래밍의 성능을 끌어올릴 수 있는데, `trio`에서는 사용할 수가 없습니다.\n\n그렇다면 `trio`의 기능적 특징을 가지고, `asyncio`와 호환되고, `uvloop`도 지원하는 그런 라이브러리는 없을까요? **있습니다.** `anyio`라는 라이브러리를 사용하면 됩니다.\n\n## `anyio`, 현대적 방식과 호환성을 한번에\n\n`anyio`는 `asyncio`와 `trio`를 둘 다 사용할 수 있습니다. `asyncio`를 사용하고 싶다면 백엔드로 `asyncio`를 지정하고, `trio`를 사용하고 싶다면 `trio`를 지정하기만 하면 됩니다. `uvloop`를 사용하고 싶다면? `use_uvloop=True` 파라미터를 입력하기만 하면 됩니다.\n\n\u003e 그렇다면 `trio`의 기능을 사용하기 위해 무조건 백엔드를 `trio`로 지정해야 할까요? **아닙니다.** `anyio`는 `trio`의 기능을 `asyncio`로 구현한 라이브러리이기 때문에, `asyncio`를 백엔드로 사용해도 아무 문제가 없습니다.\n\n앞에서 `asyncio`와 `trio`로 작성했던 코드를 `anyio`로 다시 작성하겠습니다.\n\n```python\nfrom datetime import datetime\n\nimport anyio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await anyio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with anyio.create_task_group() as task_group:\n        for num in range(5):\n            task_group.start_soon(just_sleep, num, 1)\n\n\nif __name__ == \"__main__\":\n    anyio.run(main, backend_options=dict(use_uvloop=True))\n```\n\n\u003e `uvloop` 사용이 가능하다는 것을 보이기 위해 `backend_options=dict(use_uvloop=True)` 파라미터를 추가했습니다. 추가하지 않아도 문제 없습니다.\n\n`trio`로 작성된 코드와 차이점이 있다면 `trio.open_nursery`가 `anyio.create_task_group`로 바뀐 것 정도입니다. 실제로 대부분 용어의 문제지, `trio`에서 작성된 [document](https://trio.readthedocs.io/en/stable/index.html)는 `anyio`에 대부분 적용이 가능합니다.\n\n### 상대적으로 빈약한 document\n\n`anyio`의 [document](https://anyio.readthedocs.io/en/stable/index.html)는 상대적으로 좀 부족하다는 느낌을 받았습니다. 그래서 쓰다가 부족한 부분이 있으면 `trio`의 [document](https://trio.readthedocs.io/en/stable/index.html)를 읽어보고, `trio`와 대응하는 `anyio`의 모듈을 찾아서 해결하곤 했습니다.\n\n## 내 선택은 `anyio`\n\n저는 동시성 프로그래밍을 해야 할 일이 있으면 우선 `anyio`를 사용하는 편입니다. 특히 제가 좋아하는 프레임워크인 `fastapi`에서 `anyio`를 사용하기 때문에 거리낌 없이 사용할 수 있습니다. (`fastapi`에서 사용하는 `starlette`의 특정 버전부터 `anyio`를 지원하기 때문에 가능한 것으로, `anyio`를 사용하려면 버전 확인이 필요합니다.)\n\n이후 글에서는 `anyio`의 메소드와 클래스를 활용하는 것에 대해 작성할 예정입니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/파이썬으로 동시성 프로그래밍을 쉽게 하는법","data":{"title":"파이썬으로 동시성 프로그래밍을 쉽게 하는법","date":"2021-11-27T17:20:16.241+09:00","tags":["anyio","async","asyncio","python","trio","@all"],"page":"파이썬 동시성 프로그래밍","summary":"asyncio? trio? anyio!"}},{"name":"파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2","content":"\n비동기 프로그래밍의 핵심은 무엇일까? 저는 **작업을 생성**하고, 각 작업의 **전환점을 명시**하고, 각 작업간 **정보를 주고받는 것**이라고 생각합니다.\n\n**전환점을 명시**하는 것은 `python`에 특별한 키워드로 추가됐기에, 명확합니다. 각 작업간 전환이 가능하다(`awaitable`이라고 하는 것 같습니다)는 것을 알리는 `async`와, 전환점을 명확하게 알리는 `await`입니다.\n\n그렇다면 **작업을 생성**하고, **정보를 주고받는 것**은 어떻게 해야할까요?\n\n## `anyio`의 작업 생성\n\n`anyio`는 `trio`의 작업 생성 방식을 따라합니다. 그리고 `trio`는 **암시적 동시성**이 없습니다. 따라서 모든 기능은 위에서 아래로 실행합니다.\n\n`trio`는 사용자가 작업을 생성할 때, 그 작업에 대한 책임을 지도록 설계되었습니다. 이 설계는 `async with` 블록으로 나타내며, 이 블록에서 `start_soon`메소드로 호출된 모든 `awaitable` 함수는 동시에 실행되는 하나의 작업으로 생성됩니다. `trio`는 이것을 `nursery`라고 명명했습니다.\n\n`anyio`에서는 이러한 과정을 `task_group`이라 명명해서 보다 직관적으로 알 수 있게 했습니다. 실제 코드로 확인해보겠습니다.\n\n```python\nfrom datetime import datetime\n\nimport anyio\n\n\nasync def just_sleep(num: int, second: float):\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep start\")\n    await anyio.sleep(second)\n    print(f\"{datetime.today()}:: {num=}, {second=} sleep end\")\n\n\nasync def main():\n    async with anyio.create_task_group() as task_group:\n        for num in range(5):\n            task_group.start_soon(just_sleep, num, 5)\n        return\n\n\nif __name__ == \"__main__\":\n    print(f\"{datetime.today()}:: main start\")\n    result = anyio.run(main)\n    print(f\"{datetime.today()}:: main end??? {result=}\")\n```\n\n이 코드에서 실제로 실행되는 함수는 `main` 함수입니다. 이 함수의 코드를 확인해보면, 우선 `async with anyio.create_task_group`으로 `task_group`을 생성합니다. 그리고 이 `task_group` 블록 안에서 `task_group.start_soon`메소드를 이용하여 5개의 `just_sleep`을 호출했습니다.\n\n따라서 이 `task_group` 블록에는, 총 5개의 `just_sleep` 작업이 예정되어있습니다. 하지만 `task_group` 블록을 나가기 전에, `return` 키워드를 작성해서, `task_group` 블록에 5개의 작업을 호출한 직후 해당 함수를 종료하도록 했습니다.\n\n만약 의도한대로 실행된다면, 5개의 `just_sleep` 작업이 생성되지만, 그 직후 main 함수는 `None`을 반환하고, main end??? 는 main start 출력 이후 1초 내에 출력될 것입니다.\n\n```log\n2021-11-29 17:56:17.798277:: main start\n2021-11-29 17:56:17.800793:: num=0, second=5 sleep start\n2021-11-29 17:56:17.800829:: num=1, second=5 sleep start\n2021-11-29 17:56:17.800853:: num=2, second=5 sleep start\n2021-11-29 17:56:17.800869:: num=3, second=5 sleep start\n2021-11-29 17:56:17.800884:: num=4, second=5 sleep start\n2021-11-29 17:56:22.806281:: num=0, second=5 sleep end\n2021-11-29 17:56:22.806401:: num=1, second=5 sleep end\n2021-11-29 17:56:22.806443:: num=2, second=5 sleep end\n2021-11-29 17:56:22.806479:: num=3, second=5 sleep end\n2021-11-29 17:56:22.806513:: num=4, second=5 sleep end\n2021-11-29 17:56:22.807098:: main end??? result=None\n```\n\n하지만 실제 결과는, `return`과 무관하게 생성한 작업이 모두 끝난 이후 `return`이 실행됩니다. 즉, 사용자는 작업을 생성할 때, 각 작업을 어떤식으로든 완료되는 것을 확인 할 의무가 있습니다. 만약 작업 도중 `return`을 실행할 일이 있다면, 그에 맞는 조건을 설정하여 해당 `task_group`을 종료시킨 다음 `return`하는 것이 맞습니다.\n\n말이 길어졌기에, 요약하자면\n\n\u003e 1. `awaitable` 함수는 `async with anyio.create_task_group` 블록 내부에서 `task_group.start_soon` 메소드로 호출한다.\n\u003e 2. 생성된 작업은, 어떤식으로든 완료시켜야 한다.\n\n이 2가지만 기억해도 큰 문제가 없습니다.\n\n## `anyio`의 정보 주고받기\n\nanyio에서 정보를 주고받을때 사용하는 것을 `stream`이라고 합니다. 이 `stream`은 크게 두가지로 분류되는데, 바이트 스트림과 객체 스트림입니다.\n\n객체 스트림은 기존에 사용하던 큐와 거의 같은 형태로 사용이 가능합니다. `stream`의 버퍼 사이즈를 지정하고, 버퍼 사이즈 만큼 객체를 입력하고, 버퍼에 객체가 있으면 그 객체를 가져오는 간단한 방식입니다. `trio`에서는 `channel`이라고 명명합니다.\n\n바이트 스트림은 약간 다릅니다. 만약 사용자가 `b'qwe'`, `b'rty'`라는 두개의 바이트 객체를 입력했다면, 이 스트림에서 객체를 받을 때, `b'qwe'`, `b'rty'`라고 받을 수도 있지만, `b'q'`, `b'wer'`, `b'ty'`라고 받을 수도 있고, `b'qwert'`, `b'y'`라고 받을 수도 있습니다. `trio`에서는 `stream`이라고 명명합니다.\n\n실제로 `stream`을 사용하는 코드로 확인하겠습니다.\n\n```python\nfrom datetime import datetime\nfrom random import uniform\n\nimport anyio\nfrom anyio.abc import ObjectReceiveStream, ObjectSendStream\n\n\nasync def ping(num: int, send: ObjectSendStream):\n    print(f\"{datetime.today()}:: {num=}, ping start\")\n    async with send:\n        sleep_time = uniform(0, 3)\n        await anyio.sleep(sleep_time)\n        await send.send((f\"ping from {num=}, {sleep_time=}\", sleep_time))\n    print(f\"{datetime.today()}:: {num=}, ping end\")\n\n\nasync def pong(receive: ObjectReceiveStream):\n    sleep_time_sum = 0\n    print(f\"{datetime.today()}:: pong start\")\n    async for text, sleep_time in receive:\n        print(f\"{datetime.today()}:: pong:: {text}\")\n        sleep_time_sum += sleep_time\n    print(f\"{datetime.today()}:: pong end:: {sleep_time_sum=}\")\n\n\nasync def main():\n    async with anyio.create_task_group() as task_group:\n        send, receive = anyio.create_memory_object_stream(0)\n        async with send:\n            for num in range(5):\n                task_group.start_soon(ping, num, send.clone())\n        async with receive:\n            task_group.start_soon(pong, receive.clone())\n\n\nif __name__ == \"__main__\":\n    result = anyio.run(main)\n```\n\n우선 `main`함수부터 확인하겠습니다.\n\n`create_task_group`으로 `task_group` 블록을 생성합니다. 그리고 `create_memory_object_stream`으로 각 작업간 정보를 주고받기 위한 `stream`을 생성합니다.\n\n\u003e 이때 생성된 `stream`은 send와 receive 두개로 나뉘어 반환됩니다.\n\n이어서 5개의 `ping`과 1개의 `pong` 작업을 호출해서, 실제로 `main`을 실행할 때 실행될 작업을 지정합니다.\n\n여기서 사용되는 `async with send`와 `async with receive`는 안전한 프로그래밍을 위해 필요한 문법으로, 해당 블록이 끝나면 따로 `close` 메소드를 호출 할 필요 없이, 자동으로 해당 객체를 닫습니다.\n\n그리고 `start_soon`으로 호출되는 각 작업에 send와 receive를 보낼 때 사용되는 `clone`메소드는, 해당 `stream`의 새로운 send와 receive를 생성해서 보내기 위해서 사용됩니다. 만약 send나 receive를 사용하는 작업이 하나가 아닐 때 `clone` 메소드를 사용하지 않는다면, 의도치 않은 `ClosedResourceError`를 만나게 될 수 있습니다.\n\n`main`에서 호출된 작업은 간단합니다.\n`ping`은 0~3초 사이의 랜덤한 시간동안 대기한 다음, 해당 시간에 대한 정보를 send를 이용해서 보냅니다.\n`pong`은 receive를 통해 받은 정보를 출력하고, 합산합니다.\n또한, 각 `ping` 작업은 `main`에서 사용된 방식과 같은 방식으로 `async with` 블록으로 구성되어 있으므로, 따로 `close` 메소드를 호출 할 필요가 없습니다.\n\n이 방식은 상당히 유용한데, 모든 send가 닫히고, 더이상 버퍼에 정보가 없다면 `async for` 블록 또한 자동으로 닫히게 됩니다.\n\n위 코드를 실행해보면 다음과 같은 출력을 확인할 수 있습니다.\n\n```log\n2021-11-29 18:34:55.095995:: num=0, ping start\n2021-11-29 18:34:55.096041:: num=1, ping start\n2021-11-29 18:34:55.096056:: num=2, ping start\n2021-11-29 18:34:55.096068:: num=3, ping start\n2021-11-29 18:34:55.096080:: num=4, ping start\n2021-11-29 18:34:55.096091:: pong start\n2021-11-29 18:34:55.348744:: num=4, ping end\n2021-11-29 18:34:55.348931:: pong:: ping from num=4, sleep_time=0.25142686937439906\n2021-11-29 18:34:56.042114:: num=3, ping end\n2021-11-29 18:34:56.042310:: pong:: ping from num=3, sleep_time=0.9448073290170278\n2021-11-29 18:34:56.779485:: num=1, ping end\n2021-11-29 18:34:56.779686:: pong:: ping from num=1, sleep_time=1.6822150526554853\n2021-11-29 18:34:56.925375:: num=2, ping end\n2021-11-29 18:34:56.925595:: pong:: ping from num=2, sleep_time=1.8275787340996095\n2021-11-29 18:34:57.535689:: num=0, ping end\n2021-11-29 18:34:57.535911:: pong:: ping from num=0, sleep_time=2.4386441219878816\n2021-11-29 18:34:57.536030:: pong end:: sleep_time_sum=7.144672107134403\n```\n\n바이트 스트림 또한 대동소이합니다.\n\n요약하자면\n\n\u003e 1. 바이트 스트림과 객체 스트림으로 정보를 주고받을 수 있다.\n\u003e 2. send와 receive 두개로 나누어 사용한다.\n\u003e 3. send 또는 receive를 사용하는 작업이 여러개라면 `clone` 메소드를 사용한다.\n\u003e 4. `async with`, `async for`를 사용하면 좀 더 깔끔하고 명확하게 작성할 수 있다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2","data":{"title":"파이썬으로 동시성 프로그래밍을 쉽게 하는법 - 2","date":"2021-11-29T18:42:54.419+09:00","tags":["anyio","async","python","@all"],"page":"파이썬 동시성 프로그래밍","summary":"anyio로 작업 생성 + 작업간 정보 주고받기"}}]],["FastAPI, sqlmodel로 간단한 crud api 생성",[{"name":"FastAPI, sqlmodel로 간단한 crud api 생성","content":"\n## 사용 라이브러리?프레임워크? 간단 소개\n\n### [FastAPI](https://fastapi.tiangolo.com/ko/)\n\npython type hint를 적극적으로 활용해서\n`rest api`를 만들때 생산성이 아주 좋습니다.\n`uvicorn`을 사용하기 때문에, `uvloop`로 성능도 준수해서 더욱 좋습니다.\n공식 [document](https://fastapi.tiangolo.com/ko/tutorial/)가 아주 잘 작성돼서 혼자 공부하기도 좋습니다.\n\n정말 좋으니까, `flask`를 써야할 일이 생긴다면 **꼭** `FastAPI`를 사용해보세요.\n\n### [SQLModel](https://sqlmodel.tiangolo.com/)\n\n`pydantic`과 `sqlalchemy`를 정교하게 섞어서 사용할 수 있도록 만든 라이브러리입니다.\n`FastAPI`와 작성자가 같습니다.\n`FastAPI`는 쿼리나 바디 등의 변수 타입 검증을 위해 `pydantic`을 사용하는데, `crud`용 테이블은 정작 `sqlalchemy`로 따로 작성해야해서 두번 작성하는 귀찮은 일이 많았습니다.\n`SQLModel`을 사용하면 그런 일이 없으니 편합니다.\n다만 아직 초기 개발 단계이고, 공식 [document](https://sqlmodel.tiangolo.com/tutorial/)도 그렇게 좋지는 않습니다.\n\n## api 작성 전 초기작업\n\npython 버전은 `3.9.9`를 사용합니다.\ndb는 `postgres`를 사용합니다.\n간단하게 만들 생각이기 때문에, 많이 설치하지 않습니다.\n`fastapi`, `uvicorn`, `email-validator`, `sqlmodel`, `asyncpg`\n이렇게 5개만 설치하겠습니다.\n\n`podman`를 간단하게나마 사용할 예정이기 때문에, `dockerfile`을 작성합니다.\n\n\u003e `podman`을 사용하지만 `dockerfile`을 사용하는 것 처럼, 그냥 `docker`를 사용하셔도 아무 문제가 없습니다.\n\u003e\n\u003e \u003e 저는 zshrc에 `podman`과 `podman-compose`를 각각 `docker`와 `docker-compose`로 alias설정했습니다.\n\n```\n# dockerfile\nFROM python:3.9-bullseye\n\nWORKDIR /api\n\nADD https://raw.githubusercontent.com/vishnubob/wait-for-it/master/wait-for-it.sh /\nRUN [\"chmod\", \"+x\", \"/wait-for-it.sh\"]\n\nCOPY ./requirements.txt /requirements.txt\nRUN pip install --no-cache-dir --upgrade -r /requirements.txt\n```\n\n처음에 추가한 `wait-for-it.sh`는 db가 정상적으로 생성되고, 연결이 가능한지 확인하기 위한 쉘스크립트입니다.\n\n`wait-for-it.sh`를 다운로드 한 다음 실행권한을 주고,\n로컬에 존재하는 `requirements.txt`를 가져와서 pip로 필요한 패키지를 설치하는 간단한 구성의 `dockerfile`입니다.\n\n이어서 db와 api에서 사용할 환경변수를 `.env`파일로 작성합니다.\n\n```bash\n# .env\nPOSTGRES_USER=safeuser\nPOSTGRES_PASSWORD=s@fep@ssw0rd\nPOSTGRES_DB=restapi\nPOSTGRES_PORT=8081\n\nRESTAPI_PORT=8000\nRESTAPI_OUT_PORT=8000\nRESTAPI_DEBUG=1\n```\n\n순서대로, sql에서 사용할 아이디, 비밀번호, database이름, 포트,\n그리고 FastAPI가 실행될 포트, 도커 외부에서 api에 접속할 포트, 디버그 여부 플래그입니다.\n\n그리고 `docker-compose.yml`을 작성합니다.\n\n```yml\n# docker-compose.yml\nversion: '3'\n\nservices:\n  db:\n    image: postgres:latest\n    env_file:\n      - .env\n    command: -p ${POSTGRES_PORT}\n    volumes:\n      - ./db:/var/lib/postgresql/data\n\n  api:\n    build:\n      context: .\n      dockerfile: ./dockerfile\n    image: restapi:latest\n    env_file:\n      - .env\n    command:\n      - bash\n      - -c\n      - |\n        /wait-for-it.sh db:${POSTGRES_PORT} -t 10\n        python main.py\n    ports:\n      - '${RESTAPI_OUT_PORT}:${RESTAPI_PORT}'\n    depends_on:\n      - db\n    volumes:\n      - ./api:/api\n      - /etc/localtime:/etc/localtime:ro\n```\n\n컨테이너가 종료되더라도 db가 유지될 수 있게 로컬경로의 db폴더를 마운트 할 예정입니다. `docker volume`을 사용해도 되지만, 지금은 별로 중요한게 아닙니다.\n\n빌드되는 이미지 명은 별 생각없이 restapi라고 했습니다.\napi 컨테이너는 우선 db가 연결 가능한 상태인지 확인하고, 최대 10초간 대기합니다.\n연결이 가능하거나, 10초가 지나면, 현재 폴더의 `main.py`를 실행하도록 했습니다.\n\nvolumes에 작성된 것 처럼, 로컬 경로의 api폴더를 컨테이너 내부의 /api에 마운트했습니다.\n당연하게도, 로컬 경로의 api폴더에 FastAPI로 작성할 모든 결과물이 들어가게 됩니다.\n\n끝으로 실제로 실행할 `main.py`를 작성합니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef index():\n    return {\"hello\": \"world\"}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=int(environ[\"RESTAPI_PORT\"]),\n        reload=bool(int(environ[\"RESTAPI_DEBUG\"])),\n    )\n```\n\ndb를 생성하긴 하지만, 당장은 db와 관련된 작업을 하지 않겠습니다. 다음 글에서 이어서 하는걸로..\n\n정상적으로 따라오셨다면, 다음과 같은 구조입니다.\n\n```\n.\n├── .env\n├── api\n│   └── main.py\n├── db\n├── docker-compose.yml\n├── dockerfile\n└── requirements.txt\n```\n\n이제 실행해봅시다.\n`docker-compose up`으로 실행이 가능합니다.\n\n이제 http://localhost:8000 에 접속하면\n\n```python\n{\"hello\":\"world\"}\n```\n\n을 확인할 수 있습니다.\n\n작성된 api를 확인하기 위해\nhttp://localhost:8000/docs 에 접속하면\n다음과 같이 확인할 수 있습니다.\n![](/images/dbba2083-54d9-4406-89d2-dfc5b61cf360-docs.png)\n\n다음에는 `SQLModel`을 사용해서 모델을 만들고,\n그 모델을 이용한 간단한 형태의 `crud` api를 생성해보겠습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성","date":"2021-11-25T22:13:02.346+09:00","tags":["fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"fastapi로 index만 구성하는 것 까지 진행"}},{"name":"FastAPI, sqlmodel로 간단한 crud api 생성 2","content":"\n## db접속 모듈 생성\n\n지난 글에서 db 컨테이너를 생성했지만 사용은 하지 않고 끝냈습니다. 이제 db를 연결하기 위한 작업을 진행하겠습니다.\n\n\u003e 저는 `fastapi`와 `sqlmodel`의 기능을 최대한 사용하기 위해 `Field`나 `Depends`, `Path` 등을 가능하다면 사용하지만, **사용하지 않아도 대부분의 경우 문제가 없습니다.** \u003e `fastapi` 와 `sqlmodel`이 **알아서 해결합니다.**\n\n`fastapi`는 `Depends`라는 재밌는 함수를 가지고 있습니다. 이걸 이용하면 코드를 깔끔하게 작성할 수 있는데, 이때 사용할 수 있는 형태로 database.py를 작성하겠습니다.\n\n```python\n# api/database.py\nfrom os import environ\nfrom typing import AsyncGenerator\n\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio.engine import create_async_engine\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\ndatabase = dict(\n    drivername=\"postgresql+asyncpg\",\n    username=environ[\"POSTGRES_USER\"],\n    password=environ[\"POSTGRES_PASSWORD\"],\n    host=\"db\",\n    port=environ[\"POSTGRES_PORT\"],\n    database=environ[\"POSTGRES_DB\"],\n)\nurl = URL.create(**database)\nengine = create_async_engine(url, echo=bool(int(environ[\"RESTAPI_DEBUG\"])))\n\n\nasync def get_session() -\u003e AsyncGenerator[AsyncSession, None]:\n    async with AsyncSession(engine) as session:\n        yield session\n\n\nasync def create_model_table() -\u003e None:\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\ndb에서 비동기 세션을 사용할 계획이므로, `create_engine`대신 `create_async_engine`을 사용합니다.\n\n`get_session`함수는 각 요청에서 사용할 session을 생성할때 사용하고,\n`create_model_table`은 작성한 모델에 대응하는 테이블을 db에 생성하는 함수입니다. 나중에 모델을 생성하고 나면, fastapi가 시작할때 자동으로 실행되도록 할 계획입니다.\n\n\u003e 만약 동기 세션을 사용한다면, `from sqlmodel import create_engine`으로 엔진을 생성하고,\n\u003e `AsyncSession` 대신 `from sqlmodel import Session`으로 `Session`을 사용하면 됩니다.\n\u003e 물론 `get_session`을 작성할 때, `async with` 대신 `with`로 바꿔야 합니다.\n\u003e 그리고 `create_model_table` 내부에서 `with context`를 사용할 필요 없이, `create_all` 메소드를 실행하면 됩니다.\n\n## db접속 모듈 테스트\n\n작성한 함수가 잘 실행되는지 확인하기 위해 main.py에 간단한 `get` api를 생성하겠습니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import get_session\n\n# 중략\n\n\n@app.get(\"/session_test\")\nasync def session_test(*, session: AsyncSession = Depends(get_session)):\n    data = await session.exec(text(\"select 1\"))  # type: ignore\n    return data.all()\n\n\n# 후략\n```\n\n\u003e `# type: ignore`는 `vscode`의 확장 프로그램인 `pylance`가 해당 라인의 정적 타입 확인을 하지 않도록 합니다.\n\u003e 이유는 모르겠는데, `text`가 `excutable`한데도 `excutable`한 객체로 인정하지를 않습니다.\n\u003e 사실 `sqlalchemy`자체가 정적 타입 체크시 많은 에러를 뿜긴 합니다.\n\n\u003e `session`의 `exec` 메소드는 `sqlalchemy`에 없는 메소드입니다. 기존 실행 메소드인 `execute`를 사용해도 무방하지만, `exec`는 `execute`의 `wrapper`이면서 type hint가 잘 되어 있으므로, 정적 타입 체크나 `vscode`의 자동완성 등에서 상당한 편의를 얻을 수 있습니다.\n\n`select 1` 쿼리를 실행하는 간단한 형태의 `get` api를 작성했습니다. 정상적으로 작성하셨다면\n\n```json\n[\n  {\n    \"?column?\": 1\n  }\n]\n```\n\n와 같은 결과를 받게 됩니다.\n여기서 사용된 `Depends`는 단순히 `session`을 받는 용도지만, 이 외에도 많은 사용법이 있습니다.\n관련 내용은 [여기](https://fastapi.tiangolo.com/tutorial/dependencies/)에서 확인할 수 있습니다.\n\n\u003e `fastapi`는 비동기 프로그래밍을 아주 잘 지원하기 때문에, **원한다면 그냥 `async def`를 사용하면 되고, 비동기가 아닌 io 작업이 있다면 그냥 `def`를 사용해도 됩니다. await 키워드를 사용하지 않더라도 async def를 사용해도 좋습니다. 어떻게 작성하든 `fastapi`가 알아서 잘 실행합니다.**\n\n## 사용할 모델 및 테이블 생성\n\n세션이 잘 붙은걸 확인했으니, 이제 사용할 모델을 생성하겠습니다.\n\n```python\n# api/model.py\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import EmailStr\nfrom sqlmodel import Field, SQLModel\n\n\nclass user(SQLModel, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n    registered_date: datetime = Field(default_factory=datetime.today)\n```\n\n`user`라는 모델이자 테이블인 클래스를 정의했습니다.\n`name`과 `email`은 필수값이고, `registered_date`는 자동으로 생성되도록 했습니다.\n\n\u003e `table=True` 파라미터는 `user` 클래스가 db에서 사용할 테이블이라는 것을 알려줍니다.\n\u003e 이 파라미터가 없으면, 이전에 작성한 `create_model_table` 함수를 실행해도 db에 테이블이 생성되지 않습니다.\n\npk로 지정한 `id`가 `Optional`이어서 의아할 수 있는데,\napi 서버에서 우선 `id`를 지정하지 않은 상태로 `user`인스턴스를 생성하고, 그 인스턴스를 `session`을 통해 추가하면 `user` 테이블에서는 정상적으로 `id`가 들어가게 됩니다.\n이후 api 서버에서 `id`를 확인하고 싶다면 `refresh`메소드를 사용하면 됩니다.\n\n### 테이블에 레코드를 추가하는 `post` api 생성\n\n이 과정을 담은 `post` api를 하나 생성하겠습니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\napp = FastAPI()\napp.on_event(\"startup\")(create_model_table)\n\n\n# 중략\n\n\n@app.post(\"/create_user\", response_model=user)\nasync def create_user(data: user, *, session: AsyncSession = Depends(get_session)):\n    user_instance = user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n# 후략\n```\n\n기존에 작성했던 `create_model_table`함수를 `app.on_event(...)` 데코레이터를 이용해서 자동으로 실행되도록 했습니다.\n현재 `main.py`에 `user` 클래스가 있으므로 api 서버가 실행될때 `user` 테이블이 db에 없다면 자동으로 생성됩니다.\n\n`.env` 파일에 `RESTAPI_DEBUG=1`로 작성하셨다면, 다음과 같은 쿼리로 테이블이 생성됐다는 것을 로그에서 확인할 수 있습니다.\n\n```sql\nCREATE TABLE \"user\" (\n        id SERIAL,\n        name VARCHAR NOT NULL,\n        email VARCHAR NOT NULL,\n        registered_date TIMESTAMP WITHOUT TIME ZONE,\n        PRIMARY KEY (id)\n)\n```\n\n\u003e 아직 문자열을 `nvarchar`로 간단하게 설정하는 방법은 `sqlmodel`에 없습니다. `sqlalchemy`의 `Column`을 직접 작성해서 `Field`에 대응하는 방식으로만 가능합니다.\n\u003e `type_` 파라미터를 사용할 수 있도록 PR된 상태이니, 다음 버전에서는 가능할 것 같습니다.\n\n다음과 같은 `body`로 `post`를 요청하면\n\n```json\n{\n  \"name\": \"string\",\n  \"email\": \"user@example.com\"\n}\n```\n\n다음과 같은 결과를 받게 됩니다.\n\n```json\n{\n  \"id\": 1,\n  \"registered_date\": \"2021-11-25T23:51:26.156134\",\n  \"name\": \"string\",\n  \"email\": \"user@example.com\"\n}\n```\n\n### 레코드를 조회하는 `get` api 생성\n\n이제 이 유저 정보를 조회하는 `get` api를 생성하겠습니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException, Path\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\n# 중략\n\n\n@app.get(\"/get_user/{user_id}\", response_model=user)\nasync def get_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    return user_instance\n\n\n# 후략\n```\n\n\u003e 여기서 사용된 `Path`는 **없어도 아무 문제가 없습니다.**\n\n`user_id`에 해당하는 `user`가 없을 경우 404에러를 반환하도록 했습니다.\n`fastapi`에서 제공하는 `Path`를 이용해서, `user_id`는 1 이상의 값만 받도록 제한했습니다. 내부적으로 `pydantic`을 사용하기 때문에, 빠르고 정확합니다.\n\n### 레코드를 수정하는 `patch` api 생성\n\n이어서 유저 정보를 수정하는 `patch` api를 작성합니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException, Path\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\n# 중략\n\n\n@app.patch(\"/update_user/{user_id}\", response_model=user)\nasync def update_user(\n    data: user,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n# 후략\n```\n\n`data.dict` 메소드의 `exclude_unset=True` 파라미터는 `user` 클래스에 정의된 속성이면서 사용자가 `body`에 포함하지 않은 값을 제외한 딕셔너리를 반환하게 합니다.\n\n`user_id=1`에 다음과 같은 `body`를 보내면\n\n```json\n{\n  \"name\": \"aaa\",\n  \"email\": \"aaaa@example.com\"\n}\n```\n\n다음과 같은 `user`를 반환합니다.\n\n```json\n{\n  \"id\": 1,\n  \"registered_date\": \"2021-11-25T23:51:26.156134\",\n  \"name\": \"aaa\",\n  \"email\": \"aaaa@example.com\"\n}\n```\n\n이전에 생성한 `get` api로 조회해보면, 정상적으로 수정된 것을 확인할 수 있습니다.\n\n### 레코드를 제거하는 `delete` api 생성\n\n마지막으로 `delete` api를 작성합니다.\n\n```python\n# api/main.py\nfrom os import environ\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException, Path\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom database import create_model_table, get_session\nfrom model import user\n\n# 중략\n\n\n@app.delete(\"/delete_user/{user_id}\")\nasync def delete_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is no {user_id=} user\")\n\n    await session.delete(user_instance)\n    await session.commit()\n\n    return user_id\n\n\n# 후략\n```\n\n`user_id=1`로 `delete` api를 요청 한 다음 `get` api를 요청하면 다음과 같은 메세지를 보냅니다.\n\n```json\n{\n  \"detail\": \"there is no user_id=1 user\"\n}\n```\n\n기초적인 형태의 `crud` api를 작성하고, 정상적으로 실행되는지 확인했습니다.\n몇몇 아쉬운 부분들이 눈에 띕니다.\n\n- 유저를 추가할때 중복을 확인하지 않는다.\n- 유저를 수정한 일자가 없다.\n- 왜 `response_model`은 user로 고정이지?\n- etc...\n\n이러한 부분들은 다음 글에서 확인하겠습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성 2","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성 2","date":"2021-11-26T00:21:45.352+09:00","tags":["crud","fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"db와 연결 후 기초적인 형태의 crud api 생성"}},{"name":"FastAPI, sqlmodel로 간단한 crud api 생성 3","content":"\n이전 글에서 몇가지 의문점을 남겨놨습니다.\n\n- 유저를 추가할때 중복을 확인하지 않는다.\n- 유저를 수정한 일자가 없다.\n- 왜 response_model은 user로 고정이지?\n- etc...\n\n**다음 글**에서, 이러한 부분들을 고쳐가겠습니다.\n\n## 그 전에...\n\n지난 글까지 작성한 스크립트는 모두 한 폴더에 모여있습니다. 이런 구조는 지금같이 간단한 수준일때는 문제가 없지만, 점점 개발을 힘들게 만듭니다.\n그렇기 때문에, 간단한 형태로 구조화할 생각입니다.\n**아직 많이 부족하여, 효율적인 구조일지는 장담할 수 없습니다..**\n\n계획은 이렇습니다.\n\n\u003e 1. api 서버를 실행하는 스크립트를 최상위 폴더에 위치하고, `scripts` 폴더를 생성\n\u003e 2. `scripts` 폴더에 `config`, `database`, `models`, `routes` 폴더를 생성\n\u003e    \u003e `config` : 환경설정과 관련된 스크립트를 모아놓습니다. **다른 경로의 스크립트를 참조하지 않습니다.** \u003e\u003e `database` : db와 관련된 기본적인 작업에 대한 스크립트를 모아놓습니다.\n\u003e    \u003e `models` : 여러 api를 작성할 때 사용될 모델에 대한 스크립트를 모아놓습니다.\n\u003e    \u003e `routes` : 여러 api에 대해 입맛에 맞게 구조화하여 배치합니다.\n\u003e\n\u003e ### 왜 최상위 폴더가 아닌 `scripts` 폴더에?\n\u003e\n\u003e 파이썬에는 상대참조와 절대참조가 있습니다.\n\u003e 아직 많이 부족하여, 정확히 이건 어떻고 저건 어떻다 말할 수준은 못되지만, **상대참조는 패키지로 구성된 스크립트에서만 가능하다고 알고 있습니다.**\n\u003e 그렇기에, `scripts`폴더를 최상위 경로에서 사용할 수 있는 로컬 패키지처럼 사용하기 위해 `scripts`폴더를 생성 후, 하위 경로로 다른 폴더를 위치하게 했습니다.\n\n### 1. config\n\n앞으로 사용할 `settings` 클래스를 정의할 스크립트인 `default.py`를 생성하겠습니다.\n\n```python\n# api/scripts/config/default.py\nfrom typing import Any\n\nfrom pydantic import BaseSettings, Field\n\n\nclass database(BaseSettings):\n    drivername: str = \"postgresql+asyncpg\"\n    host: str = \"db\"\n\n    username: str = Field(..., env=\"POSTGRES_USER\")\n    password: str = Field(..., env=\"POSTGRES_PASSWORD\")\n    port: int = Field(..., env=\"POSTGRES_PORT\")\n    database: str = Field(..., env=\"POSTGRES_DB\")\n\n    query: dict[str, Any] = Field(default_factory=dict)\n\n\nclass settings(BaseSettings):\n    debug: bool = Field(..., env=\"RESTAPI_DEBUG\")\n\n    run_port: int = Field(..., env=\"RESTAPI_PORT\")\n    access_port: int = Field(..., env=\"RESTAPI_OUT_PORT\")\n\n    database: database = database()\n```\n\n그리고 `__ init__.py`를 생성해서 `settings` 클래스의 인스턴스를 생성합니다.\n\n```python\n# api/scripts/config/__init__.py\nfrom .default import settings\n\n__all__ = (\"settings\",)\n\nsettings = settings()\n```\n\n이제 `scripts.config.settings`로 설정값에 접근할 수 있습니다.\n\n### 2. database\n\n`routes`에서 빈번하게 사용될 `get_session`과 같은 범용적인 db관련 스크립트를 작성합니다.\n\n```python\n# api/scripts/database/default.py\nfrom typing import AsyncGenerator\n\nfrom sqlalchemy.engine.url import URL\nfrom sqlalchemy.ext.asyncio.engine import create_async_engine\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ..config import settings\n\nurl = URL.create(**settings.database.dict())\nengine = create_async_engine(url, echo=settings.debug)\n\n\nasync def get_session() -\u003e AsyncGenerator[AsyncSession, None]:\n    async with AsyncSession(engine) as session:\n        yield session\n\n\nasync def create_model_table() -\u003e None:\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\n기존에 최상위 경로에 생성했던 `database.py`와 달라진 점은, **직접 환경변수를 불러오지 않고,** 이전에 작성한 `scripts.config.settings`를 불러와서 사용한다는 것입니다.\n\n이어서 `__ init__.py`를 작성해서, 실제로 사용할 함수를 모아놓습니다.\n\n```python\n# api/scripts/database/__init__.py\nfrom .default import create_model_table, get_session\n\n__all__ = (\"get_session\", \"create_model_table\")\n```\n\n### 3. models\n\n우선 `user`폴더를 생성한 다음, 그 폴더에 `__ init__.py`를 작성하겠습니다.\n\n\u003e 굳이 이렇게 하는 이유는\n\n- 각 라우트 혹은 모델별로 다른 폴더에 관리하면 편했던 기억이 있어서 그렇고,\n- 지금은 사용하지 않지만, `orjson`으로 `json`을 loads, dumps 할때, `pydantic`의 `BaseModel`을 상속한 새로운 모델을 만들어서 사용하는데, 그 모델을 `models.__init__.py`에 작성해두면 나중에 쓸때 편했기 때문입니다.\n\n**`api/scripts/models/user/__init__.py`는 기존 `model.py`와 같으므로 생략합니다.**\n\n### 4. routes\n\n기존에 `main.py`에 있던 `crud` api를 옮깁니다.\n이것도 `models`와 같이, `user`폴더를 생성 한 다음 해당 폴더에 스크립트를 작성합니다.\n\n우선 `main.py`에 정의된 `app`에 연결할 라우터를 정의할 `app.py`부터 작성합니다.\n\n```python\n# api/scripts/routes/user/app.py\nfrom fastapi import APIRouter\n\napp = APIRouter()\n```\n\n굳이 이렇게 따로 뺀 이유는 순환 참조 오류를 방지하기 위해서 입니다.\n\n여기서 `tags`와 `prefix`를 설정할 수도 있지만, 개인적으로 `main.py`에서 일괄적으로 확인하고 수정할 수 있는게 편해서 지금은 하지 않았습니다.\n\n다음으로 이전에 작성한 `crud` api를 모아놓은 `crud.py`를 작성합니다.\n\n```python\n# api/scripts/scripts/routes/user/crud.py\nfrom fastapi import Depends, HTTPException, Path\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ...database import get_session\nfrom ...models import user\nfrom .app import app\n\n\n@app.post(\"/create_user\", response_model=user.user)\nasync def create_user(data: user.user, *, session: AsyncSession = Depends(get_session)):\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.get(\"/get_user/{user_id}\", response_model=user.user)\nasync def get_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    return user_instance\n\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user)\nasync def update_user(\n    data: user.user,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.delete(\"/delete_user/{user_id}\")\nasync def delete_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    await session.delete(user_instance)\n    await session.commit()\n\n    return user_id\n```\n\n여기서 사용되는 `app`은 `main.py`의 `app`이 아닌, 같은 폴더의 `app.py`의 `app`입니다.\n\n마지막으로 `__ init__.py`를 작성합니다.\n\n```python\n# api/scripts/routes/user/__init__.py\nfrom .crud import app\n```\n\n여기서 불러온 앱은 `crud` api가 기억된 상태로, 나중에 `main.py`에서 불러옵니다.\n\n이제 `main.py`를 정리합니다.\n\n```python\n# api/main.py\nimport uvicorn\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.sql import text\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom scripts.config import settings\nfrom scripts.database import create_model_table, get_session\nfrom scripts.routes import user\n\napp = FastAPI()\napp.on_event(\"startup\")(create_model_table)\napp.include_router(user.app, prefix=\"/user\", tags=[\"user\"])\n\n\n@app.get(\"/\")\ndef index():\n    return {\"hello\": \"world\"}\n\n\n@app.get(\"/session_test\")\nasync def session_test(*, session: AsyncSession = Depends(get_session)):\n    data = await session.exec(text(\"select 1\"))  # type: ignore\n    return data.all()\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=settings.run_port,\n        reload=settings.debug,\n    )\n```\n\n`api`폴더는 최상위 폴더이므로, `scripts`를 패키지처럼 다루면 됩니다.\n`user` 라우터는 `prefix=\"user\"`, `tags=[\"user\"]`로 파라미터를 줬습니다. 나중에 docs에서 확인해보면 차이를 알 수 있습니다.\n이제는 사용하지 않는 기존 `api/database.py`, `api/model.py`를 제거합니다.\n정상적으로 진행했다면, 다음과 같은 구조를 가지게 됩니다.\n\n```\n.\n├── .env\n├── api\n│   ├── main.py\n│   └── scripts\n│       ├── config\n│       │   ├── __init__.py\n│       │   └── default.py\n│       ├── database\n│       │   ├── __init__.py\n│       │   └── default.py\n│       ├── models\n│       │   └── user\n│       │       └── __init__.py\n│       └── routes\n│           └── user\n│               ├── __init__.py\n│               ├── app.py\n│               └── crud.py\n├── db [error opening dir]\n├── docker-compose.yml\n├── dockerfile\n└── requirements.txt\n```\n\n`db`폴더에 접근이 불가능 한 것은, 컨테이너 내부에서 관리자 권한으로 작성됐기 때문입니다.\n이제 `docker-compose up`으로 실행해서 docs를 확인해봅시다.\n![](/images/80800d72-874a-4bc0-afd5-80792cf91bef-docs.png)\napi 경로에 `user`가 추가됐고,\n각 api가 사전에 설정한 `tags`를 기준으로 나뉘어 진 것을 확인할 수 있습니다.\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성 3","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성 3","date":"2021-11-26T22:52:37.564+09:00","tags":["crud","fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"crud api를 보완하기 전, 구조를 적당히 변환"}},{"name":"FastAPI, sqlmodel로 간단한 crud api 생성 4","content":"\n이제 기존에 작성한 `crud` api를 보완해보겠습니다.\n\n## 유저를 추가할때 중복 확인\n\n기존 작성된 `create` api는 입력받은 `body`를 그대로 db에 새로운 레코드로 추가하는 역할만 했습니다.\n이제 `email`속성을 기준으로 중복을 확인 한 다음 레코드로 추가할 수 있게 코드를 수정하겠습니다.\n\n```python\n# api/scripts/routes/user/crud.py\n(전략)\n\n@app.post(\"/create_user\", response_model=user.user)\nasync def create_user(data: user.user, *, session: AsyncSession = Depends(get_session)):\n    user_email = await session.exec(select(user.user.email))  # type: ignore\n    if data.email in user_email: # type: ignore\n        raise HTTPException(status_code=400, detail=\"동일한 email 유저 있음\")\n\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n(후략)\n```\n\n이제 중복된 유저 데이터를 입력하면 다음과 같은 400에러와 함께 다음과 같은 값을 반환합니다.\n\n```json\n{\n  \"detail\": \"동일한 email 유저 있음\"\n}\n```\n\n로그를 확인해보면 다음과 같이 에러를 반환하는 것을 확인할 수 있습니다.\n\n```sql\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".email\nFROM \"user\"\nINFO sqlalchemy.engine.Engine [no key 0.00018s] ()\nINFO:     10.0.2.100:43750 - \"POST /user/create_user HTTP/1.1\" 400 Bad Request\nINFO sqlalchemy.engine.Engine ROLLBACK\n```\n\n만약 중복이 아닌 데이터를 입력하면, 다음과 같은 로그를 확인할 수 있습니다.\n\n```sql\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".email\nFROM \"user\"\nINFO sqlalchemy.engine.Engine [no key 0.00016s] ()\nINFO sqlalchemy.engine.Engine INSERT INTO \"user\" (name, email, registered_date) VALUES (%s, %s, %s) RETURNING \"user\".id\nINFO sqlalchemy.engine.Engine [cached since 276.6s ago] ('test', 'test@example.com', datetime.datetime(--))\nINFO sqlalchemy.engine.Engine COMMIT\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\nINFO sqlalchemy.engine.Engine SELECT \"user\".id, \"user\".name, \"user\".email, \"user\".registered_date\nFROM \"user\"\nWHERE \"user\".id = %s\nINFO sqlalchemy.engine.Engine [cached since 276.6s ago] (3,)\nINFO:     10.0.2.100:43796 - \"POST /user/create_user HTTP/1.1\" 200 OK\nINFO sqlalchemy.engine.Engine ROLLBACK\n```\n\n\u003e 지금은 api 서버에서 처리하는 방법을 보이기 위해 이렇게 코드를 작성했습니다.\n\u003e 하지만 **더 간단하게 중복을 제외하는 방법**이 있습니다.\n\u003e `user.user` 모델을 정의할 때, `email` 필드에 `sa_column_kwargs={\"unique\": True}` 파라미터를 추가하면 됩니다.\n\u003e 그러면 api 서버가 아닌, db에서 중복을 확인하고, 에러를 반환할 것입니다.\n\u003e 다만, **이 에러에 대한 예외처리는 직접 해야합니다.**\n\n## 유저 정보를 수정한 최종 일자 기록\n\n기존 `user` 모델은 최초 입력 일자에 대한 정보만 보존하고, 수정한 일자에 대해서는 보존하지 않습니다. 이는 테이블에 새로운 필드를 추가해야 가능한 일이므로, `user`모델을 직접적으로 수정하겠습니다.\n\n```python\n# api/scripts/models/user/__init__.py\n(전략)\n\nclass user(SQLModel, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n    registered_date: datetime = Field(default_factory=datetime.today)\n    last_updated_date: datetime = Field(default_factory=datetime.today)\n```\n\n`last_updated_date` 필드만 추가하고 끝냈습니다.\n지금 이상태 그대로 진행하면 `update` api를 수정하더라도, 에러를 반환할 것입니다. 기존에 db 생성한 `user`테이블에는 `last_updated_date` 필드가 없기 때문입니다.\nsql의 `alter` 쿼리를 사용해도 되고, `sqlalchemy`의 `drop_all` 메소드를 사용해도 됩니다.\n지금은 개발 초기중의 초기이므로 `drop_all`로 해결하겠습니다.\n\n```python\n# api/scripts/database/default.py\n(전략)\n\nasync def create_model_table() -\u003e None:\n    async with engine.begin() as conn:\n        if settings.debug:\n            await conn.run_sync(SQLModel.metadata.drop_all)\n        await conn.run_sync(SQLModel.metadata.create_all)\n```\n\n기존에 없던 `await conn.run_sync(SQLModel.metadata.drop_all)`를 추가했습니다.\n`create_model_table`함수가 이미 서버를 시작할때 실행되도록 설정돼 있기 때문에, 이제 서버를 시작하면 작성한 모델에 대응하는 테이블을 모두 `drop`하고 다시 `create`할 것입니다.\n개발중에만 사용하자는 의미로 `settings.debug`를 확인하도록 했습니다. 실제로는 더 엄격하게 확인하는게 맞습니다.\n\n이제 `update` api를 수정하겠습니다.\n\n```python\n# api/scripts/routes/user/crud.py\n\nfrom datetime import datetime\n\nfrom fastapi import Depends, HTTPException, Path\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom ...database import get_session\nfrom ...models import user\nfrom .app import app\n\n(중략)\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user)\nasync def update_user(\n    data: user.user,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    user_instance.last_updated_date = datetime.today()\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n(후략)\n```\n\n`user_instance.last_updated_date = datetime.today()`가 추가됐습니다.\n이제 정상적으로 `update` api가 실행되면, `last_update_date` 값이 변합니다.\n\n실제로 실행해보면, 다음과 같은 결과를 반환받습니다.\n\n```json\n{\n  \"id\": 1,\n  \"registered_date\": \"2021-11-26T23:59:37.359332\",\n  \"last_updated_date\": \"2021-11-26T23:59:52.837064\",\n  \"name\": \"aaa\",\n  \"email\": \"user@example.com\"\n}\n```\n\n## 각 api의 `response_model`과 `body` 형태 수정\n\n지금까지 작성된 `crud` api는 `delete`를 제외하고 `response_model=user.user` 파라미터를 가지고 있습니다. 이것은 반환한 값이 `user.user` 인스턴스이고, `user.user` 의 스키마로 데이터를 반환해라는 의미입니다.\n\n하지만 모든 api에서 그렇게 하는 것은 **위험한 일**입니다.\n지금은 따로 설정하지 않았지만 사용자의 **비밀번호**가 필드에 있을 수도 있고, **민감한 개인정보** 또한 가능합니다.\n\n또한 입력받는 `body` 역시 `user.user`의 스키마로 구성된 데이터를 받습니다. 하지만 이것은 불필요한 일이고, 어쩌면 **오류를 발생시킬 수도 있습니다.**\n\n사용자가 `user`를 추가할 때, `id`나 `registered_date`와 같이 레코드에 자동으로 입력되는 값은 **사용자가 입력한 값을 받을 필요도 없고, 받아선 안되는 값입니다.**\n\n따라서, 사용자가 입력하는 값과, 사용자에게 반환할 값에 대한 새로운 스키마가 필요합니다. 이에 대한 모델을 새로 생성하면서, 기존의 모델을 정의하는데 있어서 **약간의 변화**를 주겠습니다.\n\n```python\n# api/scripts/models/user/__init__.py\n\n(전략)\n\nclass user_base(SQLModel):\n    name: str = Field(..., min_length=1, nullable=False)\n    email: EmailStr = Field(..., nullable=False)\n\n\nclass user_create(user_base):\n    pass\n\n\nclass user_read(user_base):\n    id: int\n\n\nclass user_update(user_base):\n    name: Optional[str] = Field(None, min_length=1)\n    email: Optional[EmailStr] = None\n\n\nclass user(user_base, table=True):\n    id: Optional[int] = Field(None, primary_key=True)\n    registered_date: datetime = Field(default_factory=datetime.today)\n    last_updated_date: datetime = Field(default_factory=datetime.today)\n```\n\n`user_base`를 기준으로 `create`, `read`, `update`에 대응하는 모델과 `user` 테이블에 해당하는 모델을 생성했습니다.\n\n\u003e `user_update`는 `user_base`에서 정의된 모든 필드를 덮어씌우지만, 그렇지 않은 경우도 있을 수 있으니 일단 상속했습니다.\n\n이전에 `table=True` 파라미터가 있어야 db에 테이블이 생성된다고 한 적이 있습니다. 위 코드에서 확인할 수 있듯이, `user` 클래스만 `table=True` 파라미터를 가지고 있습니다. 따라서 `user` 클래스를 제외한 모델은 사실상 `pydantic`의 모델로 활용하게 됩니다.\n\n이제 이 모델을 적용한 `crud` api를 수정합니다.\n\n```python\n# api/scripts/routes/user/crud.py\n\n(전략)\n\n@app.post(\"/create_user\", response_model=user.user_read)\nasync def create_user(\n    data: user.user_create, *, session: AsyncSession = Depends(get_session)\n):\n    user_email = await session.exec(select(user.user.email))  # type: ignore\n    if data.email in user_email:  # type: ignore\n        raise HTTPException(status_code=400, detail=\"동일한 email 유저 있음\")\n\n    user_instance = user.user.from_orm(data)\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.get(\"/get_user/{user_id}\", response_model=user.user_read)\nasync def get_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    return user_instance\n\n\n@app.patch(\"/update_user/{user_id}\", response_model=user.user_read)\nasync def update_user(\n    data: user.user_update,\n    user_id: int = Path(..., ge=1),\n    *,\n    session: AsyncSession = Depends(get_session),\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    update_data = data.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(user_instance, key, value)\n\n    user_instance.last_updated_date = datetime.today()\n\n    session.add(user_instance)\n    await session.commit()\n    await session.refresh(user_instance)\n\n    return user_instance\n\n\n@app.delete(\"/delete_user/{user_id}\")\nasync def delete_user(\n    user_id: int = Path(..., ge=1), *, session: AsyncSession = Depends(get_session)\n):\n    user_instance = await session.get(user.user, user_id)\n    if not user_instance:\n        raise HTTPException(status_code=404, detail=f\"there is not {user_id=} user\")\n\n    await session.delete(user_instance)\n    await session.commit()\n\n    return user_id\n```\n\n`reponse_model`을 `user.user_read`로 수정하고, `body`에 해당하는 `data`의 타입을 `user.user_create` 또는 `user.user_update`로 수정했습니다.\n`response_model`을 `user.user_read`로 정했기 때문에, `user.user` 인스턴스를 반환하더라도, `user.user_read`의 스키마에 따라 값이 반환됩니다.\n![](/images/9a191a49-09af-4cad-acf6-fe48c31b5fa5-docs.png)\ndocs에서 한 눈에 확인 가능합니다.\n\n## 끝으로..\n\n더 적고 싶은데, 더 적을게 뭐가 있을지 잘 모르겠어요.\n일단 여기서 중단\n","mtime":"2022-08-13T00:12:20.000+09:00","href":"velog/FastAPI, sqlmodel로 간단한 crud api 생성 4","data":{"title":"FastAPI, sqlmodel로 간단한 crud api 생성 4","date":"2021-11-27T00:28:51.285+09:00","tags":["crud","fastapi","python","sqlmodel","@all"],"page":"FastAPI, sqlmodel로 간단한 crud api 생성","summary":"이제 기존에 작성한 crud api를 보완해보겠습니다."}}]]]},"__N_SSG":true},"page":"/posts/@page/[idx]","query":{"idx":"1"},"buildId":"MQ_lMVQgBI0RkmUA6wvVT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>