import{a as M,i as p,k as O,a4 as x,b as W,V as j,d as V,a2 as L,a0 as X,f as Y,l as b,q as C,a1 as B}from"./lzQ-8W9p.js";const D=Symbol.for("nuxt:client-only"),Q=M({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(e,{slots:t,attrs:n}){const o=p(!1);return O(()=>{o.value=!0}),x(D,!0),r=>{var u;if(o.value)return(u=t.default)==null?void 0:u.call(t);const s=t.fallback||t.placeholder;if(s)return s();const i=r.fallback||r.placeholder||"",a=r.fallbackTag||r.placeholderTag||"span";return W(a,n,i)}}}),A=()=>j("color-mode").value,y="light",G=()=>new Set(["light","dark"]),T=e=>G().has(e),R=V({id:"color_schema",state:()=>({color_schema:y}),getters:{safe_color_schema:()=>{const e=A();return e.unknown||e.preference==="system"||!T(e.value)?y:e.value}},actions:{set_color_schema_safe(e){if(T(e)){const t=A();t.preference=e,this.color_schema=e}},toggle_color_schema(){this.safe_color_schema==="light"?this.set_color_schema_safe("dark"):this.set_color_schema_safe("light")}}});function E(e){return L()?(X(e),!0):!1}function w(e){return typeof e=="function"?e():Y(e)}const q=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const N=e=>e!=null,$=Object.prototype.toString,z=e=>$.call(e)==="[object Object]",_=()=>{};function v(e){var t;const n=w(e);return(t=n==null?void 0:n.$el)!=null?t:n}const g=q?window:void 0;function F(...e){let t,n,o,r;if(typeof e[0]=="string"||Array.isArray(e[0])?([n,o,r]=e,t=g):[t,n,o,r]=e,!t)return _;Array.isArray(n)||(n=[n]),Array.isArray(o)||(o=[o]);const s=[],i=()=>{s.forEach(l=>l()),s.length=0},a=(l,c,m,h)=>(l.addEventListener(c,m,h),()=>l.removeEventListener(c,m,h)),u=C(()=>[v(t),w(r)],([l,c])=>{if(i(),!l)return;const m=z(c)?{...c}:c;s.push(...n.flatMap(h=>o.map(d=>a(l,h,d,m))))},{immediate:!0,flush:"post"}),f=()=>{u(),i()};return E(f),f}function H(){const e=p(!1),t=B();return t&&O(()=>{e.value=!0},t),e}function J(e){const t=H();return b(()=>(t.value,!!e()))}function K(e,t,n={}){const{root:o,rootMargin:r="0px",threshold:s=0,window:i=g,immediate:a=!0}=n,u=J(()=>i&&"IntersectionObserver"in i),f=b(()=>{const d=w(e);return(Array.isArray(d)?d:[d]).map(v).filter(N)});let l=_;const c=p(a),m=u.value?C(()=>[f.value,v(o),c.value],([d,I])=>{if(l(),!c.value||!d.length)return;const S=new IntersectionObserver(t,{root:v(I),rootMargin:r,threshold:s});d.forEach(k=>k&&S.observe(k)),l=()=>{S.disconnect(),l=_}},{immediate:a,flush:"post"}):_,h=()=>{l(),m(),c.value=!1};return E(h),{isSupported:u,isActive:c,pause(){l(),c.value=!1},resume(){c.value=!0},stop:h}}function U(e,t={}){const{window:n=g,scrollTarget:o,threshold:r=0}=t,s=p(!1);return K(e,i=>{let a=s.value,u=0;for(const f of i)f.time>=u&&(u=f.time,a=f.isIntersecting);s.value=a},{root:o,window:n,threshold:r}),s}function Z(e={}){const{window:t=g,behavior:n="auto"}=e;if(!t)return{x:p(0),y:p(0)};const o=p(t.scrollX),r=p(t.scrollY),s=b({get(){return o.value},set(a){scrollTo({left:a,behavior:n})}}),i=b({get(){return r.value},set(a){scrollTo({top:a,behavior:n})}});return F(t,"scroll",()=>{o.value=t.scrollX,r.value=t.scrollY},{capture:!1,passive:!0}),{x:s,y:i}}export{Q as _,U as a,Z as b,R as u};
